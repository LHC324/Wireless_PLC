C51 COMPILER V9.60.0.0   TIMER                                                             03/03/2023 11:28:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\Objects\timer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\timer.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeModB
                    -us\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\timer.lst) OBJECT(.\Objects\timer.obj)

line level    source

   1          #include "timer.h"
   2          #include "systemTimer.h"
   3          
   4          TIM_HandleTypeDef Timer0;
   5          PUBLIC_TIMER16 PublicTimer16;
   6          
   7          /*********************************************************
   8          * 函数名：void WDT_init(void)
   9          * 功能：  初始化看门狗
  10          * 参数：
  11          * 作者：
  12          * note：
  13          *
  14          **********************************************************/
  15          //void WDT_init(void)
  16          //{
  17          ////  WDT_CONTR = 0x23;                           //使能看门狗,溢出时间约为0.5s
  18          //    WDT_CONTR = 0x24;                           //使能看门狗,溢出时间约为1s
  19          ////  WDT_CONTR = 0x27;                           //使能看门狗,溢出时间约为8s
  20          //}
  21          
  22          //void CLRWDT(void)
  23          //{
  24          //              WDT_CONTR |= 0x10;//喂狗
  25          //}
  26          
  27          /*********************************************************
  28          * 函数名： Timer0_Init()
  29          * 功能：   定时器0 的初始化设置
  30          * 参数：   无
  31          * 作者：   LHC
  32          * note：
  33          *                  定时器2、3、4均工作在16bit自动重载模式
  34          **********************************************************/
  35          
  36          void Timer0_Init(void)
  37          {
  38   1              Timer0.Instance = TIMER0;
  39   1              Timer0.Register_AUXR = T0X12; //12T模式
  40   1              Timer0.Timer_Mode = 0x00;
  41   1              Timer0.Timer_Count = (COUNTMAX - (T12_MODE));
  42   1              Timer0.RunTimer_Enable = true;            //开启定时器0
  43   1              Timer0.Interrupt_Enable = true;           //开启定时器0中断
  44   1              Timer0.Timer_NVIC.Register_IP = 0x20; //定时器0优先级为11，最高优先级
  45   1              Timer0.Timer_NVIC.Register_IPH = 0x20;
  46   1              TIM_Base_MspInit(&Timer0);
  47   1      }
  48          
  49          void TIM_Base_MspInit(TIM_HandleTypeDef *const tim_baseHandle)
  50          {
  51   1              if (tim_baseHandle->Instance == TIMER0)
  52   1              { //首次初始化，把TMOD和AUXR全部置零
  53   2                      AUXR = tim_baseHandle->Register_AUXR;
  54   2                      TMOD = tim_baseHandle->Timer_Mode;                        //模式0
C51 COMPILER V9.60.0.0   TIMER                                                             03/03/2023 11:28:23 PAGE 2   

  55   2                      TL0 = (uint8_t)(tim_baseHandle->Timer_Count); //65536-11.0592M/12/1000
  56   2                      TH0 = (uint8_t)((tim_baseHandle->Timer_Count) >> 8);
  57   2                      TR0 = tim_baseHandle->RunTimer_Enable;  //启动定时器
  58   2                      ET0 = tim_baseHandle->Interrupt_Enable; //使能定时器中断
  59   2                      IP |= tim_baseHandle->Timer_NVIC.Register_IP;
  60   2                      IPH |= tim_baseHandle->Timer_NVIC.Register_IPH;
  61   2                      //              EA = 1;
  62   2              }
  63   1      }
  64          
  65          #define CHECK_UART_FRAME(_ID)                                                      \
  66          do                                                                                                         \
  67          {                                                                                              \
  68                  if(COM_UART##_ID.LNode[COM_UART##_ID.Wptr].Timer_Flag) \
  69                  SET_FRAME(COM_UART##_ID);                                  \
  70          } while (0)
  71          
  72          /**
  73           * @brief       定时器0的中断服务函数
  74           * @details     
  75           * @param       None
  76           * @retval      None
  77           */
  78          void Timer0_ISR() interrupt 1 using 0
  79          {
  80   1              /*软件定时器*/
  81   1              // systemTimer();
  82   1              SET_SOFTTIMER_FLAG(PublicTimer16);
  83   1      
  84   1              // if(COM_UART1.LNode[COM_UART1.Wptr].Timer_Flag)
  85   1              //      /*以太网串口接收字符间隔超时处理*/
  86   1              //      SET_FRAME(COM_UART1);
  87   1              // if(COM_UART2.LNode[COM_UART2.Wptr].Timer_Flag)
  88   1              //      /*4G/WiFi串口接收字符间隔超时处理*/
  89   1              //      SET_FRAME(COM_UART2);
  90   1              // if(COM_UART3.LNode[COM_UART3.Wptr].Timer_Flag)
  91   1              //      /*RS485串口接收字符间隔超时处理*/
  92   1              //      SET_FRAME(COM_UART3);
  93   1              // if(COM_UART4.LNode[COM_UART4.Wptr].Timer_Flag)
  94   1              //      /*PLC串口接收字符间隔超时处理*/
  95   1              //      SET_FRAME(COM_UART4);
  96   1      
  97   1              CHECK_UART_FRAME(1); /*以太网串口接收字符间隔超时处理*/
  98   1              CHECK_UART_FRAME(2); /*4G/WiFi串口接收字符间隔超时处理*/
  99   1              CHECK_UART_FRAME(3); /*RS485串口接收字符间隔超时处理*/
 100   1      #if !USING_PORT0_SINGLE
                      CHECK_UART_FRAME(4); /*PLC串口接收字符间隔超时处理*/
              #else
 103   1      //      if (!COM_UART4.Timer_Flag)
 104   1      //              return;
 105   1              if (COM_UART4.OverTime)
 106   1              {
 107   2                      if (!--COM_UART4.OverTime)
 108   2                              COM_UART4.Frame_Flag = true;
 109   2              }
 110   1              // COM_UART4.Timer_Flag = false;
 111   1      
 112   1                                              
 113   1      #endif
 114   1      }
 115          
 116          
C51 COMPILER V9.60.0.0   TIMER                                                             03/03/2023 11:28:23 PAGE 3   

 117          void Delay_ms(unsigned short time)
 118          {
 119   1          unsigned short temp;
 120   1      
 121   1          temp = time;
 122   1      
 123   1          while(temp --)
 124   1          {
 125   2              Delay1ms();
 126   2          }
 127   1      }
 128          
 129          /*禁止编译器优化该模块*/
 130          #pragma OPTIMIZE(0)
 131          
 132          void Delay1ms()         //@27MHz
 133          {
 134   1          unsigned char i, j;
 135   1      
 136   1          i = 11;
 137   1          j = 300;
 138   1      
 139   1          do
 140   1          {
 141   2              while (--j);
 142   2          }
 143   1          while (--i);
 144   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    646    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     18       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
