C51 COMPILER V9.60.0.0   USART                                                             12/18/2021 09:21:04 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\usart.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeModB
                    -us\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "Control.h"
   3          #include "systemTimer.h"
   4          // #include "queue.h"
   5          
   6          /*********************************************************
   7          * å‡½æ•°åï¼š
   8          * åŠŸèƒ½ï¼š
   9          * å‚æ•°ï¼š
  10          * ä½œè€…ï¼š
  11          * noteï¼š
  12                  åŒæ—¶ä½¿ç”¨å¤šä¸ªä¸²å£çš„æ—¶å€™ä¼šå‡ºç°æ•°æ®ä¼ è¾“é”™è¯¯çš„æƒ…å†µ å»ºè®®åœ¨ä½¿ç”¨è¯¥æ¿å­ä¸å
             -…¶ä»–
  13                  é€šè®¯æ¨¡å—å»ºç«‹é€šè®¯çš„æ—¶å€™ä½¿ç”¨1å¯¹1çš„å»ºç«‹è¿æ¥çš„æ¨¡å¼
  14          
  15                  è§£å†³äº†å¤šä¸²å£åŒæ—¶æ•°æ®ä¼ è¾“é”™è¯¯é—®é¢˜ //2021/5/31
  16          
  17                  åœ¨åˆ‡æ¢ä¸²å£çš„å¼•è„šè¾“å…¥æ—¶ï¼Œå»ºè®®å°†RXç«¯åˆå§‹åŒ–çš„æ—¶å€™ç»™ä¸ª0å€¼ TXå¼•è„šæ‰‹åŠ¨ç»™ä¸
             -ª1å€¼
  18                  ï¼ˆåŸºäºSTCå•ç‰‡æœºçš„ç‰¹æ€§ï¼‰
  19          
  20          **********************************************************/
  21          
  22          Uart_HandleTypeDef Uart1; //ä¸²å£1å¥æŸ„
  23          Uart_HandleTypeDef Uart2; //ä¸²å£2å¥æŸ„
  24          Uart_HandleTypeDef Uart3; //ä¸²å£3å¥æŸ„
  25          Uart_HandleTypeDef Uart4; //ä¸²å£4å¥æŸ„
  26          
  27          #define ISR_RECEIVE(current_uart, uart_id, src, dest)                                                     
             -                            \
  28              do                                                                                                    
             -                            \
  29              {                                                                                                     
             -                            \
  30                  current_uart.LNode[current_uart.Wptr].Timer_Flag = true;                                          
             -                            \
  31                  if (!current_uart.LNode[current_uart.Wptr].Frame_Flag)                                            
             -                            \
  32                  {                                                                                                 
             -                            \
  33                      current_uart.LNode[current_uart.Wptr].OverTime = MAX_SILENCE;                                 
             -                            \
  34                      if (current_uart.LNode[current_uart.Wptr].Rx_Length < MAX_SIZE)                               
             -                            \
  35                      {                                                                                             
             -                            \
  36                          current_uart.LNode[current_uart.Wptr].Rx_Buffer[current_uart.LNode[current_uart.Wptr].Rx_L
             -ength++] = S##uart_id##BUF; \
  37                          current_uart.LNode[current_uart.Wptr].Source_Channel = src;                               
             -                            \
  38                          current_uart.LNode[current_uart.Wptr].Target_Channel = dest;                              
             -                            \
  39                      }                                                                                             
             -                            \
C51 COMPILER V9.60.0.0   USART                                                             12/18/2021 09:21:04 PAGE 2   

  40                  }                                                                                                 
             -                            \
  41              } while (0);
  42          
  43          /*å®šä¹‰ä¸€ä¸ªå½“å‰å‘èµ·è¯·æ±‚é€šé“å˜é‡*/
  44          SEL_CHANNEL current_request_channel = CHANNEL_IDLE;
  45          
  46          /*********************************************************
  47           * å‡½æ•°åï¼švoid Uart_1Init(void)
  48           * åŠŸèƒ½ï¼š  ä¸²å£1çš„åˆå§‹åŒ–
  49           * å‚æ•°ï¼š
  50           * ä½œè€…ï¼š  LHC
  51           * noteï¼š
  52           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨
  53           **********************************************************/
  54          void Uart1_Init(void) //ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
  55          {
  56   1          Uart1.Instance = UART1;
  57   1          Uart1.Register_SCON = 0x50; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
  58   1          Uart1.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
  59   1          Uart1.Uart_Count = UART1_BRT;
  60   1          Uart1.RunUart_Enable = true;
  61   1          Uart1.Interrupt_Enable = true;
  62   1          Uart1.Register_AUXR = 0x40;  //å®šæ—¶å™¨1ï¼Œ1Tæ¨¡å¼
  63   1          Uart1.Register_AUXR &= 0xFE; //æ³¢ç‰¹ç‡å‘ç”Ÿå™¨é€‰ç”¨å®šæ—¶å™¨1ï¼Œæœ€å¥½æŒ‰ç…§è¦æ±‚æ¥
  64   1      
  65   1          Uart1.Uart_NVIC.Register_IP = 0xEF; // PS=0,PSH=0,ä¸²å£1ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§ï¼Œæœ€ä½çº§
  66   1          Uart1.Uart_NVIC.Register_IPH = 0xEF;
  67   1      
  68   1          Uart_Base_MspInit(&Uart1);
  69   1      }
  70          
  71          /*********************************************************
  72           * å‡½æ•°åï¼švoid Uart1_ISR() interrupt 4 using 2
  73           * åŠŸèƒ½ï¼š  ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  74           * å‚æ•°ï¼š
  75           * ä½œè€…ï¼š  LHC
  76           * noteï¼š
  77           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨
  78           **********************************************************/
  79          void Uart1_ISR() interrupt 4 // using 2 //ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  80          {
  81   1          /*å‘é€ä¸­æ–­æ ‡å¿—*/
  82   1          if (TI)
  83   1          {
  84   2              TI = 0;
  85   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
  86   2              Uart1.Uartx_busy = false;
  87   2          }
  88   1          /*æ¥æ”¶ä¸­æ–­æ ‡å¿—*/
  89   1          if (RI)
  90   1          {
  91   2              RI = 0;
  92   2      
  93   2              /*å½“æ”¶åˆ°æ•°æ®æ—¶æ‰“å¼€å¸§ä¸­æ–­å®šæ—¶å™¨*/
  94   2              // COM_UART1.LNode[COM_UART1.Wptr].Timer_Flag = true;
  95   2              /*å½“å‰èŠ‚ç‚¹è¿˜æ²¡æœ‰æ”¶åˆ°ä¸€å¸§æ•°æ®*/
  96   2              // if(!COM_UART1.LNode[COM_UART1.Wptr].Frame_Flag)
  97   2              // {
  98   2              //      /*åˆ·æ–°å¸§è¶…æ—¶æ—¶é—´*/
  99   2              //      COM_UART1.LNode[COM_UART1.Wptr].OverTime = MAX_SILENCE;
 100   2              //      if(COM_UART1.LNode[COM_UART1.Wptr].Rx_Length < MAX_SIZE)
C51 COMPILER V9.60.0.0   USART                                                             12/18/2021 09:21:04 PAGE 3   

 101   2              //      {       /*æŠŠæ•°æ®å­˜åˆ°å½“å‰èŠ‚ç‚¹çš„ç¼“å†²åŒº*/
 102   2              //              COM_UART1.LNode[COM_UART1.Wptr].Rx_Buffer[COM_UART1.LNode[COM_UART1.Wptr].Rx_Length++] = SBUF
             -;
 103   2              //      }
 104   2              //      else
 105   2              //      {       /*æ•°æ®ç¼“å†²åŒºæº¢å‡ºå¯¼è‡´çš„å¸§æˆªæ–­*/
 106   2              //                      COM_UART1.LNode[COM_UART1.Wptr].Frame_Flag = true;
 107   2              //      }
 108   2              // }
 109   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 110   2              current_request_channel = CHANNEL_LAN;
 111   2              ISR_RECEIVE(COM_UART1, ,CHANNEL_LAN, CHANNEL_PLC);
 112   2          }
 113   1      }
 114          
 115          /*********************************************************
 116           * å‡½æ•°åï¼švoid Uart_2Init(void)
 117           * åŠŸèƒ½ï¼š  ä¸²å£2çš„åˆå§‹åŒ–
 118           * å‚æ•°ï¼š
 119           * ä½œè€…ï¼š  LHC
 120           * noteï¼š
 121           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 122           **********************************************************/
 123          void Uart2_Init(void) //ä¸²å£2é€‰æ‹©å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 124          {
 125   1          Uart2.Instance = UART2;
 126   1          Uart2.Register_SCON = 0x10; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼Œå¼€å¯ä¸²å£2æ¥æ”¶
 127   1          Uart2.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
 128   1          Uart2.Uart_Count = UART2_BRT;
 129   1          Uart2.RunUart_Enable = true;
 130   1          Uart2.Interrupt_Enable = 0x01;
 131   1          Uart2.Register_AUXR = 0x14;         //å¼€å¯å®šæ—¶å™¨2ï¼Œ1Tæ¨¡å¼
 132   1          Uart2.Uart_NVIC.Register_IP = 0x01; // PS2=1,PS2H=0,ä¸²å£2ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬1çº§
 133   1          Uart2.Uart_NVIC.Register_IPH = 0xFE;
 134   1      
 135   1          Uart_Base_MspInit(&Uart2);
 136   1      }
 137          
 138          /*********************************************************
 139           * å‡½æ•°åï¼švoid Uart2_ISR() interrupt 8 using 2
 140           * åŠŸèƒ½ï¼š  ä¸²å£2ä¸­æ–­å‡½æ•°
 141           * å‚æ•°ï¼š
 142           * ä½œè€…ï¼š  LHC
 143           * noteï¼š
 144           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,4Gå£ç”¨
 145           **********************************************************/
 146          void Uart2_ISR() interrupt 8 // using 2
 147          {                            /*å‘é€ä¸­æ–­*/
 148   1          if (S2CON & S2TI)
 149   1          {
 150   2              S2CON &= ~S2TI;
 151   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 152   2              Uart2.Uartx_busy = false;
 153   2          }
 154   1          /*æ¥æ”¶ä¸­æ–­*/
 155   1          if (S2CON & S2RI)
 156   1          {
 157   2              S2CON &= ~S2RI;
 158   2      
 159   2              /*å½“æ”¶åˆ°æ•°æ®æ—¶æ‰“å¼€å¸§ä¸­æ–­å®šæ—¶å™¨*/
 160   2              // COM_UART2.LNode[COM_UART2.Wptr].Timer_Flag = true;
 161   2              // /*å½“å‰èŠ‚ç‚¹è¿˜æ²¡æœ‰æ”¶åˆ°ä¸€å¸§æ•°æ®*/
C51 COMPILER V9.60.0.0   USART                                                             12/18/2021 09:21:04 PAGE 4   

 162   2              // if (!COM_UART2.LNode[COM_UART2.Wptr].Frame_Flag)
 163   2              // {
 164   2              //     /*åˆ·æ–°å¸§è¶…æ—¶æ—¶é—´*/
 165   2              //     COM_UART2.LNode[COM_UART2.Wptr].OverTime = MAX_SILENCE;
 166   2              //     if (COM_UART2.LNode[COM_UART2.Wptr].Rx_Length < MAX_SIZE)
 167   2              //     { /*æŠŠæ•°æ®å­˜åˆ°å½“å‰èŠ‚ç‚¹çš„ç¼“å†²åŒº*/
 168   2              //         COM_UART2.LNode[COM_UART2.Wptr].Rx_Buffer[COM_UART2.LNode[COM_UART2.Wptr].Rx_Length++] 
             -= S2BUF;
 169   2              //     }
 170   2              // }
 171   2      
 172   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 173   2              current_request_channel = CHANNEL_WIFI;
 174   2              ISR_RECEIVE(COM_UART2, 2, CHANNEL_WIFI, CHANNEL_PLC);
 175   2          }
 176   1      }
 177          
 178          ///*********************************************************
 179          //* å‡½æ•°åï¼švoid Uart_3Init(void)
 180          //* åŠŸèƒ½ï¼š  ä¸²å£3çš„åˆå§‹åŒ–
 181          //* å‚æ•°ï¼š
 182          //* ä½œè€…ï¼š  LHC
 183          //* noteï¼š
 184          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,æ©å¤–éƒ¨485è½¬å‘
 185          //**********************************************************/
 186          void Uart3_Init(void) //ä¸²å£3é€‰æ‹©å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 187          {
 188   1          Uart3.Instance = UART3;
 189   1          Uart3.Register_SCON = 0x50; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 190   1          Uart3.Uart_Mode = 0x0A;     //æ‰“å¼€å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 191   1          Uart3.Uart_Count = UART3_BRT;
 192   1          Uart3.Interrupt_Enable = 0x08;
 193   1      
 194   1          Uart_Base_MspInit(&Uart3);
 195   1      }
 196          
 197          /*********************************************************
 198           * å‡½æ•°åï¼švoid Uart3_ISR() interrupt 17 using 2
 199           * åŠŸèƒ½ï¼š  ä¸²å£3ä¸­æ–­å‡½æ•°
 200           * å‚æ•°ï¼š
 201           * ä½œè€…ï¼š  LHC
 202           * noteï¼š
 203           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,RS485æ¨¡å—
 204           **********************************************************/
 205          void Uart3_ISR() interrupt 17 // using 2
 206          {
 207   1          /*å‘é€ä¸­æ–­å®Œæˆ*/
 208   1          if (S3CON & S3TI)
 209   1          {
 210   2              S3CON &= ~S3TI;
 211   2              Uart3.Uartx_busy = false; //å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 212   2          }
 213   1          /*æ¥æ”¶ä¸­æ–­*/
 214   1          if (S3CON & S3RI)
 215   1          {
 216   2              S3CON &= ~S3RI;
 217   2      
 218   2              /*å½“æ”¶åˆ°æ•°æ®æ—¶æ‰“å¼€å¸§ä¸­æ–­å®šæ—¶å™¨*/
 219   2              // COM_UART3.LNode[COM_UART3.Wptr].Timer_Flag = true;
 220   2              // /*å½“å‰èŠ‚ç‚¹è¿˜æ²¡æœ‰æ”¶åˆ°ä¸€å¸§æ•°æ®*/
 221   2              // if (!COM_UART3.LNode[COM_UART3.Wptr].Frame_Flag)
 222   2              // {
C51 COMPILER V9.60.0.0   USART                                                             12/18/2021 09:21:04 PAGE 5   

 223   2              //     /*åˆ·æ–°å¸§è¶…æ—¶æ—¶é—´*/
 224   2              //     COM_UART3.LNode[COM_UART3.Wptr].OverTime = MAX_SILENCE;
 225   2              //     if (COM_UART3.LNode[COM_UART3.Wptr].Rx_Length < MAX_SIZE)
 226   2              //     { /*æŠŠæ•°æ®å­˜åˆ°å½“å‰èŠ‚ç‚¹çš„ç¼“å†²åŒº*/
 227   2              //         COM_UART3.LNode[COM_UART3.Wptr].Rx_Buffer[COM_UART3.LNode[COM_UART3.Wptr].Rx_Length++] 
             -= S3BUF;
 228   2              //     }
 229   2              // }
 230   2      
 231   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 232   2              current_request_channel = CHANNEL_RS485;
 233   2              ISR_RECEIVE(COM_UART3, 3, CHANNEL_RS485, CHANNEL_PLC);
 234   2          }
 235   1      }
 236          
 237          ///*********************************************************
 238          //* å‡½æ•°åï¼švoid Uart_4Init(void)
 239          //* åŠŸèƒ½ï¼š  ä¸²å£4çš„åˆå§‹åŒ–
 240          //* å‚æ•°ï¼š
 241          //* ä½œè€…ï¼š  LHC
 242          //* noteï¼š
 243          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 244          //**********************************************************/
 245          void Uart4_Init(void) //ä¸²å£4é€‰æ‹©å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 246          {
 247   1          Uart4.Instance = UART4;
 248   1          Uart4.Register_SCON = 0x50; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 249   1          Uart4.Uart_Mode = 0xA0;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½;å¼€å¯å®šæ—¶å™¨4ï¼Œ1Tæ¨¡å¼
 250   1          Uart4.Uart_Count = UART4_BRT;
 251   1          Uart4.Interrupt_Enable = 0x10;
 252   1      
 253   1          Uart_Base_MspInit(&Uart4);
 254   1      }
 255          
 256          /*********************************************************
 257           * å‡½æ•°åï¼švoid Uart4_Isr() interrupt 18 using 1
 258           * åŠŸèƒ½ï¼š  ä¸²å£4ä¸­æ–­å‡½æ•°
 259           * å‚æ•°ï¼š
 260           * ä½œè€…ï¼š  LHC
 261           * noteï¼š
 262           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 263           **********************************************************/
 264          void Uart4_Isr() interrupt 18 // using 1
 265          {                             /*å‘é€ä¸­æ–­*/
 266   1          SEL_CHANNEL temp_channel = CHANNEL_RS485;
 267   1      
 268   1          if (S4CON & S4TI)
 269   1          {
 270   2              S4CON &= ~S4TI;
 271   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 272   2              Uart4.Uartx_busy = false;
 273   2          }
 274   1          /*æ¥æ”¶ä¸­æ–­*/
 275   1          if (S4CON & S4RI)
 276   1          {
 277   2              S4CON &= ~S4RI;
 278   2      
 279   2              /*å½“æ”¶åˆ°æ•°æ®æ—¶æ‰“å¼€å¸§ä¸­æ–­å®šæ—¶å™¨*/
 280   2              // COM_UART4.LNode[COM_UART4.Wptr].Timer_Flag = true;
 281   2              // /*å½“å‰èŠ‚ç‚¹è¿˜æ²¡æœ‰æ”¶åˆ°ä¸€å¸§æ•°æ®*/
 282   2              // if (!COM_UART4.LNode[COM_UART4.Wptr].Frame_Flag)
 283   2              // {
C51 COMPILER V9.60.0.0   USART                                                             12/18/2021 09:21:04 PAGE 6   

 284   2              //     /*åˆ·æ–°å¸§è¶…æ—¶æ—¶é—´*/
 285   2              //     COM_UART4.LNode[COM_UART4.Wptr].OverTime = MAX_SILENCE;
 286   2              //     if (COM_UART4.LNode[COM_UART4.Wptr].Rx_Length < MAX_SIZE)
 287   2              //     { /*æŠŠæ•°æ®å­˜åˆ°å½“å‰èŠ‚ç‚¹çš„ç¼“å†²åŒº*/
 288   2              //         COM_UART4.LNode[COM_UART4.Wptr].Rx_Buffer[COM_UART4.LNode[COM_UART4.Wptr].Rx_Length++] 
             -= S4BUF;
 289   2              //     }
 290   2              // }
 291   2      
 292   2              /*åˆ¤æ–­å½“å‰PLCæ˜¯ä¸»åŠ¨å‘é€è¿˜æ˜¯è¢«åŠ¨è¯·æ±‚*/
 293   2              if (current_request_channel != CHANNEL_IDLE)
 294   2              {
 295   3                  temp_channel = CHANNEL_RS485;
 296   3              }
 297   2              else
 298   2              {
 299   3                  temp_channel = current_request_channel;
 300   3              }
 301   2              ISR_RECEIVE(COM_UART4, 4, CHANNEL_PLC, temp_channel);
 302   2          }
 303   1      }
 304          
 305          /**********************************å…¬ç”¨å‡½æ•°************************/
 306          
 307          /*********************************************************
 308           * å‡½æ•°åï¼šUart_Base_MspInit(Uart_HandleTypeDef *uart_baseHandle)
 309           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£åº•å±‚åˆå§‹åŒ–å‡½æ•°
 310           * å‚æ•°ï¼š  Uart_HandleTypeDef *uart_baseHandleä¸²å£å¥æŸ„
 311           * ä½œè€…ï¼š  LHC
 312           * noteï¼š
 313           *              æ³¨æ„æ­£ç¡®ç»™å‡ºä¸²å£å¥æŸ„
 314           **********************************************************/
 315          void Uart_Base_MspInit(Uart_HandleTypeDef *const uart_baseHandle)
 316          {
 317   1          if (uart_baseHandle->Instance == UART1)
 318   1          {
 319   2              SCON = uart_baseHandle->Register_SCON;
 320   2              TMOD |= uart_baseHandle->Uart_Mode;
 321   2              TL1 = uart_baseHandle->Uart_Count;
 322   2              TH1 = uart_baseHandle->Uart_Count >> 8;
 323   2              TR1 = uart_baseHandle->RunUart_Enable;
 324   2              AUXR |= uart_baseHandle->Register_AUXR;
 325   2              IP &= uart_baseHandle->Uart_NVIC.Register_IP;
 326   2              IPH &= uart_baseHandle->Uart_NVIC.Register_IPH;
 327   2      #if USEING_PRINTF //å¦‚æœä½¿ç”¨printf
                      TI = 1;   //æ”¾åˆ°printfé‡å®šå‘
              #else
 330   2              ES = uart_baseHandle->Interrupt_Enable; //ä¸²å£1ä¸­æ–­å…è®¸ä½
 331   2      #endif
 332   2          }
 333   1          else if (uart_baseHandle->Instance == UART2)
 334   1          {
 335   2              S2CON = uart_baseHandle->Register_SCON;
 336   2              TL2 = uart_baseHandle->Uart_Count;
 337   2              TH2 = uart_baseHandle->Uart_Count >> 8;
 338   2              AUXR |= uart_baseHandle->Register_AUXR;
 339   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£2ä¸­æ–­å…è®¸ä½
 340   2              IP2 &= uart_baseHandle->Uart_NVIC.Register_IP;
 341   2              IP2H &= uart_baseHandle->Uart_NVIC.Register_IPH;
 342   2          }
 343   1          else if (uart_baseHandle->Instance == UART3)
 344   1          {
C51 COMPILER V9.60.0.0   USART                                                             12/18/2021 09:21:04 PAGE 7   

 345   2              S3CON = uart_baseHandle->Register_SCON;
 346   2              T4T3M = uart_baseHandle->Uart_Mode;
 347   2              T3L = uart_baseHandle->Uart_Count;
 348   2              T3H = uart_baseHandle->Uart_Count >> 8;
 349   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£3ä¸­æ–­å…è®¸ä½
 350   2          }
 351   1          else if (uart_baseHandle->Instance == UART4)
 352   1          {
 353   2              S4CON = uart_baseHandle->Register_SCON;
 354   2              T4T3M |= uart_baseHandle->Uart_Mode; //æ­¤å¤„ä¸²å£3å’Œä¸²å£4å…±ç”¨
 355   2              T4L = uart_baseHandle->Uart_Count;
 356   2              T4H = uart_baseHandle->Uart_Count >> 8;
 357   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£4ä¸­æ–­å…è®¸ä½
 358   2          }
 359   1      }
 360          
 361          /*********************************************************
 362           * å‡½æ•°åï¼šstatic void Busy_Await(Uart_HandleTypeDef * const Uart, uint16_t overtime)
 363           * åŠŸèƒ½ï¼š  å­—èŠ‚å‘é€è¶…æ—¶ç­‰å¾…æœºåˆ¶
 364           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart;uint16_t overtime
 365           * ä½œè€…ï¼š  LHC
 366           * noteï¼š
 367           *
 368           **********************************************************/
 369          void Busy_Await(Uart_HandleTypeDef *const Uart, uint16_t overtime)
 370          {
 371   1      
 372   1          while (Uart->Uartx_busy) //ç­‰å¾…å‘é€å®Œæˆï¼šUart->Uartx_busyæ¸…é›¶
 373   1          {
 374   2              if (!(overtime--))
 375   2                  break;
 376   2          }
 377   1      
 378   1          Uart->Uartx_busy = true; //å‘é€æ•°æ®ï¼ŒæŠŠç›¸åº”ä¸²å£ç½®å¿™
 379   1      }
 380          
 381          /*********************************************************
 382           * å‡½æ•°åï¼šUartx_SendStr(Uart_HandleTypeDef *const Uart,uint8_t *p,uint8_t length)
 383           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£å­—ç¬¦ä¸²å‘é€å‡½æ•°
 384           * å‚æ•°ï¼š  Uart_HandleTypeDef *const Uart,uint8_t *p;uint8_t length
 385           * ä½œè€…ï¼š  LHC
 386           * noteï¼š
 387           *
 388           **********************************************************/
 389          void Uartx_SendStr(Uart_HandleTypeDef *const Uart, uint8_t *p, uint8_t length)
 390          {
 391   1      
 392   1          while (length--)
 393   1          {
 394   2              Busy_Await(&(*Uart), UART_BYTE_SENDOVERTIME); //ç­‰å¾…å½“å‰å­—èŠ‚å‘é€å®Œæˆ
 395   2              switch (Uart->Instance)
 396   2              {
 397   3              case UART1:
 398   3                  SBUF = *p++;
 399   3                  break;
 400   3              case UART2:
 401   3                  S2BUF = *p++;
 402   3                  break;
 403   3              case UART3:
 404   3                  S3BUF = *p++;
 405   3                  break;
 406   3              case UART4:
C51 COMPILER V9.60.0.0   USART                                                             12/18/2021 09:21:04 PAGE 8   

 407   3                  S4BUF = *p++;
 408   3                  break;
 409   3              default:
 410   3                  break;
 411   3              }
 412   2          }
 413   1      }
 414          
 415          /*********************************************************
 416           * å‡½æ•°åï¼šchar putchar(char str)
 417           * åŠŸèƒ½ï¼š  putcharé‡å®šå‘,è¢«printfè°ƒç”¨
 418           * å‚æ•°ï¼š  char strï¼Œå‘é€çš„å­—ç¬¦ä¸²
 419           * ä½œè€…ï¼š  LHC
 420           * noteï¼š
 421           *                ä½¿ç”¨printfå‡½æ•°å°†ä¼šå ç”¨1K å·¦å³FLASH
 422           **********************************************************/
 423          #ifdef USEING_PRINTF
 424          // char putchar(char str)
 425          // {
 426          //     ES = 0; //å…³é—­ä¸²å£1ä¸­æ–­
 427          //     SBUF = str;
 428          
 429          //     while (!TI)
 430          //         ;
 431          
 432          //     TI = 0;
 433          //     ES = 1;
 434          //     return str;
 435          // }
 436          #endif
 437          
 438          /**********************************å…¬ç”¨å‡½æ•°************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1310    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     45       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
