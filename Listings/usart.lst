C51 COMPILER V9.60.0.0   USART                                                             12/21/2021 17:57:20 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\usart.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeModB
                    -us\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "Control.h"
   3          #include "systemTimer.h"
   4          // #include "queue.h"
   5          
   6          /*********************************************************
   7          * å‡½æ•°åï¼š
   8          * åŠŸèƒ½ï¼š
   9          * å‚æ•°ï¼š
  10          * ä½œè€…ï¼š
  11          * noteï¼š
  12                  åŒæ—¶ä½¿ç”¨å¤šä¸ªä¸²å£çš„æ—¶å€™ä¼šå‡ºç°æ•°æ®ä¼ è¾“é”™è¯¯çš„æƒ…å†µ å»ºè®®åœ¨ä½¿ç”¨è¯¥æ¿å­ä¸å
             -…¶ä»–
  13                  é€šè®¯æ¨¡å—å»ºç«‹é€šè®¯çš„æ—¶å€™ä½¿ç”¨1å¯¹1çš„å»ºç«‹è¿æ¥çš„æ¨¡å¼
  14          
  15                  è§£å†³äº†å¤šä¸²å£åŒæ—¶æ•°æ®ä¼ è¾“é”™è¯¯é—®é¢˜ //2021/5/31
  16          
  17                  åœ¨åˆ‡æ¢ä¸²å£çš„å¼•è„šè¾“å…¥æ—¶ï¼Œå»ºè®®å°†RXç«¯åˆå§‹åŒ–çš„æ—¶å€™ç»™ä¸ª0å€¼ TXå¼•è„šæ‰‹åŠ¨ç»™ä¸
             -ª1å€¼
  18                  ï¼ˆåŸºäºSTCå•ç‰‡æœºçš„ç‰¹æ€§ï¼‰
  19          
  20          **********************************************************/
  21          
  22          Uart_HandleTypeDef Uart1; //ä¸²å£1å¥æŸ„
  23          Uart_HandleTypeDef Uart2; //ä¸²å£2å¥æŸ„
  24          Uart_HandleTypeDef Uart3; //ä¸²å£3å¥æŸ„
  25          Uart_HandleTypeDef Uart4; //ä¸²å£4å¥æŸ„
  26          
  27          #define ISR_RECEIVE(current_uart, uart_id, src, dest)                                                     
             -                            \
  28              do                                                                                                    
             -                            \
  29              {                                                                                                     
             -                            \
  30                  current_uart.LNode[current_uart.Wptr].Timer_Flag = true;                                          
             -                            \
  31                  if (!current_uart.LNode[current_uart.Wptr].Frame_Flag)                                            
             -                            \
  32                  {                                                                                                 
             -                            \
  33                      current_uart.LNode[current_uart.Wptr].OverTime = MAX_SILENCE;                                 
             -                            \
  34                      if (current_uart.LNode[current_uart.Wptr].Rx_Length < MAX_SIZE)                               
             -                            \
  35                      {                                                                                             
             -                            \
  36                          current_uart.LNode[current_uart.Wptr].Rx_Buffer[current_uart.LNode[current_uart.Wptr].Rx_L
             -ength++] = S##uart_id##BUF; \
  37                          current_uart.LNode[current_uart.Wptr].Source_Channel = src;                               
             -                            \
  38                          current_uart.LNode[current_uart.Wptr].Target_Channel = dest;                              
             -                            \
  39                      }                                                                                             
             -                            \
C51 COMPILER V9.60.0.0   USART                                                             12/21/2021 17:57:20 PAGE 2   

  40                  }                                                                                                 
             -                            \
  41              } while (0);
  42          
  43          /*å®šä¹‰ä¸€ä¸ªå½“å‰å‘èµ·è¯·æ±‚é€šé“å˜é‡*/
  44          volatile  SEL_CHANNEL current_request_channel = CHANNEL_IDLE;
  45          
  46          /*********************************************************
  47           * å‡½æ•°åï¼švoid Uart_1Init(void)
  48           * åŠŸèƒ½ï¼š  ä¸²å£1çš„åˆå§‹åŒ–
  49           * å‚æ•°ï¼š
  50           * ä½œè€…ï¼š  LHC
  51           * noteï¼š
  52           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨
  53           **********************************************************/
  54          void Uart1_Init(void) //ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
  55          {
  56   1          Uart1.Instance = UART1;
  57   1          Uart1.Register_SCON = 0x50; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
  58   1          Uart1.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
  59   1          Uart1.Uart_Count = UART1_BRT;
  60   1          Uart1.RunUart_Enable = true;
  61   1          Uart1.Interrupt_Enable = true;
  62   1          Uart1.Register_AUXR = 0x40;  //å®šæ—¶å™¨1ï¼Œ1Tæ¨¡å¼
  63   1          Uart1.Register_AUXR &= 0xFE; //æ³¢ç‰¹ç‡å‘ç”Ÿå™¨é€‰ç”¨å®šæ—¶å™¨1ï¼Œæœ€å¥½æŒ‰ç…§è¦æ±‚æ¥
  64   1      
  65   1          Uart1.Uart_NVIC.Register_IP = 0xEF; // PS=0,PSH=0,ä¸²å£1ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§ï¼Œæœ€ä½çº§
  66   1          Uart1.Uart_NVIC.Register_IPH = 0xEF;
  67   1      
  68   1          Uart_Base_MspInit(&Uart1);
  69   1      }
  70          
  71          /*********************************************************
  72           * å‡½æ•°åï¼švoid Uart1_ISR() interrupt 4 using 2
  73           * åŠŸèƒ½ï¼š  ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  74           * å‚æ•°ï¼š
  75           * ä½œè€…ï¼š  LHC
  76           * noteï¼š
  77           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨
  78           **********************************************************/
  79          void Uart1_ISR() interrupt 4 using 2 //ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  80          {
  81   1          /*å‘é€ä¸­æ–­æ ‡å¿—*/
  82   1          if (TI)
  83   1          {
  84   2              TI = 0;
  85   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
  86   2              Uart1.Uartx_busy = false;
  87   2          }
  88   1          /*æ¥æ”¶ä¸­æ–­æ ‡å¿—*/
  89   1          if (RI)
  90   1          {
  91   2              RI = 0;
  92   2      
  93   2              COM_UART1.LNode[COM_UART1.Wptr].Timer_Flag = true;
  94   2              if (!COM_UART1.LNode[COM_UART1.Wptr].Frame_Flag)
  95   2              {
  96   3                  COM_UART1.LNode[COM_UART1.Wptr].OverTime = MAX_SILENCE;
  97   3                  if (COM_UART1.LNode[COM_UART1.Wptr].Rx_Length < MAX_SIZE)
  98   3                  {
  99   4                      COM_UART1.LNode[COM_UART1.Wptr].Rx_Buffer[COM_UART1.LNode[COM_UART1.Wptr].Rx_Length++] = S
             -BUF;
C51 COMPILER V9.60.0.0   USART                                                             12/21/2021 17:57:20 PAGE 3   

 100   4                      COM_UART1.LNode[COM_UART1.Wptr].Source_Channel = CHANNEL_LAN;
 101   4                      COM_UART1.LNode[COM_UART1.Wptr].Target_Channel = CHANNEL_PLC;
 102   4                  }
 103   3              }
 104   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 105   2              current_request_channel = CHANNEL_LAN;
 106   2              // ISR_RECEIVE(COM_UART1, ,CHANNEL_LAN, CHANNEL_PLC);
 107   2          }
 108   1      }
 109          
 110          /*********************************************************
 111           * å‡½æ•°åï¼švoid Uart_2Init(void)
 112           * åŠŸèƒ½ï¼š  ä¸²å£2çš„åˆå§‹åŒ–
 113           * å‚æ•°ï¼š
 114           * ä½œè€…ï¼š  LHC
 115           * noteï¼š
 116           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 117           **********************************************************/
 118          void Uart2_Init(void) //ä¸²å£2é€‰æ‹©å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 119          {
 120   1          Uart2.Instance = UART2;
 121   1          Uart2.Register_SCON = 0x10; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼Œå¼€å¯ä¸²å£2æ¥æ”¶
 122   1          Uart2.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
 123   1          Uart2.Uart_Count = UART2_BRT;
 124   1          Uart2.RunUart_Enable = true;
 125   1          Uart2.Interrupt_Enable = 0x01;
 126   1          Uart2.Register_AUXR = 0x14;         //å¼€å¯å®šæ—¶å™¨2ï¼Œ1Tæ¨¡å¼
 127   1          Uart2.Uart_NVIC.Register_IP = 0xFE; // PS2=0,PS2H=0,ä¸²å£2ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§
 128   1          Uart2.Uart_NVIC.Register_IPH = 0xFE;
 129   1      
 130   1          Uart_Base_MspInit(&Uart2);
 131   1      }
 132          
 133          /*********************************************************
 134           * å‡½æ•°åï¼švoid Uart2_ISR() interrupt 8 using 2
 135           * åŠŸèƒ½ï¼š  ä¸²å£2ä¸­æ–­å‡½æ•°
 136           * å‚æ•°ï¼š
 137           * ä½œè€…ï¼š  LHC
 138           * noteï¼š
 139           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,4Gå£ç”¨
 140           **********************************************************/
 141          void Uart2_ISR() interrupt 8 using 2
 142          {   /*å‘é€ä¸­æ–­*/
 143   1          if (S2CON & S2TI)
 144   1          {
 145   2              S2CON &= ~S2TI;
 146   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 147   2              Uart2.Uartx_busy = false;
 148   2          }
 149   1          /*æ¥æ”¶ä¸­æ–­*/
 150   1          if (S2CON & S2RI)
 151   1          {
 152   2              S2CON &= ~S2RI;
 153   2      
 154   2              COM_UART2.LNode[COM_UART2.Wptr].Timer_Flag = true;
 155   2              if (!COM_UART2.LNode[COM_UART2.Wptr].Frame_Flag)
 156   2              {
 157   3                  COM_UART2.LNode[COM_UART2.Wptr].OverTime = MAX_SILENCE;
 158   3                  if (COM_UART2.LNode[COM_UART2.Wptr].Rx_Length < MAX_SIZE)
 159   3                  {
 160   4                      COM_UART2.LNode[COM_UART2.Wptr].Rx_Buffer[COM_UART2.LNode[COM_UART2.Wptr].Rx_Length++] = S
             -2BUF;
C51 COMPILER V9.60.0.0   USART                                                             12/21/2021 17:57:20 PAGE 4   

 161   4                      COM_UART2.LNode[COM_UART2.Wptr].Source_Channel = CHANNEL_WIFI;
 162   4                      COM_UART2.LNode[COM_UART2.Wptr].Target_Channel = CHANNEL_PLC;
 163   4                  }
 164   3              }
 165   2      
 166   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 167   2              current_request_channel = CHANNEL_WIFI;
 168   2              // ISR_RECEIVE(COM_UART2, 2, CHANNEL_WIFI, CHANNEL_PLC);
 169   2          }
 170   1      }
 171          
 172          ///*********************************************************
 173          //* å‡½æ•°åï¼švoid Uart_3Init(void)
 174          //* åŠŸèƒ½ï¼š  ä¸²å£3çš„åˆå§‹åŒ–
 175          //* å‚æ•°ï¼š
 176          //* ä½œè€…ï¼š  LHC
 177          //* noteï¼š
 178          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,æ©å¤–éƒ¨485è½¬å‘
 179          //**********************************************************/
 180          void Uart3_Init(void) //ä¸²å£3é€‰æ‹©å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 181          {
 182   1          Uart3.Instance = UART3;
 183   1          Uart3.Register_SCON = 0x50; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 184   1          Uart3.Uart_Mode = 0x0A;     //æ‰“å¼€å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 185   1          Uart3.Uart_Count = UART3_BRT;
 186   1          Uart3.Interrupt_Enable = 0x08;
 187   1      
 188   1          Uart_Base_MspInit(&Uart3);
 189   1      }
 190          
 191          /*********************************************************
 192           * å‡½æ•°åï¼švoid Uart3_ISR() interrupt 17 using 2
 193           * åŠŸèƒ½ï¼š  ä¸²å£3ä¸­æ–­å‡½æ•°
 194           * å‚æ•°ï¼š
 195           * ä½œè€…ï¼š  LHC
 196           * noteï¼š
 197           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,RS485æ¨¡å—
 198           **********************************************************/
 199          void Uart3_ISR() interrupt 17 using 2
 200          {
 201   1          /*å‘é€ä¸­æ–­å®Œæˆ*/
 202   1          if (S3CON & S3TI)
 203   1          {
 204   2              S3CON &= ~S3TI;
 205   2              Uart3.Uartx_busy = false; //å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 206   2          }
 207   1          /*æ¥æ”¶ä¸­æ–­*/
 208   1          if (S3CON & S3RI)
 209   1          {
 210   2              S3CON &= ~S3RI;
 211   2      
 212   2              COM_UART3.LNode[COM_UART3.Wptr].Timer_Flag = true;
 213   2              if (!COM_UART3.LNode[COM_UART3.Wptr].Frame_Flag)
 214   2              {
 215   3                  COM_UART3.LNode[COM_UART3.Wptr].OverTime = MAX_SILENCE;
 216   3                  if (COM_UART3.LNode[COM_UART3.Wptr].Rx_Length < MAX_SIZE)
 217   3                  {
 218   4                      COM_UART3.LNode[COM_UART3.Wptr].Rx_Buffer[COM_UART3.LNode[COM_UART3.Wptr].Rx_Length++] = S
             -3BUF;
 219   4                      COM_UART3.LNode[COM_UART3.Wptr].Source_Channel = CHANNEL_RS485;
 220   4                      COM_UART3.LNode[COM_UART3.Wptr].Target_Channel = CHANNEL_PLC;
 221   4                  }
C51 COMPILER V9.60.0.0   USART                                                             12/21/2021 17:57:20 PAGE 5   

 222   3              }
 223   2      
 224   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 225   2              current_request_channel = CHANNEL_RS485;
 226   2              // ISR_RECEIVE(COM_UART3, 3, CHANNEL_RS485, CHANNEL_PLC);
 227   2          }
 228   1      }
 229          
 230          ///*********************************************************
 231          //* å‡½æ•°åï¼švoid Uart_4Init(void)
 232          //* åŠŸèƒ½ï¼š  ä¸²å£4çš„åˆå§‹åŒ–
 233          //* å‚æ•°ï¼š
 234          //* ä½œè€…ï¼š  LHC
 235          //* noteï¼š
 236          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 237          //**********************************************************/
 238          void Uart4_Init(void) //ä¸²å£4é€‰æ‹©å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 239          {
 240   1          Uart4.Instance = UART4;
 241   1          Uart4.Register_SCON = 0x50; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 242   1          Uart4.Uart_Mode = 0xA0;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½;å¼€å¯å®šæ—¶å™¨4ï¼Œ1Tæ¨¡å¼
 243   1          Uart4.Uart_Count = UART4_BRT;
 244   1          Uart4.Interrupt_Enable = 0x10;
 245   1      
 246   1          Uart_Base_MspInit(&Uart4);
 247   1      }
 248          
 249          /*********************************************************
 250           * å‡½æ•°åï¼švoid Uart4_Isr() interrupt 18 using 1
 251           * åŠŸèƒ½ï¼š  ä¸²å£4ä¸­æ–­å‡½æ•°
 252           * å‚æ•°ï¼š
 253           * ä½œè€…ï¼š  LHC
 254           * noteï¼š
 255           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 256           **********************************************************/
 257          void Uart4_Isr() interrupt 18 using 2
 258          {                             /*å‘é€ä¸­æ–­*/
 259   1          // SEL_CHANNEL temp_channel = CHANNEL_RS485;
 260   1      
 261   1          if (S4CON & S4TI)
 262   1          {
 263   2              S4CON &= ~S4TI;
 264   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 265   2              Uart4.Uartx_busy = false;
 266   2          }
 267   1          /*æ¥æ”¶ä¸­æ–­*/
 268   1          if (S4CON & S4RI)
 269   1          {
 270   2              S4CON &= ~S4RI;
 271   2      
 272   2              COM_UART4.LNode[COM_UART4.Wptr].Timer_Flag = true;
 273   2              if (!COM_UART4.LNode[COM_UART4.Wptr].Frame_Flag)
 274   2              {
 275   3                  COM_UART4.LNode[COM_UART4.Wptr].OverTime = MAX_SILENCE;
 276   3                  if (COM_UART4.LNode[COM_UART4.Wptr].Rx_Length < MAX_SIZE)
 277   3                  {
 278   4                      COM_UART4.LNode[COM_UART4.Wptr].Rx_Buffer[COM_UART4.LNode[COM_UART4.Wptr].Rx_Length++] = S
             -4BUF;
 279   4                      COM_UART4.LNode[COM_UART4.Wptr].Source_Channel = CHANNEL_PLC;
 280   4                      COM_UART4.LNode[COM_UART4.Wptr].Target_Channel = current_request_channel;
 281   4                  }
 282   3              }
C51 COMPILER V9.60.0.0   USART                                                             12/21/2021 17:57:20 PAGE 6   

 283   2      
 284   2              /*åˆ¤æ–­å½“å‰PLCæ˜¯ä¸»åŠ¨å‘é€è¿˜æ˜¯è¢«åŠ¨è¯·æ±‚*/
 285   2              // if (current_request_channel != CHANNEL_IDLE)
 286   2              // {
 287   2              //     temp_channel = CHANNEL_RS485;
 288   2              // }
 289   2              // else
 290   2              // {
 291   2              //     temp_channel = current_request_channel;
 292   2              // }
 293   2              // ISR_RECEIVE(COM_UART4, 4, CHANNEL_PLC, CHANNEL_RS485);
 294   2          }
 295   1      }
 296          
 297          /**********************************å…¬ç”¨å‡½æ•°************************/
 298          
 299          /*********************************************************
 300           * å‡½æ•°åï¼šUart_Base_MspInit(Uart_HandleTypeDef *uart_baseHandle)
 301           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£åº•å±‚åˆå§‹åŒ–å‡½æ•°
 302           * å‚æ•°ï¼š  Uart_HandleTypeDef *uart_baseHandleä¸²å£å¥æŸ„
 303           * ä½œè€…ï¼š  LHC
 304           * noteï¼š
 305           *              æ³¨æ„æ­£ç¡®ç»™å‡ºä¸²å£å¥æŸ„
 306           **********************************************************/
 307          void Uart_Base_MspInit(Uart_HandleTypeDef *const uart_baseHandle)
 308          {
 309   1          if (uart_baseHandle->Instance == UART1)
 310   1          {
 311   2              SCON = uart_baseHandle->Register_SCON;
 312   2              TMOD |= uart_baseHandle->Uart_Mode;
 313   2              TL1 = uart_baseHandle->Uart_Count;
 314   2              TH1 = uart_baseHandle->Uart_Count >> 8;
 315   2              TR1 = uart_baseHandle->RunUart_Enable;
 316   2              AUXR |= uart_baseHandle->Register_AUXR;
 317   2              IP &= uart_baseHandle->Uart_NVIC.Register_IP;
 318   2              IPH &= uart_baseHandle->Uart_NVIC.Register_IPH;
 319   2      #if USEING_PRINTF //å¦‚æœä½¿ç”¨printf
                      TI = 1;   //æ”¾åˆ°printfé‡å®šå‘
              #else
 322   2              ES = uart_baseHandle->Interrupt_Enable; //ä¸²å£1ä¸­æ–­å…è®¸ä½
 323   2      #endif
 324   2          }
 325   1          else if (uart_baseHandle->Instance == UART2)
 326   1          {
 327   2              S2CON = uart_baseHandle->Register_SCON;
 328   2              TL2 = uart_baseHandle->Uart_Count;
 329   2              TH2 = uart_baseHandle->Uart_Count >> 8;
 330   2              AUXR |= uart_baseHandle->Register_AUXR;
 331   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£2ä¸­æ–­å…è®¸ä½
 332   2              IP2 &= uart_baseHandle->Uart_NVIC.Register_IP;
 333   2              IP2H &= uart_baseHandle->Uart_NVIC.Register_IPH;
 334   2          }
 335   1          else if (uart_baseHandle->Instance == UART3)
 336   1          {
 337   2              S3CON = uart_baseHandle->Register_SCON;
 338   2              T4T3M = uart_baseHandle->Uart_Mode;
 339   2              T3L = uart_baseHandle->Uart_Count;
 340   2              T3H = uart_baseHandle->Uart_Count >> 8;
 341   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£3ä¸­æ–­å…è®¸ä½
 342   2          }
 343   1          else if (uart_baseHandle->Instance == UART4)
 344   1          {
C51 COMPILER V9.60.0.0   USART                                                             12/21/2021 17:57:20 PAGE 7   

 345   2              S4CON = uart_baseHandle->Register_SCON;
 346   2              T4T3M |= uart_baseHandle->Uart_Mode; //æ­¤å¤„ä¸²å£3å’Œä¸²å£4å…±ç”¨
 347   2              T4L = uart_baseHandle->Uart_Count;
 348   2              T4H = uart_baseHandle->Uart_Count >> 8;
 349   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£4ä¸­æ–­å…è®¸ä½
 350   2          }
 351   1      }
 352          
 353          /*********************************************************
 354           * å‡½æ•°åï¼šstatic void Busy_Await(Uart_HandleTypeDef * const Uart, uint16_t overtime)
 355           * åŠŸèƒ½ï¼š  å­—èŠ‚å‘é€è¶…æ—¶ç­‰å¾…æœºåˆ¶
 356           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart;uint16_t overtime
 357           * ä½œè€…ï¼š  LHC
 358           * noteï¼š
 359           *
 360           **********************************************************/
 361          void Busy_Await(Uart_HandleTypeDef *const Uart, uint16_t overtime)
 362          {
 363   1      
 364   1          while (Uart->Uartx_busy) //ç­‰å¾…å‘é€å®Œæˆï¼šUart->Uartx_busyæ¸…é›¶
 365   1          {
 366   2              if (!(overtime--))
 367   2                  break;
 368   2          }
 369   1      
 370   1          Uart->Uartx_busy = true; //å‘é€æ•°æ®ï¼ŒæŠŠç›¸åº”ä¸²å£ç½®å¿™
 371   1      }
 372          
 373          /*********************************************************
 374           * å‡½æ•°åï¼šUartx_SendStr(Uart_HandleTypeDef *const Uart,uint8_t *p,uint8_t length)
 375           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£å­—ç¬¦ä¸²å‘é€å‡½æ•°
 376           * å‚æ•°ï¼š  Uart_HandleTypeDef *const Uart,uint8_t *p;uint8_t length
 377           * ä½œè€…ï¼š  LHC
 378           * noteï¼š
 379           *
 380           **********************************************************/
 381          void Uartx_SendStr(Uart_HandleTypeDef *const Uart, uint8_t *p, uint8_t length)
 382          {
 383   1      
 384   1          while (length--)
 385   1          {
 386   2              Busy_Await(&(*Uart), UART_BYTE_SENDOVERTIME); //ç­‰å¾…å½“å‰å­—èŠ‚å‘é€å®Œæˆ
 387   2              switch (Uart->Instance)
 388   2              {
 389   3              case UART1:
 390   3                  SBUF = *p++;
 391   3                  break;
 392   3              case UART2:
 393   3                  S2BUF = *p++;
 394   3                  break;
 395   3              case UART3:
 396   3                  S3BUF = *p++;
 397   3                  break;
 398   3              case UART4:
 399   3                  S4BUF = *p++;
 400   3                  break;
 401   3              default:
 402   3                  break;
 403   3              }
 404   2          }
 405   1      }
 406          
C51 COMPILER V9.60.0.0   USART                                                             12/21/2021 17:57:20 PAGE 8   

 407          /*********************************************************
 408           * å‡½æ•°åï¼šchar putchar(char str)
 409           * åŠŸèƒ½ï¼š  putcharé‡å®šå‘,è¢«printfè°ƒç”¨
 410           * å‚æ•°ï¼š  char strï¼Œå‘é€çš„å­—ç¬¦ä¸²
 411           * ä½œè€…ï¼š  LHC
 412           * noteï¼š
 413           *                ä½¿ç”¨printfå‡½æ•°å°†ä¼šå ç”¨1K å·¦å³FLASH
 414           **********************************************************/
 415          #ifdef USEING_PRINTF
 416          char putchar(char str)
 417          {
 418   1          ES = 0; //å…³é—­ä¸²å£1ä¸­æ–­
 419   1          SBUF = str;
 420   1      
 421   1          while (!TI)
 422   1              ;
 423   1      
 424   1          TI = 0;
 425   1          ES = 1;
 426   1          return str;
 427   1      }
 428          #endif
 429          
 430          /**********************************å…¬ç”¨å‡½æ•°************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1216    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     45       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
