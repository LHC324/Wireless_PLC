C51 COMPILER V9.60.0.0   USART                                                             03/03/2023 11:28:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\usart.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeModB
                    -us\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "Control.h"
   3          #include "systemTimer.h"
   4          
   5          /*********************************************************
   6          * å‡½æ•°åï¼š
   7          * åŠŸèƒ½ï¼š
   8          * å‚æ•°ï¼š
   9          * ä½œè€…ï¼š
  10          * noteï¼š
  11                  åŒæ—¶ä½¿ç”¨å¤šä¸ªä¸²å£çš„æ—¶å€™ä¼šå‡ºç°æ•°æ®ä¼ è¾“é”™è¯¯çš„æƒ…å†µ å»ºè®®åœ¨ä½¿ç”¨è¯¥æ¿å­ä¸å
             -…¶ä»–
  12                  é€šè®¯æ¨¡å—å»ºç«‹é€šè®¯çš„æ—¶å€™ä½¿ç”¨1å¯¹1çš„å»ºç«‹è¿æ¥çš„æ¨¡å¼
  13          
  14                  è§£å†³äº†å¤šä¸²å£åŒæ—¶æ•°æ®ä¼ è¾“é”™è¯¯é—®é¢˜ //2021/5/31
  15          
  16                  åœ¨åˆ‡æ¢ä¸²å£çš„å¼•è„šè¾“å…¥æ—¶ï¼Œå»ºè®®å°†RXç«¯åˆå§‹åŒ–çš„æ—¶å€™ç»™ä¸ª0å€¼ TXå¼•è„šæ‰‹åŠ¨ç»™ä¸
             -ª1å€¼
  17                  ï¼ˆåŸºäºSTCå•ç‰‡æœºçš„ç‰¹æ€§ï¼‰
  18          
  19          **********************************************************/
  20          
  21          Uart_HandleTypeDef Uart1; //ä¸²å£1å¥æŸ„
  22          Uart_HandleTypeDef Uart2; //ä¸²å£2å¥æŸ„
  23          Uart_HandleTypeDef Uart3; //ä¸²å£3å¥æŸ„
  24          Uart_HandleTypeDef Uart4; //ä¸²å£4å¥æŸ„
  25          
  26          #define S1BUF SBUF
  27          #define ISR_RECEIVE(_id, _src, _dest)                                            \
  28              do {                                                                         \
  29                  COM_UART##_id.LNode[COM_UART##_id.Wptr].Timer_Flag = true;               \
  30                  if (!COM_UART##_id.LNode[COM_UART##_id.Wptr].Frame_Flag){                \
  31                      COM_UART##_id.LNode[COM_UART##_id.Wptr].OverTime = MAX_SILENCE;      \
  32                      if (COM_UART##_id.LNode[COM_UART##_id.Wptr].Rx_Length < MAX_SIZE) {  \
  33                          COM_UART##_id.LNode[COM_UART##_id.Wptr].Rx_Buffer[COM_UART##_id. \
  34                          LNode[COM_UART##_id.Wptr].Rx_Length++]  = S##_id##BUF;           \
  35                          COM_UART##_id.LNode[COM_UART##_id.Wptr].Source_Channel = _src;   \
  36                          COM_UART##_id.LNode[COM_UART##_id.Wptr].Target_Channel = _dest;  \
  37                      }                                                                    \
  38                  }                                                                        \
  39              } while (0)
  40          
  41          /*å®šä¹‰ä¸€ä¸ªå½“å‰å‘èµ·è¯·æ±‚é€šé“å˜é‡*/
  42          volatile  SEL_CHANNEL current_request_channel = CHANNEL_IDLE;
  43          
  44          /*********************************************************
  45           * å‡½æ•°åï¼švoid Uart_1Init(void)
  46           * åŠŸèƒ½ï¼š  ä¸²å£1çš„åˆå§‹åŒ–
  47           * å‚æ•°ï¼š
  48           * ä½œè€…ï¼š  LHC
  49           * noteï¼š
  50           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨
  51           **********************************************************/
  52          void Uart1_Init(void) //ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
C51 COMPILER V9.60.0.0   USART                                                             03/03/2023 11:28:23 PAGE 2   

  53          {
  54   1          Uart1.Instance = UART1;
  55   1          Uart1.Register_SCON = 0x50; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
  56   1          Uart1.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
  57   1          Uart1.Uart_Count = UART1_BRT;
  58   1          Uart1.RunUart_Enable = true;
  59   1          Uart1.Interrupt_Enable = true;
  60   1          Uart1.Register_AUXR = 0x40;  //å®šæ—¶å™¨1ï¼Œ1Tæ¨¡å¼
  61   1          Uart1.Register_AUXR &= 0xFE; //æ³¢ç‰¹ç‡å‘ç”Ÿå™¨é€‰ç”¨å®šæ—¶å™¨1ï¼Œæœ€å¥½æŒ‰ç…§è¦æ±‚æ¥
  62   1      
  63   1          Uart1.Uart_NVIC.Register_IP = 0xEF; // PS=0,PSH=0,ä¸²å£1ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§ï¼Œæœ€ä½çº§
  64   1          Uart1.Uart_NVIC.Register_IPH = 0xEF;
  65   1      
  66   1          Uart_Base_MspInit(&Uart1);
  67   1      }
  68          
  69          /*********************************************************
  70           * å‡½æ•°åï¼švoid Uart1_ISR() interrupt 4 using 3
  71           * åŠŸèƒ½ï¼š  ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  72           * å‚æ•°ï¼š
  73           * ä½œè€…ï¼š  LHC
  74           * noteï¼š
  75           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨
  76           **********************************************************/
  77          void Uart1_ISR() interrupt 4 using 3 //ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  78          {
  79   1          /*å‘é€ä¸­æ–­æ ‡å¿—*/
  80   1          if (TI)
  81   1          {
  82   2              TI = 0;
  83   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
  84   2              Uart1.Uartx_busy = false;
  85   2          }
  86   1          /*æ¥æ”¶ä¸­æ–­æ ‡å¿—*/
  87   1          if (RI)
  88   1          {
  89   2              RI = 0;
  90   2      #if !USE_PRINTF_DEBUG
  91   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
  92   2              current_request_channel = CHANNEL_LAN;
  93   2              ISR_RECEIVE(1, CHANNEL_LAN, CHANNEL_PLC);
  94   2      #endif
  95   2          }
  96   1      }
  97          
  98          /*********************************************************
  99           * å‡½æ•°åï¼švoid Uart_2Init(void)
 100           * åŠŸèƒ½ï¼š  ä¸²å£2çš„åˆå§‹åŒ–
 101           * å‚æ•°ï¼š
 102           * ä½œè€…ï¼š  LHC
 103           * noteï¼š
 104           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 105           **********************************************************/
 106          void Uart2_Init(void) //ä¸²å£2é€‰æ‹©å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 107          {
 108   1          Uart2.Instance = UART2;
 109   1          Uart2.Register_SCON = 0x10; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼Œå¼€å¯ä¸²å£2æ¥æ”¶
 110   1          Uart2.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
 111   1          Uart2.Uart_Count = UART2_BRT;
 112   1          Uart2.RunUart_Enable = true;
 113   1          Uart2.Interrupt_Enable = 0x01;
 114   1          Uart2.Register_AUXR = 0x14;         //å¼€å¯å®šæ—¶å™¨2ï¼Œ1Tæ¨¡å¼
C51 COMPILER V9.60.0.0   USART                                                             03/03/2023 11:28:23 PAGE 3   

 115   1          Uart2.Uart_NVIC.Register_IP = 0xFE; // PS2=0,PS2H=0,ä¸²å£2ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§
 116   1          Uart2.Uart_NVIC.Register_IPH = 0xFE;
 117   1      
 118   1          Uart_Base_MspInit(&Uart2);
 119   1      }
 120          
 121          /*********************************************************
 122           * å‡½æ•°åï¼švoid Uart2_ISR() interrupt 8 using 3
 123           * åŠŸèƒ½ï¼š  ä¸²å£2ä¸­æ–­å‡½æ•°
 124           * å‚æ•°ï¼š
 125           * ä½œè€…ï¼š  LHC
 126           * noteï¼š
 127           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,4Gå£ç”¨
 128           **********************************************************/
 129          void Uart2_ISR() interrupt 8 using 3
 130          {   /*å‘é€ä¸­æ–­*/
 131   1          if (S2CON & S2TI)
 132   1          {
 133   2              S2CON &= ~S2TI;
 134   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 135   2              Uart2.Uartx_busy = false;
 136   2          }
 137   1          /*æ¥æ”¶ä¸­æ–­*/
 138   1          if (S2CON & S2RI)
 139   1          {
 140   2              S2CON &= ~S2RI;
 141   2      
 142   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 143   2              current_request_channel = CHANNEL_WIFI;
 144   2              ISR_RECEIVE(2, CHANNEL_WIFI, CHANNEL_PLC);
 145   2          }
 146   1      }
 147          
 148          ///*********************************************************
 149          //* å‡½æ•°åï¼švoid Uart_3Init(void)
 150          //* åŠŸèƒ½ï¼š  ä¸²å£3çš„åˆå§‹åŒ–
 151          //* å‚æ•°ï¼š
 152          //* ä½œè€…ï¼š  LHC
 153          //* noteï¼š
 154          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,æ©å¤–éƒ¨485è½¬å‘
 155          //**********************************************************/
 156          void Uart3_Init(void) //ä¸²å£3é€‰æ‹©å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 157          {
 158   1          Uart3.Instance = UART3;
 159   1          Uart3.Register_SCON = 0x50; //æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 160   1              // Uart3.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 161   1          Uart3.Uart_Mode = 0x0A;     //æ‰“å¼€å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 162   1          Uart3.Uart_Count = UART3_BRT;
 163   1          Uart3.Interrupt_Enable = 0x08;
 164   1      
 165   1          Uart_Base_MspInit(&Uart3);
 166   1      }
 167          
 168          /*********************************************************
 169           * å‡½æ•°åï¼švoid Uart3_ISR() interrupt 17 using 2
 170           * åŠŸèƒ½ï¼š  ä¸²å£3ä¸­æ–­å‡½æ•°
 171           * å‚æ•°ï¼š
 172           * ä½œè€…ï¼š  LHC
 173           * noteï¼š
 174           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,RS485æ¨¡å—
 175           **********************************************************/
 176          void Uart3_ISR() interrupt 17 using 2
C51 COMPILER V9.60.0.0   USART                                                             03/03/2023 11:28:23 PAGE 4   

 177          {
 178   1          /*å‘é€ä¸­æ–­å®Œæˆ*/
 179   1          if (S3CON & S3TI)
 180   1          {
 181   2              S3CON &= ~S3TI;
 182   2              Uart3.Uartx_busy = false; //å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 183   2          }
 184   1          /*æ¥æ”¶ä¸­æ–­*/
 185   1          if (S3CON & S3RI)
 186   1          {
 187   2              S3CON &= ~S3RI;
 188   2      
 189   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 190   2              current_request_channel = CHANNEL_RS485;
 191   2              ISR_RECEIVE(3, CHANNEL_RS485, CHANNEL_PLC);
 192   2          }
 193   1      }
 194          
 195          ///*********************************************************
 196          //* å‡½æ•°åï¼švoid Uart_4Init(void)
 197          //* åŠŸèƒ½ï¼š  ä¸²å£4çš„åˆå§‹åŒ–
 198          //* å‚æ•°ï¼š
 199          //* ä½œè€…ï¼š  LHC
 200          //* noteï¼š
 201          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 202          //**********************************************************/
 203          void Uart4_Init(void) //ä¸²å£4é€‰æ‹©å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 204          {
 205   1          Uart4.Instance = UART4;
 206   1          Uart4.Register_SCON = 0x50; //æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 207   1              // Uart4.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 208   1          Uart4.Uart_Mode = 0xA0;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½;å¼€å¯å®šæ—¶å™¨4ï¼Œ1Tæ¨¡å¼
 209   1          Uart4.Uart_Count = UART4_BRT;
 210   1          Uart4.Interrupt_Enable = 0x10;
 211   1      
 212   1          Uart_Base_MspInit(&Uart4);
 213   1      }
 214          
 215          /*********************************************************
 216           * å‡½æ•°åï¼švoid Uart4_Isr() interrupt 18 using 1
 217           * åŠŸèƒ½ï¼š  ä¸²å£4ä¸­æ–­å‡½æ•°
 218           * å‚æ•°ï¼š
 219           * ä½œè€…ï¼š  LHC
 220           * noteï¼š
 221           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 222           **********************************************************/
 223          void Uart4_Isr() interrupt 18 using 1
 224          {                             /*å‘é€ä¸­æ–­*/
 225   1          // SEL_CHANNEL temp_channel = CHANNEL_RS485;
 226   1      
 227   1          if (S4CON & S4TI)
 228   1          {
 229   2              S4CON &= ~S4TI;
 230   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 231   2              Uart4.Uartx_busy = false;
 232   2          }
 233   1          /*æ¥æ”¶ä¸­æ–­*/
 234   1          if (S4CON & S4RI)
 235   1          {
 236   2              S4CON &= ~S4RI;
 237   2      
 238   2              /*åˆ¤æ–­å½“å‰PLCæ˜¯ä¸»åŠ¨å‘é€è¿˜æ˜¯è¢«åŠ¨è¯·æ±‚*/
C51 COMPILER V9.60.0.0   USART                                                             03/03/2023 11:28:23 PAGE 5   

 239   2              // if (current_request_channel != CHANNEL_IDLE)
 240   2              // {
 241   2              //     temp_channel = CHANNEL_RS485;
 242   2              // }
 243   2              // else
 244   2              // {
 245   2              //     temp_channel = current_request_channel;
 246   2              // }
 247   2      #if !USING_PORT0_SINGLE
                      ISR_RECEIVE(4, CHANNEL_PLC, current_request_channel);
              #else
 250   2              if (!COM_UART4.Frame_Flag)
 251   2              {
 252   3                  COM_UART4.OverTime = MAX_SILENCE;
 253   3                  if (COM_UART4.Rx_Length < 
 254   3                  sizeof(COM_UART4.Rx_Buffer)/ sizeof(COM_UART4.Rx_Buffer[0]))
 255   3                  {
 256   4                      COM_UART4.Rx_Buffer[COM_UART4.Rx_Length++] = S4BUF;
 257   4                      COM_UART4.Source_Channel = CHANNEL_PLC;
 258   4                      COM_UART4.Target_Channel = current_request_channel;
 259   4                  }
 260   3              }
 261   2      #endif
 262   2          }
 263   1      }
 264          
 265          /**********************************å…¬ç”¨å‡½æ•°************************/
 266          
 267          /*********************************************************
 268           * å‡½æ•°åï¼šUart_Base_MspInit(Uart_HandleTypeDef *uart_baseHandle)
 269           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£åº•å±‚åˆå§‹åŒ–å‡½æ•°
 270           * å‚æ•°ï¼š  Uart_HandleTypeDef *uart_baseHandleä¸²å£å¥æŸ„
 271           * ä½œè€…ï¼š  LHC
 272           * noteï¼š
 273           *              æ³¨æ„æ­£ç¡®ç»™å‡ºä¸²å£å¥æŸ„
 274           **********************************************************/
 275          void Uart_Base_MspInit(Uart_HandleTypeDef *const uart_baseHandle)
 276          {
 277   1          if (uart_baseHandle->Instance == UART1)
 278   1          {
 279   2              SCON = uart_baseHandle->Register_SCON;
 280   2              TMOD |= uart_baseHandle->Uart_Mode;
 281   2              TL1 = uart_baseHandle->Uart_Count;
 282   2              TH1 = uart_baseHandle->Uart_Count >> 8;
 283   2              TR1 = uart_baseHandle->RunUart_Enable;
 284   2              AUXR |= uart_baseHandle->Register_AUXR;
 285   2              IP &= uart_baseHandle->Uart_NVIC.Register_IP;
 286   2              IPH &= uart_baseHandle->Uart_NVIC.Register_IPH;
 287   2      #if USEING_PRINTF //å¦‚æœä½¿ç”¨printf
                      TI = 1;   //æ”¾åˆ°printfé‡å®šå‘
              #else
 290   2              ES = uart_baseHandle->Interrupt_Enable; //ä¸²å£1ä¸­æ–­å…è®¸ä½
 291   2      #endif
 292   2          }
 293   1          else if (uart_baseHandle->Instance == UART2)
 294   1          {
 295   2              S2CON = uart_baseHandle->Register_SCON;
 296   2              TL2 = uart_baseHandle->Uart_Count;
 297   2              TH2 = uart_baseHandle->Uart_Count >> 8;
 298   2              AUXR |= uart_baseHandle->Register_AUXR;
 299   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£2ä¸­æ–­å…è®¸ä½
 300   2              IP2 &= uart_baseHandle->Uart_NVIC.Register_IP;
C51 COMPILER V9.60.0.0   USART                                                             03/03/2023 11:28:23 PAGE 6   

 301   2              IP2H &= uart_baseHandle->Uart_NVIC.Register_IPH;
 302   2          }
 303   1          else if (uart_baseHandle->Instance == UART3)
 304   1          {
 305   2              S3CON = uart_baseHandle->Register_SCON;
 306   2              T4T3M = uart_baseHandle->Uart_Mode;
 307   2              T3L = uart_baseHandle->Uart_Count;
 308   2              T3H = uart_baseHandle->Uart_Count >> 8;
 309   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£3ä¸­æ–­å…è®¸ä½
 310   2          }
 311   1          else if (uart_baseHandle->Instance == UART4)
 312   1          {
 313   2              S4CON = uart_baseHandle->Register_SCON;
 314   2              T4T3M |= uart_baseHandle->Uart_Mode; //æ­¤å¤„ä¸²å£3å’Œä¸²å£4å…±ç”¨
 315   2              T4L = uart_baseHandle->Uart_Count;
 316   2              T4H = uart_baseHandle->Uart_Count >> 8;
 317   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£4ä¸­æ–­å…è®¸ä½
 318   2          }
 319   1      }
 320          
 321          /*********************************************************
 322           * å‡½æ•°åï¼šstatic void Busy_Await(Uart_HandleTypeDef * const Uart, uint16_t overtime)
 323           * åŠŸèƒ½ï¼š  å­—èŠ‚å‘é€è¶…æ—¶ç­‰å¾…æœºåˆ¶
 324           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart;uint16_t overtime
 325           * ä½œè€…ï¼š  LHC
 326           * noteï¼š
 327           *
 328           **********************************************************/
 329          void Busy_Await(Uart_HandleTypeDef *const Uart, uint16_t overtime)
 330          {
 331   1      
 332   1          while (Uart->Uartx_busy) //ç­‰å¾…å‘é€å®Œæˆï¼šUart->Uartx_busyæ¸…é›¶
 333   1          {
 334   2              if (!(overtime--))
 335   2              break;
 336   2          }
 337   1      
 338   1          Uart->Uartx_busy = true; //å‘é€æ•°æ®ï¼ŒæŠŠç›¸åº”ä¸²å£ç½®å¿™
 339   1      }
 340          
 341          /*********************************************************
 342           * å‡½æ•°åï¼šUartx_SendStr(Uart_HandleTypeDef *const Uart,uint8_t *p,uint8_t length)
 343           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£å­—ç¬¦ä¸²å‘é€å‡½æ•°
 344           * å‚æ•°ï¼š  Uart_HandleTypeDef *const Uart,uint8_t *p;uint8_t length
 345           * ä½œè€…ï¼š  LHC
 346           * noteï¼š
 347           *
 348           **********************************************************/
 349          void Uartx_SendStr(Uart_HandleTypeDef *const Uart, uint8_t *p, uint8_t length)
 350          {
 351   1          /*9bitå¥‡å¶æ ¡éªŒï¼šhttps://blog.csdn.net/lljss1980/article/details/112639188*/
 352   1              uint8_t psw_p = P;
 353   1              psw_p <<= 3U;
 354   1              
 355   1          while (length--)
 356   1          {
 357   2              Busy_Await(&(*Uart), UART_BYTE_SENDOVERTIME); //ç­‰å¾…å½“å‰å­—èŠ‚å‘é€å®Œæˆ
 358   2              switch (Uart->Instance)
 359   2              {
 360   3              case UART1:
 361   3                  SBUF = *p++;
 362   3                  break;
C51 COMPILER V9.60.0.0   USART                                                             03/03/2023 11:28:23 PAGE 7   

 363   3              case UART2:
 364   3                  S2BUF = *p++;
 365   3                  break;
 366   3              case UART3:
 367   3                  S3CON |= psw_p;
 368   3                  S3BUF = *p++;
 369   3                  break;
 370   3              case UART4:
 371   3                  S4CON |= psw_p;
 372   3                  S4BUF = *p++;
 373   3                  break;
 374   3              default:
 375   3                  break;
 376   3              }
 377   2          }
 378   1      }
 379          
 380          /*********************************************************
 381           * å‡½æ•°åï¼šchar putchar(char str)
 382           * åŠŸèƒ½ï¼š  putcharé‡å®šå‘,è¢«printfè°ƒç”¨
 383           * å‚æ•°ï¼š  char strï¼Œå‘é€çš„å­—ç¬¦ä¸²
 384           * ä½œè€…ï¼š  LHC
 385           * noteï¼š
 386           *                ä½¿ç”¨printfå‡½æ•°å°†ä¼šå ç”¨1K å·¦å³FLASH
 387           **********************************************************/
 388          #if (USEING_PRINTF)
              char putchar(char str)
              {
                  ES = 0; //å…³é—­ä¸²å£1ä¸­æ–­
                  SBUF = str;
              
                  while (!TI)
                      ;
              
                  TI = 0;
                  ES = 1;
                  return str;
              }
              #endif
 402          
 403          /**********************************å…¬ç”¨å‡½æ•°************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1226    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     45       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
