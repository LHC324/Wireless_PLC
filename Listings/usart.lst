C51 COMPILER V9.60.0.0   USART                                                             12/27/2021 17:10:03 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\usart.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeModB
                    -us\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "Control.h"
   3          #include "systemTimer.h"
   4          // #include "queue.h"
   5          
   6          /*********************************************************
   7          * å‡½æ•°åï¼š
   8          * åŠŸèƒ½ï¼š
   9          * å‚æ•°ï¼š
  10          * ä½œè€…ï¼š
  11          * noteï¼š
  12                  åŒæ—¶ä½¿ç”¨å¤šä¸ªä¸²å£çš„æ—¶å€™ä¼šå‡ºç°æ•°æ®ä¼ è¾“é”™è¯¯çš„æƒ…å†µ å»ºè®®åœ¨ä½¿ç”¨è¯¥æ¿å­ä¸å
             -…¶ä»–
  13                  é€šè®¯æ¨¡å—å»ºç«‹é€šè®¯çš„æ—¶å€™ä½¿ç”¨1å¯¹1çš„å»ºç«‹è¿æ¥çš„æ¨¡å¼
  14          
  15                  è§£å†³äº†å¤šä¸²å£åŒæ—¶æ•°æ®ä¼ è¾“é”™è¯¯é—®é¢˜ //2021/5/31
  16          
  17                  åœ¨åˆ‡æ¢ä¸²å£çš„å¼•è„šè¾“å…¥æ—¶ï¼Œå»ºè®®å°†RXç«¯åˆå§‹åŒ–çš„æ—¶å€™ç»™ä¸ª0å€¼ TXå¼•è„šæ‰‹åŠ¨ç»™ä¸
             -ª1å€¼
  18                  ï¼ˆåŸºäºSTCå•ç‰‡æœºçš„ç‰¹æ€§ï¼‰
  19          
  20          **********************************************************/
  21          
  22          Uart_HandleTypeDef Uart1; //ä¸²å£1å¥æŸ„
  23          Uart_HandleTypeDef Uart2; //ä¸²å£2å¥æŸ„
  24          Uart_HandleTypeDef Uart3; //ä¸²å£3å¥æŸ„
  25          Uart_HandleTypeDef Uart4; //ä¸²å£4å¥æŸ„
  26          
  27          #define ISR_RECEIVE(current_uart, uart_id, src, dest)                                                     
             -                            \
  28              do                                                                                                    
             -                            \
  29              {                                                                                                     
             -                            \
  30                  current_uart.LNode[current_uart.Wptr].Timer_Flag = true;                                          
             -                            \
  31                  if (!current_uart.LNode[current_uart.Wptr].Frame_Flag)                                            
             -                            \
  32                  {                                                                                                 
             -                            \
  33                      current_uart.LNode[current_uart.Wptr].OverTime = MAX_SILENCE;                                 
             -                            \
  34                      if (current_uart.LNode[current_uart.Wptr].Rx_Length < MAX_SIZE)                               
             -                            \
  35                      {                                                                                             
             -                            \
  36                          current_uart.LNode[current_uart.Wptr].Rx_Buffer[current_uart.LNode[current_uart.Wptr].Rx_L
             -ength++] = S##uart_id##BUF; \
  37                          current_uart.LNode[current_uart.Wptr].Source_Channel = src;                               
             -                            \
  38                          current_uart.LNode[current_uart.Wptr].Target_Channel = dest;                              
             -                            \
  39                      }                                                                                             
             -                            \
C51 COMPILER V9.60.0.0   USART                                                             12/27/2021 17:10:03 PAGE 2   

  40                  }                                                                                                 
             -                            \
  41              } while (0);
  42          
  43          /*å®šä¹‰ä¸€ä¸ªå½“å‰å‘èµ·è¯·æ±‚é€šé“å˜é‡*/
  44          volatile  SEL_CHANNEL current_request_channel = CHANNEL_IDLE;
  45          
  46          /*********************************************************
  47           * å‡½æ•°åï¼švoid Uart_1Init(void)
  48           * åŠŸèƒ½ï¼š  ä¸²å£1çš„åˆå§‹åŒ–
  49           * å‚æ•°ï¼š
  50           * ä½œè€…ï¼š  LHC
  51           * noteï¼š
  52           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨
  53           **********************************************************/
  54          void Uart1_Init(void) //ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
  55          {
  56   1          Uart1.Instance = UART1;
  57   1          Uart1.Register_SCON = 0x50; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
  58   1          Uart1.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
  59   1          Uart1.Uart_Count = UART1_BRT;
  60   1          Uart1.RunUart_Enable = true;
  61   1          Uart1.Interrupt_Enable = true;
  62   1          Uart1.Register_AUXR = 0x40;  //å®šæ—¶å™¨1ï¼Œ1Tæ¨¡å¼
  63   1          Uart1.Register_AUXR &= 0xFE; //æ³¢ç‰¹ç‡å‘ç”Ÿå™¨é€‰ç”¨å®šæ—¶å™¨1ï¼Œæœ€å¥½æŒ‰ç…§è¦æ±‚æ¥
  64   1      
  65   1          Uart1.Uart_NVIC.Register_IP = 0xEF; // PS=0,PSH=0,ä¸²å£1ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§ï¼Œæœ€ä½çº§
  66   1          Uart1.Uart_NVIC.Register_IPH = 0xEF;
  67   1      
  68   1          Uart_Base_MspInit(&Uart1);
  69   1      }
  70          
  71          /*********************************************************
  72           * å‡½æ•°åï¼švoid Uart1_ISR() interrupt 4 using 2
  73           * åŠŸèƒ½ï¼š  ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  74           * å‚æ•°ï¼š
  75           * ä½œè€…ï¼š  LHC
  76           * noteï¼š
  77           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨
  78           **********************************************************/
  79          void Uart1_ISR() interrupt 4 using 2 //ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  80          {
  81   1          /*å‘é€ä¸­æ–­æ ‡å¿—*/
  82   1          if (TI)
  83   1          {
  84   2              TI = 0;
  85   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
  86   2              Uart1.Uartx_busy = false;
  87   2          }
  88   1          /*æ¥æ”¶ä¸­æ–­æ ‡å¿—*/
  89   1          if (RI)
  90   1          {
  91   2              RI = 0;
  92   2      
  93   2              COM_UART1.LNode[COM_UART1.Wptr].Timer_Flag = true;
  94   2              if (!COM_UART1.LNode[COM_UART1.Wptr].Frame_Flag)
  95   2              {
  96   3                  COM_UART1.LNode[COM_UART1.Wptr].OverTime = MAX_SILENCE;
  97   3                  if (COM_UART1.LNode[COM_UART1.Wptr].Rx_Length < MAX_SIZE)
  98   3                  {
  99   4                      COM_UART1.LNode[COM_UART1.Wptr].Rx_Buffer[COM_UART1.LNode[COM_UART1.Wptr].Rx_Length++] = S
             -BUF;
C51 COMPILER V9.60.0.0   USART                                                             12/27/2021 17:10:03 PAGE 3   

 100   4                      COM_UART1.LNode[COM_UART1.Wptr].Source_Channel = CHANNEL_LAN;
 101   4                      COM_UART1.LNode[COM_UART1.Wptr].Target_Channel = CHANNEL_PLC;
 102   4                  }
 103   3              }
 104   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 105   2              current_request_channel = CHANNEL_LAN;
 106   2              // ISR_RECEIVE(COM_UART1, ,CHANNEL_LAN, CHANNEL_PLC);
 107   2          }
 108   1      }
 109          
 110          /*********************************************************
 111           * å‡½æ•°åï¼švoid Uart_2Init(void)
 112           * åŠŸèƒ½ï¼š  ä¸²å£2çš„åˆå§‹åŒ–
 113           * å‚æ•°ï¼š
 114           * ä½œè€…ï¼š  LHC
 115           * noteï¼š
 116           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 117           **********************************************************/
 118          void Uart2_Init(void) //ä¸²å£2é€‰æ‹©å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 119          {
 120   1          Uart2.Instance = UART2;
 121   1          Uart2.Register_SCON = 0x10; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼Œå¼€å¯ä¸²å£2æ¥æ”¶
 122   1          Uart2.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
 123   1          Uart2.Uart_Count = UART2_BRT;
 124   1          Uart2.RunUart_Enable = true;
 125   1          Uart2.Interrupt_Enable = 0x01;
 126   1          Uart2.Register_AUXR = 0x14;         //å¼€å¯å®šæ—¶å™¨2ï¼Œ1Tæ¨¡å¼
 127   1          Uart2.Uart_NVIC.Register_IP = 0xFE; // PS2=0,PS2H=0,ä¸²å£2ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§
 128   1          Uart2.Uart_NVIC.Register_IPH = 0xFE;
 129   1      
 130   1          Uart_Base_MspInit(&Uart2);
 131   1      }
 132          
 133          /*********************************************************
 134           * å‡½æ•°åï¼švoid Uart2_ISR() interrupt 8 using 2
 135           * åŠŸèƒ½ï¼š  ä¸²å£2ä¸­æ–­å‡½æ•°
 136           * å‚æ•°ï¼š
 137           * ä½œè€…ï¼š  LHC
 138           * noteï¼š
 139           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,4Gå£ç”¨
 140           **********************************************************/
 141          void Uart2_ISR() interrupt 8 using 2
 142          {   /*å‘é€ä¸­æ–­*/
 143   1          if (S2CON & S2TI)
 144   1          {
 145   2              S2CON &= ~S2TI;
 146   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 147   2              Uart2.Uartx_busy = false;
 148   2          }
 149   1          /*æ¥æ”¶ä¸­æ–­*/
 150   1          if (S2CON & S2RI)
 151   1          {
 152   2              S2CON &= ~S2RI;
 153   2      
 154   2              COM_UART2.LNode[COM_UART2.Wptr].Timer_Flag = true;
 155   2              if (!COM_UART2.LNode[COM_UART2.Wptr].Frame_Flag)
 156   2              {
 157   3                  COM_UART2.LNode[COM_UART2.Wptr].OverTime = MAX_SILENCE;
 158   3                  if (COM_UART2.LNode[COM_UART2.Wptr].Rx_Length < MAX_SIZE)
 159   3                  {
 160   4                      COM_UART2.LNode[COM_UART2.Wptr].Rx_Buffer[COM_UART2.LNode[COM_UART2.Wptr].Rx_Length++] = S
             -2BUF;
C51 COMPILER V9.60.0.0   USART                                                             12/27/2021 17:10:03 PAGE 4   

 161   4                      COM_UART2.LNode[COM_UART2.Wptr].Source_Channel = CHANNEL_WIFI;
 162   4                      COM_UART2.LNode[COM_UART2.Wptr].Target_Channel = CHANNEL_PLC;
 163   4                  }
 164   3              }
 165   2      
 166   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 167   2              current_request_channel = CHANNEL_WIFI;
 168   2              // ISR_RECEIVE(COM_UART2, 2, CHANNEL_WIFI, CHANNEL_PLC);
 169   2          }
 170   1      }
 171          
 172          ///*********************************************************
 173          //* å‡½æ•°åï¼švoid Uart_3Init(void)
 174          //* åŠŸèƒ½ï¼š  ä¸²å£3çš„åˆå§‹åŒ–
 175          //* å‚æ•°ï¼š
 176          //* ä½œè€…ï¼š  LHC
 177          //* noteï¼š
 178          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,æ©å¤–éƒ¨485è½¬å‘
 179          //**********************************************************/
 180          void Uart3_Init(void) //ä¸²å£3é€‰æ‹©å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 181          {
 182   1          Uart3.Instance = UART3;
 183   1          Uart3.Register_SCON = 0x50; //æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 184   1              // Uart3.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 185   1          Uart3.Uart_Mode = 0x0A;     //æ‰“å¼€å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 186   1          Uart3.Uart_Count = UART3_BRT;
 187   1          Uart3.Interrupt_Enable = 0x08;
 188   1      
 189   1          Uart_Base_MspInit(&Uart3);
 190   1      }
 191          
 192          /*********************************************************
 193           * å‡½æ•°åï¼švoid Uart3_ISR() interrupt 17 using 2
 194           * åŠŸèƒ½ï¼š  ä¸²å£3ä¸­æ–­å‡½æ•°
 195           * å‚æ•°ï¼š
 196           * ä½œè€…ï¼š  LHC
 197           * noteï¼š
 198           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,RS485æ¨¡å—
 199           **********************************************************/
 200          void Uart3_ISR() interrupt 17 using 2
 201          {
 202   1          /*å‘é€ä¸­æ–­å®Œæˆ*/
 203   1          if (S3CON & S3TI)
 204   1          {
 205   2              S3CON &= ~S3TI;
 206   2              Uart3.Uartx_busy = false; //å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 207   2          }
 208   1          /*æ¥æ”¶ä¸­æ–­*/
 209   1          if (S3CON & S3RI)
 210   1          {
 211   2              S3CON &= ~S3RI;
 212   2      
 213   2              COM_UART3.LNode[COM_UART3.Wptr].Timer_Flag = true;
 214   2              if (!COM_UART3.LNode[COM_UART3.Wptr].Frame_Flag)
 215   2              {
 216   3                  COM_UART3.LNode[COM_UART3.Wptr].OverTime = MAX_SILENCE;
 217   3                  if (COM_UART3.LNode[COM_UART3.Wptr].Rx_Length < MAX_SIZE)
 218   3                  {
 219   4                      COM_UART3.LNode[COM_UART3.Wptr].Rx_Buffer[COM_UART3.LNode[COM_UART3.Wptr].Rx_Length++] = S
             -3BUF;
 220   4                      COM_UART3.LNode[COM_UART3.Wptr].Source_Channel = CHANNEL_RS485;
 221   4                      COM_UART3.LNode[COM_UART3.Wptr].Target_Channel = CHANNEL_PLC;
C51 COMPILER V9.60.0.0   USART                                                             12/27/2021 17:10:03 PAGE 5   

 222   4                  }
 223   3              }
 224   2      
 225   2              /*è®¾ç½®å½“å‰è¯·æ±‚é€šé“*/
 226   2              current_request_channel = CHANNEL_RS485;
 227   2              // ISR_RECEIVE(COM_UART3, 3, CHANNEL_RS485, CHANNEL_PLC);
 228   2          }
 229   1      }
 230          
 231          ///*********************************************************
 232          //* å‡½æ•°åï¼švoid Uart_4Init(void)
 233          //* åŠŸèƒ½ï¼š  ä¸²å£4çš„åˆå§‹åŒ–
 234          //* å‚æ•°ï¼š
 235          //* ä½œè€…ï¼š  LHC
 236          //* noteï¼š
 237          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 238          //**********************************************************/
 239          void Uart4_Init(void) //ä¸²å£4é€‰æ‹©å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 240          {
 241   1          Uart4.Instance = UART4;
 242   1          Uart4.Register_SCON = 0x50; //æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 243   1              // Uart4.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 244   1          Uart4.Uart_Mode = 0xA0;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½;å¼€å¯å®šæ—¶å™¨4ï¼Œ1Tæ¨¡å¼
 245   1          Uart4.Uart_Count = UART4_BRT;
 246   1          Uart4.Interrupt_Enable = 0x10;
 247   1      
 248   1          Uart_Base_MspInit(&Uart4);
 249   1      }
 250          
 251          /*********************************************************
 252           * å‡½æ•°åï¼švoid Uart4_Isr() interrupt 18 using 1
 253           * åŠŸèƒ½ï¼š  ä¸²å£4ä¸­æ–­å‡½æ•°
 254           * å‚æ•°ï¼š
 255           * ä½œè€…ï¼š  LHC
 256           * noteï¼š
 257           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 258           **********************************************************/
 259          void Uart4_Isr() interrupt 18 using 2
 260          {                             /*å‘é€ä¸­æ–­*/
 261   1          // SEL_CHANNEL temp_channel = CHANNEL_RS485;
 262   1      
 263   1          if (S4CON & S4TI)
 264   1          {
 265   2              S4CON &= ~S4TI;
 266   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 267   2              Uart4.Uartx_busy = false;
 268   2          }
 269   1          /*æ¥æ”¶ä¸­æ–­*/
 270   1          if (S4CON & S4RI)
 271   1          {
 272   2              S4CON &= ~S4RI;
 273   2      
 274   2              COM_UART4.LNode[COM_UART4.Wptr].Timer_Flag = true;
 275   2              if (!COM_UART4.LNode[COM_UART4.Wptr].Frame_Flag)
 276   2              {
 277   3                  COM_UART4.LNode[COM_UART4.Wptr].OverTime = MAX_SILENCE;
 278   3                  if (COM_UART4.LNode[COM_UART4.Wptr].Rx_Length < MAX_SIZE)
 279   3                  {
 280   4                      COM_UART4.LNode[COM_UART4.Wptr].Rx_Buffer[COM_UART4.LNode[COM_UART4.Wptr].Rx_Length++] = S
             -4BUF;
 281   4                      COM_UART4.LNode[COM_UART4.Wptr].Source_Channel = CHANNEL_PLC;
 282   4                      COM_UART4.LNode[COM_UART4.Wptr].Target_Channel = current_request_channel;
C51 COMPILER V9.60.0.0   USART                                                             12/27/2021 17:10:03 PAGE 6   

 283   4                  }
 284   3              }
 285   2      
 286   2              /*åˆ¤æ–­å½“å‰PLCæ˜¯ä¸»åŠ¨å‘é€è¿˜æ˜¯è¢«åŠ¨è¯·æ±‚*/
 287   2              // if (current_request_channel != CHANNEL_IDLE)
 288   2              // {
 289   2              //     temp_channel = CHANNEL_RS485;
 290   2              // }
 291   2              // else
 292   2              // {
 293   2              //     temp_channel = current_request_channel;
 294   2              // }
 295   2              // ISR_RECEIVE(COM_UART4, 4, CHANNEL_PLC, CHANNEL_RS485);
 296   2          }
 297   1      }
 298          
 299          /**********************************å…¬ç”¨å‡½æ•°************************/
 300          
 301          /*********************************************************
 302           * å‡½æ•°åï¼šUart_Base_MspInit(Uart_HandleTypeDef *uart_baseHandle)
 303           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£åº•å±‚åˆå§‹åŒ–å‡½æ•°
 304           * å‚æ•°ï¼š  Uart_HandleTypeDef *uart_baseHandleä¸²å£å¥æŸ„
 305           * ä½œè€…ï¼š  LHC
 306           * noteï¼š
 307           *              æ³¨æ„æ­£ç¡®ç»™å‡ºä¸²å£å¥æŸ„
 308           **********************************************************/
 309          void Uart_Base_MspInit(Uart_HandleTypeDef *const uart_baseHandle)
 310          {
 311   1          if (uart_baseHandle->Instance == UART1)
 312   1          {
 313   2              SCON = uart_baseHandle->Register_SCON;
 314   2              TMOD |= uart_baseHandle->Uart_Mode;
 315   2              TL1 = uart_baseHandle->Uart_Count;
 316   2              TH1 = uart_baseHandle->Uart_Count >> 8;
 317   2              TR1 = uart_baseHandle->RunUart_Enable;
 318   2              AUXR |= uart_baseHandle->Register_AUXR;
 319   2              IP &= uart_baseHandle->Uart_NVIC.Register_IP;
 320   2              IPH &= uart_baseHandle->Uart_NVIC.Register_IPH;
 321   2      #if USEING_PRINTF //å¦‚æœä½¿ç”¨printf
                      TI = 1;   //æ”¾åˆ°printfé‡å®šå‘
              #else
 324   2              ES = uart_baseHandle->Interrupt_Enable; //ä¸²å£1ä¸­æ–­å…è®¸ä½
 325   2      #endif
 326   2          }
 327   1          else if (uart_baseHandle->Instance == UART2)
 328   1          {
 329   2              S2CON = uart_baseHandle->Register_SCON;
 330   2              TL2 = uart_baseHandle->Uart_Count;
 331   2              TH2 = uart_baseHandle->Uart_Count >> 8;
 332   2              AUXR |= uart_baseHandle->Register_AUXR;
 333   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£2ä¸­æ–­å…è®¸ä½
 334   2              IP2 &= uart_baseHandle->Uart_NVIC.Register_IP;
 335   2              IP2H &= uart_baseHandle->Uart_NVIC.Register_IPH;
 336   2          }
 337   1          else if (uart_baseHandle->Instance == UART3)
 338   1          {
 339   2              S3CON = uart_baseHandle->Register_SCON;
 340   2              T4T3M = uart_baseHandle->Uart_Mode;
 341   2              T3L = uart_baseHandle->Uart_Count;
 342   2              T3H = uart_baseHandle->Uart_Count >> 8;
 343   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£3ä¸­æ–­å…è®¸ä½
 344   2          }
C51 COMPILER V9.60.0.0   USART                                                             12/27/2021 17:10:03 PAGE 7   

 345   1          else if (uart_baseHandle->Instance == UART4)
 346   1          {
 347   2              S4CON = uart_baseHandle->Register_SCON;
 348   2              T4T3M |= uart_baseHandle->Uart_Mode; //æ­¤å¤„ä¸²å£3å’Œä¸²å£4å…±ç”¨
 349   2              T4L = uart_baseHandle->Uart_Count;
 350   2              T4H = uart_baseHandle->Uart_Count >> 8;
 351   2              IE2 |= uart_baseHandle->Interrupt_Enable; //ä¸²å£4ä¸­æ–­å…è®¸ä½
 352   2          }
 353   1      }
 354          
 355          /*********************************************************
 356           * å‡½æ•°åï¼šstatic void Busy_Await(Uart_HandleTypeDef * const Uart, uint16_t overtime)
 357           * åŠŸèƒ½ï¼š  å­—èŠ‚å‘é€è¶…æ—¶ç­‰å¾…æœºåˆ¶
 358           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart;uint16_t overtime
 359           * ä½œè€…ï¼š  LHC
 360           * noteï¼š
 361           *
 362           **********************************************************/
 363          void Busy_Await(Uart_HandleTypeDef *const Uart, uint16_t overtime)
 364          {
 365   1      
 366   1          while (Uart->Uartx_busy) //ç­‰å¾…å‘é€å®Œæˆï¼šUart->Uartx_busyæ¸…é›¶
 367   1          {
 368   2              if (!(overtime--))
 369   2                  break;
 370   2          }
 371   1      
 372   1          Uart->Uartx_busy = true; //å‘é€æ•°æ®ï¼ŒæŠŠç›¸åº”ä¸²å£ç½®å¿™
 373   1      }
 374          
 375          /*********************************************************
 376           * å‡½æ•°åï¼šUartx_SendStr(Uart_HandleTypeDef *const Uart,uint8_t *p,uint8_t length)
 377           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£å­—ç¬¦ä¸²å‘é€å‡½æ•°
 378           * å‚æ•°ï¼š  Uart_HandleTypeDef *const Uart,uint8_t *p;uint8_t length
 379           * ä½œè€…ï¼š  LHC
 380           * noteï¼š
 381           *
 382           **********************************************************/
 383          void Uartx_SendStr(Uart_HandleTypeDef *const Uart, uint8_t *p, uint8_t length)
 384          {
 385   1              uint8_t psw_p = P;
 386   1              psw_p <<= 3U;
 387   1              
 388   1          while (length--)
 389   1          {
 390   2              Busy_Await(&(*Uart), UART_BYTE_SENDOVERTIME); //ç­‰å¾…å½“å‰å­—èŠ‚å‘é€å®Œæˆ
 391   2              switch (Uart->Instance)
 392   2              {
 393   3              case UART1:
 394   3                  SBUF = *p++;
 395   3                  break;
 396   3              case UART2:
 397   3                  S2BUF = *p++;
 398   3                  break;
 399   3              case UART3:
 400   3                  // if (System_Parameter.Ppistate)
 401   3                  {
 402   4                      S3CON |= psw_p;
 403   4                  }
 404   3                  S3BUF = *p++;
 405   3                  break;
 406   3              case UART4:
C51 COMPILER V9.60.0.0   USART                                                             12/27/2021 17:10:03 PAGE 8   

 407   3                  // if (System_Parameter.Ppistate)
 408   3                  {
 409   4                      S4CON |= psw_p;
 410   4                  }
 411   3                  S4BUF = *p++;
 412   3                  break;
 413   3              default:
 414   3                  break;
 415   3              }
 416   2          }
 417   1      }
 418          
 419          /*********************************************************
 420           * å‡½æ•°åï¼šchar putchar(char str)
 421           * åŠŸèƒ½ï¼š  putcharé‡å®šå‘,è¢«printfè°ƒç”¨
 422           * å‚æ•°ï¼š  char strï¼Œå‘é€çš„å­—ç¬¦ä¸²
 423           * ä½œè€…ï¼š  LHC
 424           * noteï¼š
 425           *                ä½¿ç”¨printfå‡½æ•°å°†ä¼šå ç”¨1K å·¦å³FLASH
 426           **********************************************************/
 427          #if (USEING_PRINTF)
              char putchar(char str)
              {
                  ES = 0; //å…³é—­ä¸²å£1ä¸­æ–­
                  SBUF = str;
              
                  while (!TI)
                      ;
              
                  TI = 0;
                  ES = 1;
                  return str;
              }
              #endif
 441          
 442          /**********************************å…¬ç”¨å‡½æ•°************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1236    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     45       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
