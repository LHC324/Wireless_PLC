C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Objects\Menu.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\Menu.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Include;.\FreeModB
                    -us\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\Menu.lst) OBJECT(.\Objects\Menu.obj)

line level    source

   1          #include "Menu.h"
   2          
   3          /*当前UI界面状态*/
   4          SHOW_STATE UI_STATE = MAIN_STATE;
   5          
   6          OPTION Optionlist[] =
   7          {
   8              {"启停开关", CONTROL_PLCPOWER, PlcPowerUIshow},
   9              {"通信方式", CONTROL_COMMUNICA, CommunicaUIshow},
  10              {"密码修改", CONTROL_PASSWORD_CHANGE, PassWordChangeUIShow},
  11              {"波特率设置", CONTROL_BAUDSETTING, Baud_Setting},
  12              {"恢复出厂设置", CONTROL_RELOAD, ReloadSettingUIshow},
  13          };
  14          
  15          #define OptionlistSize (sizeof(Optionlist) / sizeof(OPTION))
  16          
  17          /*二级菜单*/
  18          OPTION Optionlist1[] =
  19          {
  20              {"以太网", CONTROL_BAUD1, BaudSettingUI1show},
  21              {"无线网", CONTROL_BAUD2, BaudSettingUI2show}, 
  22              {"扩展网", CONTROL_BAUD3, BaudSettingUI3show}, 
  23              {"内部网", CONTROL_BAUD4, BaudSettingUI4show}
  24          };
  25          
  26          #define OptionlistSize1 (sizeof(Optionlist1) / sizeof(OPTION))
  27          
  28          /*当前多级菜单数量*/
  29          Menu_Show M_Show[] = 
  30          {
  31              {0, 0, 0, {1, 2, 3}, Optionlist}, 
  32              {0, 0, 0, {1, 2, 3}, Optionlist1}
  33          
  34          };
  35          
  36          #define MENU_NUM (sizeof(M_Show) / sizeof(Menu_Show))
  37          
  38          /*函数映射表*/
  39          const KEY_MAP keyStateEvent[] =
  40              {
  41                  /*Main状态*/
  42                  {KEY_UP, MAIN_STATE, KeyMain_Up},
  43                  {KEY_DOWN, MAIN_STATE, KeyMain_Down},
  44                  {KEY_ENTER, MAIN_STATE, KeyMain_Enter},
  45                  {KEY_CANCEL, MAIN_STATE, KeyMain_Cancel},
  46                  {KEY_MENU, MAIN_STATE, KeyMain_Menu},
  47                  /*Menu状态*/
  48                  {KEY_UP, MENU_STATE, KeyMenu_Up},
  49                  {KEY_DOWN, MENU_STATE, KeyMenu_Down},
  50                  {KEY_ENTER, MENU_STATE, KeyMenu_Enter},
  51                  {KEY_CANCEL, MENU_STATE, KeyMenu_Cancel},
  52                  {KEY_MENU, MENU_STATE, KeyMenu_Menu},
  53                  /*CONTROL状态*/
  54                  {KEY_UP, CONTROL_STATE, KeyControl_Up},
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 2   

  55                  {KEY_DOWN, CONTROL_STATE, KeyControl_Down},
  56                  {KEY_ENTER, CONTROL_STATE, KeyControl_Enter},
  57                  {KEY_CANCEL, CONTROL_STATE, KeyControl_Cancel},
  58                  {KEY_MENU, CONTROL_STATE, KeyControl_Menu},
  59                  /*BAUD状态*/
  60                  {KEY_UP, BAUD_STATE, KeyBaud_Up},
  61                  {KEY_DOWN, BAUD_STATE, KeyBaud_Down},
  62                  {KEY_ENTER, BAUD_STATE, KeyBaud_Enter},
  63                  {KEY_CANCEL, BAUD_STATE, KeyBaud_Cancel},
  64                  {KEY_MENU, BAUD_STATE, KeyBaud_Menu}
  65          };
  66          
  67          #define keyStateEventSize (sizeof(keyStateEvent) / sizeof(KEY_MAP))
  68          
  69          void KeyEvent(void) //按键事件
  70          {
  71   1          uint8_t i;
  72   1          KEY_e KeyState = Key_Chick(); //获取按键状态
  73   1      
  74   1          LcdDly(KeyState); // 无按键操作返回函数
  75   1      
  76   1          if (KeyState == NO_KEY) //无按键直接返回
  77   1          {
  78   2              return;
  79   2          }
  80   1      
  81   1          for (i = 0; i < keyStateEventSize; i++)
  82   1          {
  83   2              if (KeyState == keyStateEvent[i].Keycodel) //按键值
  84   2              {
  85   3                  if (UI_STATE == keyStateEvent[i].Stage) //按键状态
  86   3                  {
  87   4                      keyStateEvent[i].fun(); //执行按键状态对应函数
  88   4                      break;
  89   4                  }
  90   3              }
  91   2          }
  92   1      }
  93          
  94          void LcdShowInit(void) //界面显示初始化
  95          {
  96   1          LcdShow(&ScreensaverUiShow);
  97   1      }
  98          
  99          void LcdShow(pshow InterfaceShow) //界面显示接口(回调函数思想)
 100          {
 101   1          InterfaceShow();
 102   1      }
 103          
 104          /**
 105           * @brief       主界面状态--enter
 106           * @details     在主界面下按下enter按钮
 107           * @param       None
 108           * @retval      None
 109           */
 110          void KeyMain_Enter(void)
 111          {
 112   1      #if USE_PRINTF_DEBUG
                  uint8_t temp = strncmp(System_Parameter.PSWNext.PassWordbuff, "\xFF\xFF\xFF\xFF", PASSWORDBITS);
              #endif
 115   1          if (ControlType == CONTROL_PASSWORD)
 116   1          {
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 3   

 117   2              /*没有设置过密码或者密码正确*/
 118   2              if (PassWordjudge(PassWordI, System_Parameter) || (!strncmp(System_Parameter.PSWNext.PassWordbuff,
             - "\xFF\xFF\xFF\xFF", PASSWORDBITS)))
 119   2              {
 120   3                  LcdShow(RefreshMenuDisp); //刷新界面
 121   3                  UI_STATE = MENU_STATE;
 122   3                  // PublicTimer16.MenuDly16.Timer16Count = T_60S; //无操作返回定时器开启
 123   3              }
 124   2              else //如果密码错误
 125   2              {
 126   3                  PassWordDelete(&PassWordI);
 127   3                  clear_screen();
 128   3                  GUI_String(49, 31, "wrong password !", EN_5_8);
 129   3                  Delay_ms(1000);
 130   3                  LcdShow(PassWordInputUIShow); //重新输入
 131   3              }
 132   2          }
 133   1      
 134   1      #if USE_PRINTF_DEBUG
                  Uartx_SendStr(&Uart1, System_Parameter.PSWNext.PassWordbuff, 4);
                  Uartx_SendStr(&Uart1, &temp, 1);
                  printf("KeyMain_Enter\r\n");
              #endif
 139   1      }
 140          
 141          void KeyMain_Up(void) //主界面状态--Up
 142          {
 143   1          if (ControlType == CONTROL_PASSWORD) //密码控件
 144   1          {
 145   2              uint8_t Value = PassWordInput(ADD, &PassWordI);
 146   2              uint8_t temp[2]; //字符
 147   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 148   2          }
 149   1      
 150   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Up\r\n");
              #endif
 153   1      }
 154          /*屏保界面到密码输入界面切换*/
 155          void KeyMain_Menu(void) //主界面状态--Menu
 156          {
 157   1          switch (ControlType)
 158   1          {
 159   2          case CONTROL_SCREENSAVE:
 160   2          {
 161   3              /*切换到密码界面*/
 162   3              ControlType = CONTROL_PASSWORD;
 163   3              LcdShow(&PassWordInputUIShow);
 164   3              /*无操作返回定时器开启*/
 165   3              PublicTimer16.MenuDly16.Timer16Count = T_60S;
 166   3          }
 167   2          break;
 168   2          case CONTROL_PASSWORD:
 169   2          { /*改变当前密码输入位置*/
 170   3              InputOffect(&PassWordI);
 171   3          }
 172   2          break;
 173   2          default:
 174   2              break;
 175   2          }
 176   1      
 177   1      #if USE_PRINTF_DEBUG
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 4   

                  printf("KeyMain_Menu\r\n");
              #endif
 180   1      }
 181          
 182          void KeyMain_Cancel(void) //主界面状态--Cancel
 183          {
 184   1          /*主界面按下取消键，退到屏保界面*/
 185   1          if (ControlType == CONTROL_PASSWORD)
 186   1          {
 187   2              LcdShow(&ScreensaverUiShow);
 188   2              PassWordDelete(&PassWordI);
 189   2          }
 190   1      
 191   1      #if USE_PRINTF_DEBUG
                  printf("%s\r\n", System_Parameter.PSWNext.PassWordbuff); //防止忘记密码之后进不去PLC
              #endif
 194   1      }
 195          
 196          void KeyMain_Down(void) //主界面状态--Down
 197          {
 198   1          if (ControlType == CONTROL_PASSWORD)
 199   1          {
 200   2              uint8_t Value = PassWordInput(SUB, &PassWordI);
 201   2              uint8_t temp[2]; //字符
 202   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 203   2          }
 204   1      
 205   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Down\r\n");
              #endif
 208   1      }
 209          
 210          void KeyMenu_Enter(void) //菜单状态--Enter
 211          {
 212   1          if (M_Show[MAIN_MENU].OptionNow->ControlShow == NULL)
 213   1          {
 214   2              return;
 215   2          }
 216   1      
 217   1          UI_STATE = CONTROL_STATE;
 218   1          ControlType = M_Show[MAIN_MENU].OptionNow->ControlType; //赋值控件
 219   1          LcdShow(M_Show[MAIN_MENU].OptionNow->ControlShow);      //显示控制界面
 220   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Enter\r\n");
              #endif
 223   1      }
 224          
 225          /*菜单状态--Up*/
 226          void KeyMenu_Up(void) 
 227          {
 228   1          /*箭头索引减小*/
 229   1          if ((M_Show[MAIN_MENU].Finger_Index--) == 0) 
 230   1              M_Show[MAIN_MENU].Finger_Index = 0;
 231   1      
 232   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(UPWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize);
 233   1      
 234   1          if (M_Show[MAIN_MENU].Option_Index == (OptionlistSize - 1)) //索引逻辑
 235   1          {
 236   2              M_Show[MAIN_MENU].Finger_Index = 2;
 237   2          }
 238   1          /*菜单滑动逻辑*/
 239   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 5   

 240   1          {
 241   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
 242   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 243   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 244   2          }
 245   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 246   1          {
 247   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 248   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 249   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 250   2          }
 251   1          else
 252   1          {
 253   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 254   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 255   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 256   2          }
 257   1      
 258   1          LcdShow(RefreshMenuDisp);             //刷新显示
 259   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 260   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Up\r\n");
              #endif
 263   1      }
 264          
 265          /*菜单状态--Menu*/
 266          void KeyMenu_Menu(void) 
 267          {
 268   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Menu\r\n");
              #endif
 271   1      }
 272          
 273          void KeyMenu_Cancel(void) //菜单状态--Cancel
 274          {
 275   1          /*菜单界面按下取消键，直接锁屏*/
 276   1          UI_STATE = MAIN_STATE;
 277   1          ControlType = CONTROL_SCREENSAVE;
 278   1          LcdShow(&ScreensaverUiShow);
 279   1          PassWordDelete(&PassWordI);
 280   1      
 281   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Cancel\r\n");
              #endif
 284   1      }
 285          
 286          void KeyMenu_Down(void) //菜单状态--Down
 287          {
 288   1          if ((M_Show[MAIN_MENU].Finger_Index++) == 2) //箭头索引增加
 289   1              M_Show[MAIN_MENU].Finger_Index = 2;
 290   1      
 291   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize); 
             -//选项索引
 292   1      
 293   1          if (M_Show[MAIN_MENU].Option_Index == 0) //索引逻辑
 294   1          {
 295   2              M_Show[MAIN_MENU].Finger_Index = 0;
 296   2          }
 297   1      
 298   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
 299   1          {
 300   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 6   

 301   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 302   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 303   2          }
 304   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 305   1          {
 306   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 307   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 308   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 309   2          }
 310   1          else
 311   1          {
 312   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 313   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 314   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 315   2          }
 316   1      
 317   1          LcdShow(RefreshMenuDisp);             //刷新显示
 318   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 319   1      
 320   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Down\r\n");
              #endif
 323   1      }
 324          
 325          void KeyControl_Enter(void) //控件状态--Enter
 326          {
 327   1          switch (ControlType)
 328   1          {
 329   2          case CONTROL_PASSWORD_CHANGE:
 330   2          {
 331   3              if (PassWordFirstChangeFlag == 0) //如果是第一次输入修改密码
 332   3              {
 333   4                  uint8_t i;
 334   4                  uint8_t temp[2];
 335   4      
 336   4                  for (i = 0; i < PASSWORDBITS; i++) //显示4位密码
 337   4                  {
 338   5                      GUI_String(i * 20 + 100, 18, myitoa(PassWordChange1.PSWNext.PassWordbuff[i], temp, 10), EN
             -_5_8);
 339   5                  }
 340   4      
 341   4                  GUI_Lattice(175, 16, 16, 12, dot);
 342   4                  PassWordFirstChangeFlag = 1; //置标志位
 343   4              }
 344   3              else
 345   3              {
 346   4      
 347   4                  if (PassWordjudge(PassWordChange1, PassWordChange2)) //密码判断两次输入相同密码时修改成功
 348   4                  {
 349   5                      memcpy(&System_Parameter.PSWNext.PassWordbuff, &PassWordChange2.PSWNext.PassWordbuff, size
             -of(PassWordChange2.PSWNext.PassWordbuff));
 350   5                      ControlSave();
 351   5                      PassWordDelete(&PassWordChange1); //修改密码1清0
 352   5                      PassWordDelete(&PassWordChange2); //修改密码2清0
 353   5                      UI_STATE = MENU_STATE;            //返回菜单界面
 354   5      
 355   5                      clear_screen();
 356   5                      GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 357   5                      Delay_ms(500);
 358   5                      LcdShow(RefreshMenuDisp); //刷新显示
 359   5                  }
 360   4                  else //两次密码输入不一致时
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 7   

 361   4                  {
 362   5      
 363   5                      clear_screen();
 364   5                      GUI_String(70, 22, "修改失败", CH_12_12); //显示修改结果
 365   5                      Delay_ms(500);
 366   5                      LcdShow(PassWordChangeUIShow); //修改密码
 367   5                  }
 368   4      
 369   4                  PassWordFirstChangeFlag = 0; //置0标志位
 370   4              }
 371   3      
 372   3              break;
 373   3          }
 374   2      
 375   2          case CONTROL_PLCPOWER:
 376   2          {
 377   3              System_Parameter.PlcState ^= 1;
 378   3              RUNKEY = System_Parameter.PlcState;
 379   3              ControlSave();           //存盘开关量
 380   3              LcdShow(PlcPowerUIshow); // PLC设置界面
 381   3              break;
 382   3          }
 383   2      
 384   2          case CONTROL_COMMUNICA:
 385   2          {
 386   3              if (System_Parameter.CommunicationType == LOCAL)
 387   3              {
 388   4                  Wifi_Enable(false);
 389   4              }
 390   3              else
 391   3              {
 392   4                  Wifi_Enable(true);
 393   4                  clear_screen();
 394   4                  GUI_String(30, 22, "Please wait a moment", EN_5_8);
 395   4                  // /*初始化WIIF模块*/
 396   4                  // Wifi_Init();
 397   4              }
 398   3              ControlSave(); //存盘通信方式
 399   3      
 400   3              clear_screen();
 401   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 402   3              Delay_ms(500);
 403   3              LcdShow(CommunicaUIshow); //通讯设置界面
 404   3              break;
 405   3          }
 406   2      
 407   2          case CONTROL_BAUDSETTING:
 408   2          {
 409   3              if (M_Show[SEC0_MENU].OptionNow->ControlShow == NULL)
 410   3              {
 411   4                  return;
 412   4              }
 413   3                  /*切换到波特率设置界面*/
 414   3                  UI_STATE = BAUD_STATE;
 415   3              /*赋值控件*/
 416   3              ControlType = M_Show[SEC0_MENU].OptionNow->ControlType; 
 417   3              /*显示控制界面*/
 418   3              LcdShow(M_Show[SEC0_MENU].OptionNow->ControlShow);      
 419   3                  /*无操作返回定时器开启*/
 420   3                  // PublicTimer16.MenuDly16.Timer16Count = T_60S; 
 421   3          } break;
 422   2          /*恢复出厂设置*/
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 8   

 423   2          case CONTROL_RELOAD:
 424   2          {
 425   3              // novalueflag = true;
 426   3              CLOSE_GLOBAL_OUTAGE();
 427   3              IapErase(START_SAVEADDRESS); //擦除密码区
 428   3                                           /*把默认参数拷贝到当前数据结构*/
 429   3              memcpy(&System_Parameter.PSWNext.PassWordbuff[0], DEFAULT_SYSTEM_PARAMETER, (sizeof(System_Paramet
             -er) - 1U));
 430   3              /*把数据进行存储*/
 431   3              IapWrite_Buff(START_SAVEADDRESS, &System_Parameter.PSWNext.PassWordbuff[0], (sizeof(System_Paramet
             -er) - 1U)); //使密码界面失效
 432   3              OPEN_GLOBAL_OUTAGE();
 433   3      
 434   3              BaudInit();
 435   3              // PassWordinit();
 436   3              PowerInit();
 437   3              CommunicaInit();
 438   3              UI_STATE = MENU_STATE; //返回菜单界面
 439   3      
 440   3              clear_screen();
 441   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 442   3              Delay_ms(500);
 443   3              LcdShow(RefreshMenuDisp); //刷新显示
 444   3              break;
 445   3          }
 446   2      
 447   2          default:
 448   2              break;
 449   2          }
 450   1      
 451   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Enter\r\n");
              #endif
 454   1      }
 455          
 456          void KeyControl_Menu(void) //控件状态--Menu
 457          {
 458   1          switch (ControlType)
 459   1          {
 460   2          case CONTROL_PASSWORD_CHANGE:
 461   2          {
 462   3              if (PassWordFirstChangeFlag == 0)
 463   3              {
 464   4      
 465   4                  InputOffect(&PassWordChange1);
 466   4              }
 467   3              else
 468   3              {
 469   4      
 470   4                  InputOffect(&PassWordChange2);
 471   4              }
 472   3      
 473   3              break;
 474   3          }
 475   2      
 476   2          default:
 477   2              break;
 478   2          }
 479   1      
 480   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Menu\r\n");
              #endif
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 9   

 483   1      }
 484          
 485          void KeyControl_Cancel(void) //控件状态--Cancel
 486          {
 487   1          switch (ControlType)
 488   1          {
 489   2          case CONTROL_PASSWORD_CHANGE:
 490   2          {
 491   3              break;
 492   3          }
 493   2      
 494   2          case CONTROL_COMMUNICA:
 495   2          {
 496   3              // CommunciaIndex = CommunciaType; //如果没有确定,直接返回，则恢复当前状态索引
 497   3              break;
 498   3          }
 499   2      
 500   2          case CONTROL_BAUDSETTING:
 501   2          {
 502   3              // BaudWillIndex = BaudIndex; //如果没有确定,直接返回，则恢复当前状态索引
 503   3              break;
 504   3          }
 505   2      
 506   2          case CONTROL_RELOAD:
 507   2          {
 508   3              break;
 509   3          }
 510   2      
 511   2          default:
 512   2              break;
 513   2          }
 514   1      
 515   1          UI_STATE = MENU_STATE;    //返回菜单界面
 516   1          LcdShow(RefreshMenuDisp); //显示设置
 517   1      
 518   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Cancel\r\n");
              #endif
 521   1      }
 522          
 523          /*控件状态--Up*/
 524          void KeyControl_Up(void) 
 525          {
 526   1          switch (ControlType)
 527   1          {
 528   2          case CONTROL_PASSWORD_CHANGE:
 529   2          {
 530   3              if (PassWordFirstChangeFlag == 0)
 531   3              {
 532   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange1);
 533   4                  uint8_t temp[2]; //字符
 534   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
 535   4              }
 536   3              else
 537   3              {
 538   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange2);
 539   4                  uint8_t temp[2]; //字符
 540   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 541   4              }  
 542   3          }break;
 543   2      
 544   2          case CONTROL_COMMUNICA:
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 10  

 545   2          {
 546   3              System_Parameter.CommunicationType ^= 1;
 547   3              LcdShow(CommunicaUIshow); //通讯设置界面
 548   3          }break;
 549   2      
 550   2          case CONTROL_BAUDSETTING:
 551   2          {
 552   3              /*箭头索引减小*/
 553   3              if ((M_Show[SEC0_MENU].Finger_Index--) == 0) 
 554   3                  M_Show[SEC0_MENU].Finger_Index = 0;
 555   3      
 556   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(UPWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSize1
             -);
 557   3      
 558   3              if (M_Show[SEC0_MENU].Option_Index == (OptionlistSize1 - 1)) //索引逻辑
 559   3              {
 560   4                  M_Show[SEC0_MENU].Finger_Index = 2;
 561   4              }
 562   3              /*菜单滑动逻辑*/
 563   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 564   3              {
 565   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 566   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 567   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 568   4              }
 569   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 570   3              {
 571   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 572   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 573   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
 574   4              }
 575   3              else
 576   3              {
 577   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 578   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
 579   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
 580   4              }
 581   3      
 582   3              LcdShow(RefreshBaudDisp);             //刷新显示
 583   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 584   3          }break;
 585   2      
 586   2          default:
 587   2              break;
 588   2          }
 589   1      
 590   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Up\r\n");
              #endif
 593   1      }
 594          
 595          void KeyControl_Down(void) //控件状态--Down
 596          {
 597   1          switch (ControlType)
 598   1          {
 599   2          case CONTROL_PASSWORD_CHANGE:
 600   2          {
 601   3              if (PassWordFirstChangeFlag == 0)
 602   3              {
 603   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange1);
 604   4                  uint8_t temp[2]; //字符
 605   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 11  

 606   4              }
 607   3              else
 608   3              {
 609   4      
 610   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange2);
 611   4                  uint8_t temp[2]; //字符
 612   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 613   4              }
 614   3      
 615   3          }break;
 616   2      
 617   2          case CONTROL_COMMUNICA:
 618   2          {
 619   3              System_Parameter.CommunicationType ^= 1;
 620   3              LcdShow(CommunicaUIshow); //通讯设置界面
 621   3              
 622   3          }break;
 623   2      
 624   2          case CONTROL_BAUDSETTING:
 625   2          {   
 626   3              if ((M_Show[SEC0_MENU].Finger_Index++) >= 2) //箭头索引增加
 627   3              M_Show[SEC0_MENU].Finger_Index = 2;
 628   3      
 629   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSiz
             -e1); //选项索引
 630   3      
 631   3              if (M_Show[SEC0_MENU].Option_Index == 0) //索引逻辑
 632   3              {
 633   4                  M_Show[SEC0_MENU].Finger_Index = 0;
 634   4              }
 635   3      
 636   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 637   3              {
 638   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 639   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 640   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 641   4              }
 642   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 643   3              {
 644   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 645   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 646   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
 647   4              }
 648   3              else
 649   3              {
 650   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 651   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
 652   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
 653   4              }
 654   3              /*刷新当前选项卡*/
 655   3              LcdShow(RefreshBaudDisp);             
 656   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 657   3          }break;
 658   2      
 659   2          default:
 660   2              break;
 661   2          }
 662   1      
 663   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Down\r\n");
              #endif
 666   1      }
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 12  

 667          
 668          /*波特率控件状态--up*/
 669          void KeyBaud_Up(void)
 670          {
 671   1          switch (ControlType)
 672   1          {
 673   2              case CONTROL_BAUD1:
 674   2              {
 675   3                  System_Parameter.BaudIndex[0] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[0], G_BaudList_
             -Size);
 676   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 677   3              }break;
 678   2              case CONTROL_BAUD2:
 679   2              {
 680   3                  System_Parameter.BaudIndex[1] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[1], G_BaudList_
             -Size);
 681   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 682   3              }break;
 683   2              case CONTROL_BAUD3:
 684   2              {
 685   3                  System_Parameter.BaudIndex[2] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[2], G_BaudList_
             -Size);
 686   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 687   3              }break;
 688   2              case CONTROL_BAUD4:
 689   2              {
 690   3                  System_Parameter.BaudIndex[3] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[3], G_BaudList_
             -Size);
 691   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
 692   3              }break;
 693   2              default : break;
 694   2          }
 695   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Up\r\n");
              #endif
 698   1      }
 699          
 700          /*波特率控件状态--Down*/
 701          void KeyBaud_Down(void)
 702          {
 703   1          switch (ControlType)
 704   1          {
 705   2              case CONTROL_BAUD1:
 706   2              {
 707   3                  System_Parameter.BaudIndex[0] = LoopIndex(UPWORD, System_Parameter.BaudIndex[0], G_BaudList_Si
             -ze);
 708   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 709   3              }break;
 710   2              case CONTROL_BAUD2:
 711   2              {
 712   3                  System_Parameter.BaudIndex[1] = LoopIndex(UPWORD, System_Parameter.BaudIndex[1], G_BaudList_Si
             -ze);
 713   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 714   3              }break;
 715   2              case CONTROL_BAUD3:
 716   2              {
 717   3                  System_Parameter.BaudIndex[2] = LoopIndex(UPWORD, System_Parameter.BaudIndex[2], G_BaudList_Si
             -ze);
 718   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 719   3              }break;
 720   2              case CONTROL_BAUD4:
 721   2              {
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 13  

 722   3                  System_Parameter.BaudIndex[3] = LoopIndex(UPWORD, System_Parameter.BaudIndex[3], G_BaudList_Si
             -ze);
 723   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
 724   3              }break;
 725   2              default : break;
 726   2          }
 727   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Down\r\n");
              #endif
 730   1      }
 731          
 732          /*波特率控件状态--Enter*/
 733          void KeyBaud_Enter(void)
 734          {
 735   1          switch (ControlType)
 736   1          {
 737   2              case CONTROL_BAUD1:
 738   2              {
 739   3                  SET_BRT1(1, Baudlist[System_Parameter.BaudIndex[0]].BaudValue);
 740   3                  ControlSave();
 741   3      
 742   3                  clear_screen();
 743   3                  GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 744   3                  Delay_ms(500);
 745   3                  LcdShow(BaudSettingUI1show); //波特率设置界面
 746   3              }break;
 747   2              case CONTROL_BAUD2:
 748   2              {
 749   3                  SET_BRT1(2, Baudlist[System_Parameter.BaudIndex[1]].BaudValue);
 750   3                  ControlSave();
 751   3      
 752   3                  clear_screen();
 753   3                  GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 754   3                  Delay_ms(500);
 755   3                  LcdShow(BaudSettingUI2show); //波特率设置界面
 756   3              }break;
 757   2              case CONTROL_BAUD3:
 758   2              {
 759   3                  SET_BRT1(3, Baudlist[System_Parameter.BaudIndex[2]].BaudValue);
 760   3                  ControlSave();
 761   3      
 762   3                  clear_screen();
 763   3                  GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 764   3                  Delay_ms(500);
 765   3                  LcdShow(BaudSettingUI3show); //波特率设置界面
 766   3              }break;
 767   2              case CONTROL_BAUD4:
 768   2              {
 769   3                  SET_BRT1(4, Baudlist[System_Parameter.BaudIndex[3]].BaudValue);
 770   3                  ControlSave();
 771   3      
 772   3                  clear_screen();
 773   3                  GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 774   3                  Delay_ms(500);
 775   3                  LcdShow(BaudSettingUI4show); //波特率设置界面
 776   3              }break;
 777   2              default : break;
 778   2          }
 779   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Enter\r\n");
              #endif
 782   1      }
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 14  

 783          
 784          /*波特率控件状态--Cancel*/
 785          void KeyBaud_Cancel(void)
 786          {   /*返回上级菜单界面*/
 787   1          UI_STATE = CONTROL_STATE; 
 788   1          /*赋值控件*/
 789   1          ControlType = CONTROL_BAUDSETTING; 
 790   1          LcdShow(RefreshBaudDisp);
 791   1      
 792   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Cancel\r\n");
              #endif
 795   1      }
 796          
 797          /*波特率控件状态--Menue*/
 798          void KeyBaud_Menu(void)
 799          {
 800   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Menu\r\n");
              #endif
 803   1      }
 804          
 805          /*一级菜单界面刷新显示*/
 806          void RefreshMenuDisp(void) 
 807          {
 808   1          uint8_t i = 0;
 809   1          clear_screen(); //清屏
 810   1      
 811   1          for (; i < 3; i++)
 812   1          {
 813   2              GUI_String(70, 20 * i + 5, Optionlist[M_Show[MAIN_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 814   2          }
 815   1      
 816   1          GUI_Lattice(50, 6 + M_Show[MAIN_MENU].Finger_Index * 20, 16, 12, finger);
 817   1      }
 818          
 819          /*菜单界面下二级菜单刷新显示*/
 820          void RefreshBaudDisp(void)
 821          {
 822   1          uint8_t i = 0;
 823   1          clear_screen(); //清屏
 824   1      
 825   1          for (; i < 3U; i++)
 826   1          {
 827   2              GUI_String(70, 20 * i + 5, Optionlist1[M_Show[SEC0_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 828   2          }
 829   1      
 830   1          GUI_Lattice(50, 6 + M_Show[SEC0_MENU].Finger_Index * 20, 16, 12, finger);
 831   1      }
 832          
 833          /**
 834           * @brief       波特率设置二级菜单
 835           * @details     
 836           * @param       None
 837           * @retval      None
 838           */
 839          void Baud_Setting(void)
 840          {
 841   1              /*刷新界面*/
 842   1              LcdShow(RefreshBaudDisp); 
 843   1              // /*切换到波特率设置界面*/
 844   1              // UI_STATE = BAUD_STATE;
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 17:42:56 PAGE 15  

 845   1              // /*无操作返回定时器开启*/
 846   1              // PublicTimer16.MenuDly16.Timer16Count = T_60S; 
 847   1      }
 848          
 849          
 850          void LcdDly(KEY_e key)
 851          { /*如果已经在密码输入界面*/
 852   1          if (UI_STATE == MAIN_STATE)
 853   1          { /*并且当前控件为屏保，不启用定时器*/
 854   2              if (ControlType == CONTROL_SCREENSAVE)
 855   2                  return;
 856   2          }
 857   1      
 858   1          if (key == NO_KEY)
 859   1          {
 860   2              if (PublicTimer16.MenuDly16.Timer16Flag)
 861   2              {
 862   3                  PublicTimer16.MenuDly16.Timer16Flag = false;
 863   3                  UI_STATE = MAIN_STATE;
 864   3                  ControlType = CONTROL_SCREENSAVE;
 865   3                  /*屏保界面界面*/
 866   3                  LcdShow(&ScreensaverUiShow);
 867   3                  PassWordDelete(&PassWordI);
 868   3              }
 869   2          }
 870   1          else
 871   1          {
 872   2              PublicTimer16.MenuDly16.Timer16Count = T_60S;
 873   2          }
 874   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2466    ----
   CONSTANT SIZE    =    154    ----
   XDATA SIZE       =    182      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
