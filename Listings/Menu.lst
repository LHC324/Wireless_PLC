C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Objects\Menu.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\Menu.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Include;.\FreeModB
                    -us\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\Menu.lst) OBJECT(.\Objects\Menu.obj)

line level    source

   1          #include "Menu.h"
   2          
   3          /*当前UI界面和显示控件*/
   4          Current_UI Ui_Status = {MAIN_STATE, CONTROL_SCREENSAVE};
   5          
   6          OPTION Optionlist[] =
   7              {
   8                  {"启停开关", CONTROL_PLCPOWER, PlcPowerUIshow},
   9                  {"通信方式", CONTROL_COMMUNICA, CommunicaUIshow},
  10                  {"密码修改", CONTROL_PASSWORD_CHANGE, PassWordChangeUIShow},
  11                  {"波特率设置", CONTROL_BAUDSETTING, Baud_Setting},
  12                  {"恢复出厂设置", CONTROL_RELOAD, ReloadSettingUIshow},
  13          };
  14          
  15          #define OptionlistSize (sizeof(Optionlist) / sizeof(OPTION))
  16          
  17          /*二级菜单*/
  18          OPTION Optionlist1[] =
  19              {
  20                  {"以太网", CONTROL_BAUD1, BaudSettingUI1show},
  21                  {"无线网", CONTROL_BAUD2, BaudSettingUI2show},
  22                  {"扩展网", CONTROL_BAUD3, BaudSettingUI3show},
  23                  {"内部网", CONTROL_BAUD4, BaudSettingUI4show}};
  24          
  25          #define OptionlistSize1 (sizeof(Optionlist1) / sizeof(OPTION))
  26          
  27          /*当前多级菜单数量*/
  28          Menu_Show M_Show[] =
  29              {
  30                  {0, 0, 0, {0, 1, 2}, Optionlist},
  31                  {0, 0, 0, {0, 1, 2}, Optionlist1}
  32          
  33          };
  34          
  35          #define MENU_NUM (sizeof(M_Show) / sizeof(Menu_Show))
  36          
  37          /*函数映射表*/
  38          const KEY_MAP keyStateEvent[] =
  39              {
  40                  /*Main状态*/
  41                  {KEY_UP, MAIN_STATE, KeyMain_Up},
  42                  {KEY_DOWN, MAIN_STATE, KeyMain_Down},
  43                  {KEY_ENTER, MAIN_STATE, KeyMain_Enter},
  44                  {KEY_CANCEL, MAIN_STATE, KeyMain_Cancel},
  45                  {KEY_MENU, MAIN_STATE, KeyMain_Menu},
  46                  /*Menu状态*/
  47                  {KEY_UP, MENU_STATE, KeyMenu_Up},
  48                  {KEY_DOWN, MENU_STATE, KeyMenu_Down},
  49                  {KEY_ENTER, MENU_STATE, KeyMenu_Enter},
  50                  {KEY_CANCEL, MENU_STATE, KeyMenu_Cancel},
  51                  {KEY_MENU, MENU_STATE, KeyMenu_Menu},
  52                  /*CONTROL状态*/
  53                  {KEY_UP, CONTROL_STATE, KeyControl_Up},
  54                  {KEY_DOWN, CONTROL_STATE, KeyControl_Down},
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 2   

  55                  {KEY_ENTER, CONTROL_STATE, KeyControl_Enter},
  56                  {KEY_CANCEL, CONTROL_STATE, KeyControl_Cancel},
  57                  {KEY_MENU, CONTROL_STATE, KeyControl_Menu},
  58                  /*BAUD状态*/
  59                  {KEY_UP, BAUD_STATE, KeyBaud_Up},
  60                  {KEY_DOWN, BAUD_STATE, KeyBaud_Down},
  61                  {KEY_ENTER, BAUD_STATE, KeyBaud_Enter},
  62                  {KEY_CANCEL, BAUD_STATE, KeyBaud_Cancel},
  63                  {KEY_MENU, BAUD_STATE, KeyBaud_Menu}};
  64          
  65          #define keyStateEventSize (sizeof(keyStateEvent) / sizeof(KEY_MAP))
  66          
  67          void KeyEvent(void) //按键事件
  68          {
  69   1          uint8_t i;
  70   1          KEY_e KeyState = Key_Chick(); //获取按键状态
  71   1      
  72   1          LcdDly(KeyState); // 无按键操作返回函数
  73   1      
  74   1          if (KeyState == NO_KEY) //无按键直接返回
  75   1          {
  76   2              return;
  77   2          }
  78   1      
  79   1          for (i = 0; i < keyStateEventSize; i++)
  80   1          {
  81   2              if (KeyState == keyStateEvent[i].Keycodel) //按键值
  82   2              {   /*按键状态*/
  83   3                  if (Ui_Status.Ui == keyStateEvent[i].Stage)
  84   3                  {
  85   4                      keyStateEvent[i].fun(); //执行按键状态对应函数
  86   4                      break;
  87   4                  }
  88   3              }
  89   2          }
  90   1      }
  91          
  92          void LcdShowInit(void) //界面显示初始化
  93          {
  94   1          LcdShow(&ScreensaverUiShow);
  95   1      }
  96          
  97          /*界面显示接口(回调函数思想)*/
  98          void LcdShow(pshow InterfaceShow) 
  99          {
 100   1          InterfaceShow();
 101   1      }
 102          
 103          /**
 104           * @brief       主界面状态--enter
 105           * @details     在主界面下按下enter按钮
 106           * @param       None
 107           * @retval      None
 108           */
 109          void KeyMain_Enter(void)
 110          {
 111   1      #if USE_PRINTF_DEBUG
                  uint8_t temp = strncmp(System_Parameter.PSWNext.PassWordbuff, "\xFF\xFF\xFF\xFF", PASSWORDBITS);
              #endif
 114   1          if (Ui_Status.Widget == CONTROL_PASSWORD)
 115   1          {
 116   2              /*没有设置过密码或者密码正确*/
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 3   

 117   2              if (PassWordjudge(PassWordI, System_Parameter) || (!strncmp(System_Parameter.PSWNext.PassWordbuff,
             - "\xFF\xFF\xFF\xFF", PASSWORDBITS)))
 118   2              {
 119   3                  LcdShow(RefreshMenuDisp); //刷新界面
 120   3                  Ui_Status.Ui = MENU_STATE;
 121   3                  // PublicTimer16.MenuDly16.Timer16Count = T_60S; //无操作返回定时器开启
 122   3              }
 123   2              else //如果密码错误
 124   2              {
 125   3                  PassWordDelete(&PassWordI);
 126   3                  clear_screen();
 127   3                  GUI_String(49, 31, "wrong password !", EN_5_8);
 128   3                  Delay_ms(1000);
 129   3                  // /*控件选项为屏保*/
 130   3                  // Ui_Status.Widget = CONTROL_SCREENSAVE;
 131   3                  LcdShow(PassWordInputUIShow); //重新输入
 132   3              }
 133   2          }
 134   1      
 135   1      #if USE_PRINTF_DEBUG
                  Uartx_SendStr(&Uart1, System_Parameter.PSWNext.PassWordbuff, 4);
                  Uartx_SendStr(&Uart1, &temp, 1);
                  printf("KeyMain_Enter\r\n");
              #endif
 140   1      }
 141          
 142          void KeyMain_Up(void) //主界面状态--Up
 143          {
 144   1          if (Ui_Status.Widget == CONTROL_PASSWORD) //密码控件
 145   1          {
 146   2              uint8_t Value = PassWordInput(ADD, &PassWordI);
 147   2              uint8_t temp[2] = {0}; //字符
 148   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 149   2          }
 150   1      
 151   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Up\r\n");
              #endif
 154   1      }
 155          /*屏保界面到密码输入界面切换*/
 156          void KeyMain_Menu(void) //主界面状态--Menu
 157          {
 158   1          switch (Ui_Status.Widget)
 159   1          {
 160   2          case CONTROL_SCREENSAVE:
 161   2          {
 162   3              /*切换到密码界面*/
 163   3              Ui_Status.Widget = CONTROL_PASSWORD;
 164   3              LcdShow(&PassWordInputUIShow);
 165   3              /*无操作返回定时器开启*/
 166   3              PublicTimer16.MenuDly16.Timer16Count = T_60S;
 167   3          }
 168   2          break;
 169   2          case CONTROL_PASSWORD:
 170   2          { /*改变当前密码输入位置*/
 171   3              InputOffect(&PassWordI);
 172   3          }
 173   2          break;
 174   2          default:
 175   2              break;
 176   2          }
 177   1      
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 4   

 178   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Menu\r\n");
              #endif
 181   1      }
 182          
 183          void KeyMain_Cancel(void) //主界面状态--Cancel
 184          {
 185   1          /*主界面按下取消键，退到屏保界面*/
 186   1          if (Ui_Status.Widget == CONTROL_PASSWORD)
 187   1          {
 188   2              LcdShow(&ScreensaverUiShow);
 189   2              Ui_Status.Widget = CONTROL_SCREENSAVE;
 190   2              PassWordDelete(&PassWordI);
 191   2          }
 192   1      
 193   1      #if USE_PRINTF_DEBUG
                  printf("%s\r\n", System_Parameter.PSWNext.PassWordbuff); //防止忘记密码之后进不去PLC
              #endif
 196   1      }
 197          
 198          void KeyMain_Down(void) //主界面状态--Down
 199          {
 200   1          if (Ui_Status.Widget == CONTROL_PASSWORD)
 201   1          {
 202   2              uint8_t Value = PassWordInput(SUB, &PassWordI);
 203   2              uint8_t temp[2] = {0}; //字符
 204   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 205   2          }
 206   1      
 207   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Down\r\n");
              #endif
 210   1      }
 211          
 212          void KeyMenu_Enter(void) //菜单状态--Enter
 213          {
 214   1          if (M_Show[MAIN_MENU].OptionNow->ControlShow == NULL)
 215   1          {
 216   2              return;
 217   2          }
 218   1      
 219   1          Ui_Status.Ui = CONTROL_STATE;
 220   1          Ui_Status.Widget = M_Show[MAIN_MENU].OptionNow->ControlType; //赋值控件
 221   1          LcdShow(M_Show[MAIN_MENU].OptionNow->ControlShow);      //显示控制界面
 222   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Enter\r\n");
              #endif
 225   1      }
 226          
 227          /*菜单状态--Up*/
 228          void KeyMenu_Up(void)
 229          {
 230   1          /*箭头索引减小*/
 231   1          if ((M_Show[MAIN_MENU].Finger_Index--) == 0)
 232   1              M_Show[MAIN_MENU].Finger_Index = 0;
 233   1      
 234   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(UPWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize);
 235   1      
 236   1          if (M_Show[MAIN_MENU].Option_Index == (OptionlistSize - 1)) //索引逻辑
 237   1          {
 238   2              M_Show[MAIN_MENU].Finger_Index = 2;
 239   2          }
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 5   

 240   1          /*菜单滑动逻辑*/
 241   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
 242   1          {
 243   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
 244   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 245   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 246   2          }
 247   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 248   1          {
 249   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 250   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 251   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 252   2          }
 253   1          else
 254   1          {
 255   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 256   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 257   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 258   2          }
 259   1      
 260   1          LcdShow(RefreshMenuDisp);                                                  //刷新显示
 261   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 262   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Up\r\n");
              #endif
 265   1      }
 266          
 267          /*菜单状态--Menu*/
 268          void KeyMenu_Menu(void)
 269          {
 270   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Menu\r\n");
              #endif
 273   1      }
 274          
 275          void KeyMenu_Cancel(void) //菜单状态--Cancel
 276          {
 277   1          /*菜单界面按下取消键，直接锁屏*/
 278   1          Ui_Status.Ui = MAIN_STATE;
 279   1          Ui_Status.Widget = CONTROL_SCREENSAVE;
 280   1          LcdShow(&ScreensaverUiShow);
 281   1          PassWordDelete(&PassWordI);
 282   1      
 283   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Cancel\r\n");
              #endif
 286   1      }
 287          
 288          void KeyMenu_Down(void) //菜单状态--Down
 289          {
 290   1          if ((M_Show[MAIN_MENU].Finger_Index++) == 2) //箭头索引增加
 291   1              M_Show[MAIN_MENU].Finger_Index = 2;
 292   1      
 293   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize); 
             -//选项索引
 294   1      
 295   1          if (M_Show[MAIN_MENU].Option_Index == 0) //索引逻辑
 296   1          {
 297   2              M_Show[MAIN_MENU].Finger_Index = 0;
 298   2          }
 299   1      
 300   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 6   

 301   1          {
 302   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
 303   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 304   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 305   2          }
 306   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 307   1          {
 308   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 309   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 310   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 311   2          }
 312   1          else
 313   1          {
 314   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 315   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 316   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 317   2          }
 318   1      
 319   1          LcdShow(RefreshMenuDisp);                                                  //刷新显示
 320   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 321   1      
 322   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Down\r\n");
              #endif
 325   1      }
 326          
 327          /**
 328           * @brief       检查密码输入位数是否达标
 329           * @details     
 330           * @param       counts 当前密码输入次数
 331           * @return      true/false
 332           */
 333          uint8_t Check_PasswordBits(void)
 334          {
 335   1          /*密码位数不够，禁止修改*/
 336   1          if (!System_Parameter.PSWNext.Bit_Efficient_Flag)
 337   1          {
 338   2              clear_screen();
 339   2              if(!System_Parameter.PSWNext.First_Input_Flag)
 340   2              {
 341   3                  GUI_String(5, 20, "Invalid password!", EN_5_8);
 342   3                  GUI_String(5, 32, "Current counts is 1.", EN_5_8);
 343   3                  /*修改密码1清空 */
 344   3                  PassWordDelete(&PassWordChange1);
 345   3              }
 346   2              else
 347   2              {
 348   3                  GUI_String(5, 20, "Invalid password!", EN_5_8);
 349   3                  GUI_String(5, 32, "Current counts is 2.", EN_5_8);
 350   3                  /*修改密码2清空 */
 351   3                  PassWordDelete(&PassWordChange2);
 352   3              }
 353   2              Delay_ms(1000);
 354   2              /*显示修改密码界面*/
 355   2              LcdShow(PassWordChangeUIShow);
 356   2         
 357   2              return false;
 358   2          }
 359   1          return true;
 360   1      }
 361          
 362          void KeyControl_Enter(void) //控件状态--Enter
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 7   

 363          {
 364   1          switch (Ui_Status.Widget)
 365   1          {
 366   2          case CONTROL_PASSWORD_CHANGE:
 367   2          {
 368   3              if (!Check_PasswordBits())
 369   3                  return;
 370   3              /*如果是第一次输入修改密码*/
 371   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 372   3              {
 373   4                  uint8_t i;
 374   4                  uint8_t temp[2];
 375   4      
 376   4                  for (i = 0; i < PASSWORDBITS; i++) //显示4位密码
 377   4                  {
 378   5                      GUI_String(i * 20 + 100, 18, myitoa(PassWordChange1.PSWNext.PassWordbuff[i], temp, 10), EN
             -_5_8);
 379   5                  }
 380   4      
 381   4                  GUI_Lattice(175, 16, 16, 12, dot);
 382   4                  /*置标志位*/
 383   4                  System_Parameter.PSWNext.First_Input_Flag = true;
 384   4              }
 385   3              else
 386   3              {
 387   4                  if (PassWordjudge(PassWordChange1, PassWordChange2)) //密码判断两次输入相同密码时修改成功
 388   4                  {
 389   5                      memcpy(&System_Parameter.PSWNext.PassWordbuff, &PassWordChange2.PSWNext.PassWordbuff, size
             -of(PassWordChange2.PSWNext.PassWordbuff));
 390   5                      ControlSave();
 391   5                      PassWordDelete(&PassWordChange1); //修改密码1清0
 392   5                      PassWordDelete(&PassWordChange2); //修改密码2清0
 393   5                      /*返回菜单界面*/
 394   5                      Ui_Status.Ui = MENU_STATE;
 395   5      
 396   5                      clear_screen();
 397   5                      GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 398   5                      Delay_ms(500);
 399   5                      LcdShow(RefreshMenuDisp); //刷新显示
 400   5                  }
 401   4                  else //两次密码输入不一致时
 402   4                  {
 403   5      
 404   5                      clear_screen();
 405   5                      GUI_String(70, 22, "修改失败", CH_12_12); //显示修改结果
 406   5                      Delay_ms(500);
 407   5                      LcdShow(PassWordChangeUIShow); //修改密码
 408   5                  }
 409   4                  /*置标志位*/
 410   4                  System_Parameter.PSWNext.First_Input_Flag = false;
 411   4              }
 412   3              /*清除密码有效标志*/
 413   3              System_Parameter.PSWNext.Bit_Efficient_Flag = false;
 414   3              break;
 415   3          }
 416   2      
 417   2          case CONTROL_PLCPOWER:
 418   2          {
 419   3              System_Parameter.PlcState ^= 1;
 420   3              RUNKEY = System_Parameter.PlcState;
 421   3              ControlSave();           //存盘开关量
 422   3              LcdShow(PlcPowerUIshow); // PLC设置界面
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 8   

 423   3              break;
 424   3          }
 425   2      
 426   2          case CONTROL_COMMUNICA:
 427   2          {
 428   3              if (System_Parameter.CommunicationType == LOCAL)
 429   3              {
 430   4                  Wifi_Enable(false);
 431   4              }
 432   3              else
 433   3              {
 434   4                  Wifi_Enable(true);
 435   4                  clear_screen();
 436   4                  GUI_String(30, 22, "Please wait a moment", EN_5_8);
 437   4                  Delay_ms(500);
 438   4                  // /*初始化WIIF模块*/
 439   4                  // Wifi_Init();
 440   4              }
 441   3              ControlSave(); //存盘通信方式
 442   3      
 443   3              clear_screen();
 444   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 445   3              Delay_ms(500);
 446   3              // LcdShow(CommunicaUIshow); //通讯设置界面
 447   3              /*返回菜单界面*/
 448   3              Ui_Status.Ui = MENU_STATE;
 449   3              LcdShow(RefreshMenuDisp); //刷新显示
 450   3              break;
 451   3          }
 452   2      
 453   2          case CONTROL_BAUDSETTING:
 454   2          {
 455   3              if (M_Show[SEC0_MENU].OptionNow->ControlShow == NULL)
 456   3              {
 457   4                  return;
 458   4              }
 459   3              /*切换到波特率设置界面*/
 460   3              Ui_Status.Ui = BAUD_STATE;
 461   3              /*赋值控件*/
 462   3              Ui_Status.Widget = M_Show[SEC0_MENU].OptionNow->ControlType;
 463   3              /*显示控制界面*/
 464   3              LcdShow(M_Show[SEC0_MENU].OptionNow->ControlShow);
 465   3              /*无操作返回定时器开启*/
 466   3              // PublicTimer16.MenuDly16.Timer16Count = T_60S;
 467   3          }
 468   2          break;
 469   2          /*恢复出厂设置*/
 470   2          case CONTROL_RELOAD:
 471   2          {
 472   3              CLOSE_GLOBAL_OUTAGE();
 473   3              IapErase(START_SAVEADDRESS); //擦除密码区
 474   3                                           /*把默认参数拷贝到当前数据结构*/
 475   3              memcpy(&System_Parameter.PSWNext.PassWordbuff[0], DEFAULT_SYSTEM_PARAMETER, (sizeof(System_Paramet
             -er) - 1U));
 476   3              /*把数据进行存储*/
 477   3              IapWrite_Buff(START_SAVEADDRESS, &System_Parameter.PSWNext.PassWordbuff[0], (sizeof(System_Paramet
             -er) - 1U)); //使密码界面失效
 478   3              OPEN_GLOBAL_OUTAGE();
 479   3      
 480   3              BaudInit();
 481   3              PowerInit();
 482   3              CommunicaInit();
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 9   

 483   3      
 484   3              clear_screen();
 485   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 486   3              Delay_ms(500);
 487   3              /*返回菜单界面*/
 488   3              Ui_Status.Ui = MENU_STATE;
 489   3              LcdShow(RefreshMenuDisp); //刷新显示
 490   3              break;
 491   3          }
 492   2      
 493   2          default:
 494   2              break;
 495   2          }
 496   1      
 497   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Enter\r\n");
              #endif
 500   1      }
 501          
 502          void KeyControl_Menu(void) //控件状态--Menu
 503          {
 504   1          switch (Ui_Status.Widget)
 505   1          {
 506   2          case CONTROL_PASSWORD_CHANGE:
 507   2          {
 508   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 509   3              {
 510   4      
 511   4                  InputOffect(&PassWordChange1);
 512   4              }
 513   3              else
 514   3              {
 515   4      
 516   4                  InputOffect(&PassWordChange2);
 517   4              }
 518   3      
 519   3              break;
 520   3          }
 521   2      
 522   2          default:
 523   2              break;
 524   2          }
 525   1      
 526   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Menu\r\n");
              #endif
 529   1      }
 530          
 531          void KeyControl_Cancel(void) //控件状态--Cancel
 532          {
 533   1          switch (Ui_Status.Widget)
 534   1          {
 535   2          case CONTROL_PASSWORD_CHANGE:
 536   2          {
 537   3              PassWordDelete(&PassWordChange1); //清0数据
 538   3                  PassWordDelete(&PassWordChange2);
 539   3              System_Parameter.PSWNext.First_Input_Flag = false;
 540   3              System_Parameter.PSWNext.Bit_Efficient_Flag = false;
 541   3              break;
 542   3          }
 543   2      
 544   2          case CONTROL_COMMUNICA:
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 10  

 545   2          {
 546   3              // CommunciaIndex = CommunciaType; //如果没有确定,直接返回，则恢复当前状态索引
 547   3              break;
 548   3          }
 549   2      
 550   2          case CONTROL_BAUDSETTING:
 551   2          {
 552   3              // BaudWillIndex = BaudIndex; //如果没有确定,直接返回，则恢复当前状态索引
 553   3              break;
 554   3          }
 555   2      
 556   2          case CONTROL_RELOAD:
 557   2          {
 558   3              break;
 559   3          }
 560   2      
 561   2          default:
 562   2              break;
 563   2          }
 564   1      
 565   1          /*返回菜单界面*/
 566   1          Ui_Status.Ui = MENU_STATE;
 567   1          LcdShow(RefreshMenuDisp); //显示设置
 568   1      
 569   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Cancel\r\n");
              #endif
 572   1      }
 573          
 574          /*控件状态--Up*/
 575          void KeyControl_Up(void)
 576          {
 577   1          switch (Ui_Status.Widget)
 578   1          {
 579   2          case CONTROL_PASSWORD_CHANGE:
 580   2          {
 581   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 582   3              {
 583   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange1);
 584   4                  uint8_t temp[2] = {0}; //字符
 585   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
 586   4              }
 587   3              else
 588   3              {
 589   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange2);
 590   4                  uint8_t temp[2] = {0}; //字符
 591   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 592   4              }
 593   3          }
 594   2          break;
 595   2      
 596   2          case CONTROL_COMMUNICA:
 597   2          {
 598   3              System_Parameter.CommunicationType ^= 1;
 599   3              LcdShow(CommunicaUIshow); //通讯设置界面
 600   3          }
 601   2          break;
 602   2      
 603   2          case CONTROL_BAUDSETTING:
 604   2          {
 605   3              /*箭头索引减小*/
 606   3              if ((M_Show[SEC0_MENU].Finger_Index--) == 0)
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 11  

 607   3                  M_Show[SEC0_MENU].Finger_Index = 0;
 608   3      
 609   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(UPWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSize1
             -);
 610   3      
 611   3              if (M_Show[SEC0_MENU].Option_Index == (OptionlistSize1 - 1)) //索引逻辑
 612   3              {
 613   4                  M_Show[SEC0_MENU].Finger_Index = 2;
 614   4              }
 615   3              /*菜单滑动逻辑*/
 616   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 617   3              {
 618   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 619   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 620   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 621   4              }
 622   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 623   3              {
 624   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 625   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 626   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
 627   4              }
 628   3              else
 629   3              {
 630   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 631   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
 632   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
 633   4              }
 634   3      
 635   3              LcdShow(RefreshBaudDisp);                                                   //刷新显示
 636   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 637   3          }
 638   2          break;
 639   2      
 640   2          default:
 641   2              break;
 642   2          }
 643   1      
 644   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Up\r\n");
              #endif
 647   1      }
 648          
 649          void KeyControl_Down(void) //控件状态--Down
 650          {
 651   1          switch (Ui_Status.Widget)
 652   1          {
 653   2          case CONTROL_PASSWORD_CHANGE:
 654   2          {
 655   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 656   3              {
 657   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange1);
 658   4                  uint8_t temp[2] = {0}; //字符
 659   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
 660   4              }
 661   3              else
 662   3              {
 663   4      
 664   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange2);
 665   4                  uint8_t temp[2]= {0}; //字符
 666   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 667   4              }
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 12  

 668   3          }
 669   2          break;
 670   2      
 671   2          case CONTROL_COMMUNICA:
 672   2          {
 673   3              System_Parameter.CommunicationType ^= 1;
 674   3              LcdShow(CommunicaUIshow); //通讯设置界面
 675   3          }
 676   2          break;
 677   2      
 678   2          case CONTROL_BAUDSETTING:
 679   2          {
 680   3              if ((M_Show[SEC0_MENU].Finger_Index++) >= 2) //箭头索引增加
 681   3                  M_Show[SEC0_MENU].Finger_Index = 2;
 682   3      
 683   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSiz
             -e1); //选项索引
 684   3      
 685   3              if (M_Show[SEC0_MENU].Option_Index == 0) //索引逻辑
 686   3              {
 687   4                  M_Show[SEC0_MENU].Finger_Index = 0;
 688   4              }
 689   3      
 690   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 691   3              {
 692   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 693   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 694   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 695   4              }
 696   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 697   3              {
 698   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 699   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 700   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
 701   4              }
 702   3              else
 703   3              {
 704   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 705   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
 706   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
 707   4              }
 708   3              /*刷新当前选项卡*/
 709   3              LcdShow(RefreshBaudDisp);
 710   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 711   3          }
 712   2          break;
 713   2      
 714   2          default:
 715   2              break;
 716   2          }
 717   1      
 718   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Down\r\n");
              #endif
 721   1      }
 722          
 723          /*波特率控件状态--up*/
 724          void KeyBaud_Up(void)
 725          {
 726   1          switch (Ui_Status.Widget)
 727   1          {
 728   2          case CONTROL_BAUD1:
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 13  

 729   2          {
 730   3              System_Parameter.BaudIndex[0] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[0], G_BaudList_Size
             -);
 731   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 732   3          }
 733   2          break;
 734   2          case CONTROL_BAUD2:
 735   2          {
 736   3              System_Parameter.BaudIndex[1] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[1], G_BaudList_Size
             -);
 737   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 738   3          }
 739   2          break;
 740   2          case CONTROL_BAUD3:
 741   2          {
 742   3              System_Parameter.BaudIndex[2] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[2], G_BaudList_Size
             -);
 743   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 744   3          }
 745   2          break;
 746   2          case CONTROL_BAUD4:
 747   2          {
 748   3              System_Parameter.BaudIndex[3] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[3], G_BaudList_Size
             -);
 749   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
 750   3          }
 751   2          break;
 752   2          default:
 753   2              break;
 754   2          }
 755   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Up\r\n");
              #endif
 758   1      }
 759          
 760          /*波特率控件状态--Down*/
 761          void KeyBaud_Down(void)
 762          {
 763   1          switch (Ui_Status.Widget)
 764   1          {
 765   2          case CONTROL_BAUD1:
 766   2          {
 767   3              System_Parameter.BaudIndex[0] = LoopIndex(UPWORD, System_Parameter.BaudIndex[0], G_BaudList_Size);
 768   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 769   3          }
 770   2          break;
 771   2          case CONTROL_BAUD2:
 772   2          {
 773   3              System_Parameter.BaudIndex[1] = LoopIndex(UPWORD, System_Parameter.BaudIndex[1], G_BaudList_Size);
 774   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 775   3          }
 776   2          break;
 777   2          case CONTROL_BAUD3:
 778   2          {
 779   3              System_Parameter.BaudIndex[2] = LoopIndex(UPWORD, System_Parameter.BaudIndex[2], G_BaudList_Size);
 780   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 781   3          }
 782   2          break;
 783   2          case CONTROL_BAUD4:
 784   2          {
 785   3              System_Parameter.BaudIndex[3] = LoopIndex(UPWORD, System_Parameter.BaudIndex[3], G_BaudList_Size);
 786   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 14  

 787   3          }
 788   2          break;
 789   2          default:
 790   2              break;
 791   2          }
 792   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Down\r\n");
              #endif
 795   1      }
 796          
 797          /*波特率控件状态--Enter*/
 798          void KeyBaud_Enter(void)
 799          {
 800   1          switch (Ui_Status.Widget)
 801   1          {
 802   2          case CONTROL_BAUD1:
 803   2          {
 804   3              SET_BRT1(1, Baudlist[System_Parameter.BaudIndex[0]].BaudValue);
 805   3              ControlSave();
 806   3      
 807   3              clear_screen();
 808   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 809   3              Delay_ms(500);
 810   3              /*修改成功后返回*/
 811   3              KeyBaud_Cancel();
 812   3          }
 813   2          break;
 814   2          case CONTROL_BAUD2:
 815   2          {
 816   3              SET_BRT1(2, Baudlist[System_Parameter.BaudIndex[1]].BaudValue);
 817   3              ControlSave();
 818   3      
 819   3              clear_screen();
 820   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 821   3              Delay_ms(500);
 822   3              /*修改成功后返回*/
 823   3              KeyBaud_Cancel();
 824   3          }
 825   2          break;
 826   2          case CONTROL_BAUD3:
 827   2          {
 828   3              SET_BRT1(3, Baudlist[System_Parameter.BaudIndex[2]].BaudValue);
 829   3              ControlSave();
 830   3      
 831   3              clear_screen();
 832   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 833   3              Delay_ms(500);
 834   3              /*修改成功后返回*/
 835   3              KeyBaud_Cancel();
 836   3          }
 837   2          break;
 838   2          case CONTROL_BAUD4:
 839   2          {
 840   3              SET_BRT1(4, Baudlist[System_Parameter.BaudIndex[3]].BaudValue);
 841   3              ControlSave();
 842   3      
 843   3              clear_screen();
 844   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 845   3              Delay_ms(500);
 846   3              // LcdShow(BaudSettingUI4show); //波特率设置界面
 847   3              /*修改成功后返回*/
 848   3              KeyBaud_Cancel();
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 15  

 849   3          }
 850   2          break;
 851   2          default:
 852   2              break;
 853   2          }
 854   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Enter\r\n");
              #endif
 857   1      }
 858          
 859          /*波特率控件状态--Cancel*/
 860          void KeyBaud_Cancel(void)
 861          { /*返回上级菜单界面*/
 862   1          Ui_Status.Ui = CONTROL_STATE;
 863   1          /*赋值控件*/
 864   1          Ui_Status.Widget = CONTROL_BAUDSETTING;
 865   1          LcdShow(RefreshBaudDisp);
 866   1      
 867   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Cancel\r\n");
              #endif
 870   1      }
 871          
 872          /*波特率控件状态--Menue*/
 873          void KeyBaud_Menu(void)
 874          {
 875   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Menu\r\n");
              #endif
 878   1      }
 879          
 880          /*一级菜单界面刷新显示*/
 881          void RefreshMenuDisp(void)
 882          {
 883   1          uint8_t i = 0;
 884   1          clear_screen(); //清屏
 885   1      
 886   1          for (; i < 3; i++)
 887   1          {
 888   2              GUI_String(70, 20 * i + 5, Optionlist[M_Show[MAIN_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 889   2          }
 890   1      
 891   1          GUI_Lattice(50, 6 + M_Show[MAIN_MENU].Finger_Index * 20, 16, 12, finger);
 892   1      }
 893          
 894          /*菜单界面下二级菜单刷新显示*/
 895          void RefreshBaudDisp(void)
 896          {
 897   1          uint8_t i = 0;
 898   1          clear_screen(); //清屏
 899   1      
 900   1          for (; i < 3U; i++)
 901   1          {
 902   2              GUI_String(70, 20 * i + 5, Optionlist1[M_Show[SEC0_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 903   2          }
 904   1      
 905   1          GUI_Lattice(50, 6 + M_Show[SEC0_MENU].Finger_Index * 20, 16, 12, finger);
 906   1      }
 907          
 908          /**
 909           * @brief       波特率设置二级菜单
 910           * @details
C51 COMPILER V9.60.0.0   MENU                                                              10/28/2021 15:29:44 PAGE 16  

 911           * @param       None
 912           * @retval      None
 913           */
 914          void Baud_Setting(void)
 915          {
 916   1          /*刷新界面*/
 917   1          LcdShow(RefreshBaudDisp);
 918   1          // /*切换到波特率设置界面*/
 919   1          // UI_STATE = BAUD_STATE;
 920   1          // /*无操作返回定时器开启*/
 921   1          // PublicTimer16.MenuDly16.Timer16Count = T_60S;
 922   1      }
 923          
 924          void LcdDly(KEY_e key)
 925          { /*如果已经在密码输入界面*/
 926   1          if (Ui_Status.Ui == MAIN_STATE)
 927   1          { /*并且当前控件为屏保，不启用定时器*/
 928   2              if (Ui_Status.Widget == CONTROL_SCREENSAVE)
 929   2                  return;
 930   2          }
 931   1      
 932   1          if (key == NO_KEY)
 933   1          {
 934   2              if (PublicTimer16.MenuDly16.Timer16Flag)
 935   2              {
 936   3                  PublicTimer16.MenuDly16.Timer16Flag = false;
 937   3                  Ui_Status.Ui = MAIN_STATE;
 938   3                  Ui_Status.Widget = CONTROL_SCREENSAVE;
 939   3                  /*屏保界面界面*/
 940   3                  LcdShow(&ScreensaverUiShow);
 941   3                  PassWordDelete(&PassWordI);
 942   3              }
 943   2          }
 944   1          else
 945   1          {
 946   2              PublicTimer16.MenuDly16.Timer16Count = T_60S;
 947   2          }
 948   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2675    ----
   CONSTANT SIZE    =    226    ----
   XDATA SIZE       =    183      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
