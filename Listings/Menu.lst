C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Objects\Menu.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\Menu.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeModBu
                    -s\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\Menu.lst) OBJECT(.\Objects\Menu.obj)

line level    source

   1          #include "Menu.h"
   2          
   3          /*当前UI界面和显示控件*/
   4          Current_UI Ui_Status = {MAIN_STATE, CONTROL_SCREENSAVE};
   5          
   6          OPTION Optionlist[] =
   7              {
   8                  {"启停开关", CONTROL_PLCPOWER, PlcPowerUIshow},
   9                  {"通信方式", CONTROL_COMMUNICA, CommunicaUIshow},
  10                  {"密码修改", CONTROL_PASSWORD_CHANGE, PassWordChangeUIShow},
  11                  {"波特率设置", CONTROL_BAUDSETTING, Baud_Setting},
  12                  {"本机热点", CONTROL_HOTSPOT, HotspotSettingUIshow},
  13                  {"恢复出厂设置", CONTROL_RELOAD, ReloadSettingUIshow},
  14          };
  15          
  16          #define OptionlistSize (sizeof(Optionlist) / sizeof(OPTION))
  17          
  18          /*二级菜单*/
  19          OPTION Optionlist1[] =
  20              {
  21                  {"以太网", CONTROL_BAUD1, BaudSettingUI1show},
  22                  {"无线网", CONTROL_BAUD2, BaudSettingUI2show},
  23                  {"扩展网", CONTROL_BAUD3, BaudSettingUI3show},
  24                  {"内部网", CONTROL_BAUD4, BaudSettingUI4show}};
  25          
  26          #define OptionlistSize1 (sizeof(Optionlist1) / sizeof(OPTION))
  27          
  28          /*当前多级菜单数量*/
  29          Menu_Show M_Show[] =
  30              {
  31                  {0, 0, 0, {0, 1, 2}, Optionlist},
  32                  {0, 0, 0, {0, 1, 2}, Optionlist1}
  33          
  34          };
  35          
  36          #define MENU_NUM (sizeof(M_Show) / sizeof(Menu_Show))
  37          
  38          /*函数映射表*/
  39          const KEY_MAP keyStateEvent[] =
  40              {
  41                  /*Main状态*/
  42                  {KEY_UP, MAIN_STATE, KeyMain_Up},
  43                  {KEY_DOWN, MAIN_STATE, KeyMain_Down},
  44                  {KEY_ENTER, MAIN_STATE, KeyMain_Enter},
  45                  {KEY_CANCEL, MAIN_STATE, KeyMain_Cancel},
  46                  {KEY_MENU, MAIN_STATE, KeyMain_Menu},
  47                  /*Menu状态*/
  48                  {KEY_UP, MENU_STATE, KeyMenu_Up},
  49                  {KEY_DOWN, MENU_STATE, KeyMenu_Down},
  50                  {KEY_ENTER, MENU_STATE, KeyMenu_Enter},
  51                  {KEY_CANCEL, MENU_STATE, KeyMenu_Cancel},
  52                  {KEY_MENU, MENU_STATE, KeyMenu_Menu},
  53                  /*CONTROL状态*/
  54                  {KEY_UP, CONTROL_STATE, KeyControl_Up},
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 2   

  55                  {KEY_DOWN, CONTROL_STATE, KeyControl_Down},
  56                  {KEY_ENTER, CONTROL_STATE, KeyControl_Enter},
  57                  {KEY_CANCEL, CONTROL_STATE, KeyControl_Cancel},
  58                  {KEY_MENU, CONTROL_STATE, KeyControl_Menu},
  59                  /*BAUD状态*/
  60                  {KEY_UP, BAUD_STATE, KeyBaud_Up},
  61                  {KEY_DOWN, BAUD_STATE, KeyBaud_Down},
  62                  {KEY_ENTER, BAUD_STATE, KeyBaud_Enter},
  63                  {KEY_CANCEL, BAUD_STATE, KeyBaud_Cancel},
  64                  {KEY_MENU, BAUD_STATE, KeyBaud_Menu}};
  65          
  66          #define keyStateEventSize (sizeof(keyStateEvent) / sizeof(KEY_MAP))
  67          
  68          void KeyEvent(void) //按键事件
  69          {
  70   1          uint8_t i;
  71   1          KEY_e KeyState = Key_Chick(); //获取按键状态
  72   1      
  73   1          LcdDly(KeyState); // 无按键操作返回函数
  74   1      
  75   1          if (KeyState == NO_KEY) //无按键直接返回
  76   1          {
  77   2              return;
  78   2          }
  79   1      
  80   1          for (i = 0; i < keyStateEventSize; i++)
  81   1          {
  82   2              if (KeyState == keyStateEvent[i].Keycodel) //按键值
  83   2              {   /*按键状态*/
  84   3                  if (Ui_Status.Ui == keyStateEvent[i].Stage)
  85   3                  {
  86   4                      keyStateEvent[i].fun(); //执行按键状态对应函数
  87   4                      break;
  88   4                  }
  89   3              }
  90   2          }
  91   1      }
  92          
  93          void LcdShowInit(void) //界面显示初始化
  94          {
  95   1          LcdShow(&ScreensaverUiShow);
  96   1      }
  97          
  98          /*界面显示接口(回调函数思想)*/
  99          void LcdShow(pshow InterfaceShow) 
 100          {
 101   1          InterfaceShow();
 102   1      }
 103          
 104          /**
 105           * @brief       主界面状态--enter
 106           * @details     在主界面下按下enter按钮
 107           * @param       None
 108           * @retval      None
 109           */
 110          void KeyMain_Enter(void)
 111          {
 112   1      #if USE_PRINTF_DEBUG
                  uint8_t temp = strncmp(System_Parameter.PSWNext.PassWordbuff, "\xFF\xFF\xFF\xFF", PASSWORDBITS);
              #endif
 115   1          if (Ui_Status.Widget == CONTROL_PASSWORD)
 116   1          {
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 3   

 117   2              /*没有设置过密码或者密码正确*/
 118   2              if (PassWordjudge(PassWordI, System_Parameter) || (!strncmp(System_Parameter.PSWNext.PassWordbuff,
             - "\xFF\xFF\xFF\xFF", PASSWORDBITS)))
 119   2              {
 120   3                  LcdShow(RefreshMenuDisp); //刷新界面
 121   3                  Ui_Status.Ui = MENU_STATE;
 122   3                  // PublicTimer16.MenuDly16.Timer16Count = T_60S; //无操作返回定时器开启
 123   3              }
 124   2              else //如果密码错误
 125   2              {
 126   3                  PassWordDelete(&PassWordI);
 127   3                  clear_screen();
 128   3                  GUI_String(49, 31, "wrong password !", EN_5_8);
 129   3                  Delay_ms(1000);
 130   3                  // /*控件选项为屏保*/
 131   3                  // Ui_Status.Widget = CONTROL_SCREENSAVE;
 132   3                  LcdShow(PassWordInputUIShow); //重新输入
 133   3              }
 134   2          }
 135   1      
 136   1      #if USE_PRINTF_DEBUG
                  Uartx_SendStr(&Uart1, System_Parameter.PSWNext.PassWordbuff, 4);
                  Uartx_SendStr(&Uart1, &temp, 1);
                  printf("KeyMain_Enter\r\n");
              #endif
 141   1      }
 142          
 143          void KeyMain_Up(void) //主界面状态--Up
 144          {
 145   1          if (Ui_Status.Widget == CONTROL_PASSWORD) //密码控件
 146   1          {
 147   2              uint8_t Value = PassWordInput(ADD, &PassWordI);
 148   2              uint8_t temp[2] = {0}; //字符
 149   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 150   2          }
 151   1      
 152   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Up\r\n");
              #endif
 155   1      }
 156          /*屏保界面到密码输入界面切换*/
 157          void KeyMain_Menu(void) //主界面状态--Menu
 158          {
 159   1          switch (Ui_Status.Widget)
 160   1          {
 161   2          case CONTROL_SCREENSAVE:
 162   2          {
 163   3              /*切换到密码界面*/
 164   3              Ui_Status.Widget = CONTROL_PASSWORD;
 165   3              LcdShow(&PassWordInputUIShow);
 166   3              /*无操作返回定时器开启*/
 167   3              PublicTimer16.MenuDly16.Timer16Count = T_60S;
 168   3          }
 169   2          break;
 170   2          case CONTROL_PASSWORD:
 171   2          { /*改变当前密码输入位置*/
 172   3              InputOffect(&PassWordI);
 173   3          }
 174   2          break;
 175   2          default:
 176   2              break;
 177   2          }
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 4   

 178   1      
 179   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Menu\r\n");
              #endif
 182   1      }
 183          
 184          void KeyMain_Cancel(void) //主界面状态--Cancel
 185          {
 186   1          /*主界面按下取消键，退到屏保界面*/
 187   1          if (Ui_Status.Widget == CONTROL_PASSWORD)
 188   1          {
 189   2              LcdShow(&ScreensaverUiShow);
 190   2              Ui_Status.Widget = CONTROL_SCREENSAVE;
 191   2              PassWordDelete(&PassWordI);
 192   2          }
 193   1      
 194   1      #if USE_PRINTF_DEBUG
                  printf("%s\r\n", System_Parameter.PSWNext.PassWordbuff); //防止忘记密码之后进不去PLC
              #endif
 197   1      }
 198          
 199          void KeyMain_Down(void) //主界面状态--Down
 200          {
 201   1          if (Ui_Status.Widget == CONTROL_PASSWORD)
 202   1          {
 203   2              uint8_t Value = PassWordInput(SUB, &PassWordI);
 204   2              uint8_t temp[2] = {0}; //字符
 205   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 206   2          }
 207   1      
 208   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Down\r\n");
              #endif
 211   1      }
 212          
 213          void KeyMenu_Enter(void) //菜单状态--Enter
 214          {
 215   1          if (M_Show[MAIN_MENU].OptionNow->ControlShow == NULL)
 216   1          {
 217   2              return;
 218   2          }
 219   1      
 220   1          Ui_Status.Ui = CONTROL_STATE;
 221   1          Ui_Status.Widget = M_Show[MAIN_MENU].OptionNow->ControlType; //赋值控件
 222   1          LcdShow(M_Show[MAIN_MENU].OptionNow->ControlShow);      //显示控制界面
 223   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Enter\r\n");
              #endif
 226   1      }
 227          
 228          /*菜单状态--Up*/
 229          void KeyMenu_Up(void)
 230          {
 231   1          /*箭头索引减小*/
 232   1          if ((M_Show[MAIN_MENU].Finger_Index--) == 0)
 233   1              M_Show[MAIN_MENU].Finger_Index = 0;
 234   1      
 235   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(UPWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize);
 236   1      
 237   1          if (M_Show[MAIN_MENU].Option_Index == (OptionlistSize - 1)) //索引逻辑
 238   1          {
 239   2              M_Show[MAIN_MENU].Finger_Index = 2;
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 5   

 240   2          }
 241   1          /*菜单滑动逻辑*/
 242   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
 243   1          {
 244   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
 245   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 246   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 247   2          }
 248   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 249   1          {
 250   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 251   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 252   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 253   2          }
 254   1          else
 255   1          {
 256   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 257   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 258   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 259   2          }
 260   1      
 261   1          LcdShow(RefreshMenuDisp);                                                  //刷新显示
 262   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 263   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Up\r\n");
              #endif
 266   1      }
 267          
 268          /*菜单状态--Menu*/
 269          void KeyMenu_Menu(void)
 270          {
 271   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Menu\r\n");
              #endif
 274   1      }
 275          
 276          void KeyMenu_Cancel(void) //菜单状态--Cancel
 277          {
 278   1          /*菜单界面按下取消键，直接锁屏*/
 279   1          Ui_Status.Ui = MAIN_STATE;
 280   1          Ui_Status.Widget = CONTROL_SCREENSAVE;
 281   1          LcdShow(&ScreensaverUiShow);
 282   1          PassWordDelete(&PassWordI);
 283   1      
 284   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Cancel\r\n");
              #endif
 287   1      }
 288          
 289          void KeyMenu_Down(void) //菜单状态--Down
 290          {
 291   1          if ((M_Show[MAIN_MENU].Finger_Index++) == 2) //箭头索引增加
 292   1              M_Show[MAIN_MENU].Finger_Index = 2;
 293   1      
 294   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize); 
             -//选项索引
 295   1      
 296   1          if (M_Show[MAIN_MENU].Option_Index == 0) //索引逻辑
 297   1          {
 298   2              M_Show[MAIN_MENU].Finger_Index = 0;
 299   2          }
 300   1      
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 6   

 301   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
 302   1          {
 303   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
 304   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 305   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 306   2          }
 307   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 308   1          {
 309   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 310   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 311   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 312   2          }
 313   1          else
 314   1          {
 315   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 316   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 317   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 318   2          }
 319   1      
 320   1          LcdShow(RefreshMenuDisp);                                                  //刷新显示
 321   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 322   1      
 323   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Down\r\n");
              #endif
 326   1      }
 327          
 328          /**
 329           * @brief       检查密码输入位数是否达标
 330           * @details     
 331           * @param       counts 当前密码输入次数
 332           * @return      true/false
 333           */
 334          uint8_t Check_PasswordBits(void)
 335          {
 336   1          /*密码位数不够，禁止修改*/
 337   1          if (!System_Parameter.PSWNext.Bit_Efficient_Flag)
 338   1          {
 339   2              clear_screen();
 340   2              if(!System_Parameter.PSWNext.First_Input_Flag)
 341   2              {
 342   3                  GUI_String(5, 20, "Invalid password!", EN_5_8);
 343   3                  GUI_String(5, 32, "Current counts is 1.", EN_5_8);
 344   3                  /*修改密码1清空 */
 345   3                  PassWordDelete(&PassWordChange1);
 346   3              }
 347   2              else
 348   2              {
 349   3                  GUI_String(5, 20, "Invalid password!", EN_5_8);
 350   3                  GUI_String(5, 32, "Current counts is 2.", EN_5_8);
 351   3                  /*修改密码2清空 */
 352   3                  PassWordDelete(&PassWordChange2);
 353   3              }
 354   2              Delay_ms(1000);
 355   2              /*显示修改密码界面*/
 356   2              LcdShow(PassWordChangeUIShow);
 357   2         
 358   2              return false;
 359   2          }
 360   1          return true;
 361   1      }
 362          
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 7   

 363          void KeyControl_Enter(void) //控件状态--Enter
 364          {
 365   1          switch (Ui_Status.Widget)
 366   1          {
 367   2          case CONTROL_PASSWORD_CHANGE:
 368   2          {
 369   3              if (!Check_PasswordBits())
 370   3                  return;
 371   3              /*如果是第一次输入修改密码*/
 372   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 373   3              {
 374   4                  uint8_t i;
 375   4                  uint8_t temp[2];
 376   4      
 377   4                  for (i = 0; i < PASSWORDBITS; i++) //显示4位密码
 378   4                  {
 379   5                      GUI_String(i * 20 + 100, 18, myitoa(PassWordChange1.PSWNext.PassWordbuff[i], temp, 10), EN
             -_5_8);
 380   5                  }
 381   4      
 382   4                  GUI_Lattice(175, 16, 16, 12, dot);
 383   4                  /*置标志位*/
 384   4                  System_Parameter.PSWNext.First_Input_Flag = true;
 385   4              }
 386   3              else
 387   3              {
 388   4                  if (PassWordjudge(PassWordChange1, PassWordChange2)) //密码判断两次输入相同密码时修改成功
 389   4                  {
 390   5                      memcpy(&System_Parameter.PSWNext.PassWordbuff, &PassWordChange2.PSWNext.PassWordbuff, size
             -of(PassWordChange2.PSWNext.PassWordbuff));
 391   5                      ControlSave();
 392   5                      PassWordDelete(&PassWordChange1); //修改密码1清0
 393   5                      PassWordDelete(&PassWordChange2); //修改密码2清0
 394   5                      /*返回菜单界面*/
 395   5                      Ui_Status.Ui = MENU_STATE;
 396   5      
 397   5                      clear_screen();
 398   5                      GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 399   5                      Delay_ms(500);
 400   5                      LcdShow(RefreshMenuDisp); //刷新显示
 401   5                  }
 402   4                  else //两次密码输入不一致时
 403   4                  {
 404   5      
 405   5                      clear_screen();
 406   5                      GUI_String(70, 22, "修改失败", CH_12_12); //显示修改结果
 407   5                      Delay_ms(500);
 408   5                      LcdShow(PassWordChangeUIShow); //修改密码
 409   5                  }
 410   4                  /*置标志位*/
 411   4                  System_Parameter.PSWNext.First_Input_Flag = false;
 412   4              }
 413   3              /*清除密码有效标志*/
 414   3              System_Parameter.PSWNext.Bit_Efficient_Flag = false;
 415   3              break;
 416   3          }
 417   2      
 418   2          case CONTROL_PLCPOWER:
 419   2          {
 420   3              System_Parameter.PlcState ^= 1;
 421   3              RUNKEY = System_Parameter.PlcState;
 422   3              ControlSave();           //存盘开关量
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 8   

 423   3              LcdShow(PlcPowerUIshow); // PLC设置界面
 424   3              break;
 425   3          }
 426   2      
 427   2          case CONTROL_COMMUNICA:
 428   2          {
 429   3              if (System_Parameter.CommunicationType == LOCAL)
 430   3              {
 431   4                  Wifi_Enable(false);
 432   4              }
 433   3              else
 434   3              {
 435   4                  Wifi_Enable(true);
 436   4                  clear_screen();
 437   4                  GUI_String(30, 22, "Please wait a moment", EN_5_8);
 438   4                  Delay_ms(500);
 439   4                  // /*初始化WIIF模块*/
 440   4                  // Wifi_Init();
 441   4              }
 442   3              ControlSave(); //存盘通信方式
 443   3      
 444   3              clear_screen();
 445   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 446   3              Delay_ms(500);
 447   3              // LcdShow(CommunicaUIshow); //通讯设置界面
 448   3              /*返回菜单界面*/
 449   3              Ui_Status.Ui = MENU_STATE;
 450   3              LcdShow(RefreshMenuDisp); //刷新显示
 451   3              break;
 452   3          }
 453   2      
 454   2          case CONTROL_BAUDSETTING:
 455   2          {
 456   3              if (M_Show[SEC0_MENU].OptionNow->ControlShow == NULL)
 457   3              {
 458   4                  return;
 459   4              }
 460   3              /*切换到波特率设置界面*/
 461   3              Ui_Status.Ui = BAUD_STATE;
 462   3              /*赋值控件*/
 463   3              Ui_Status.Widget = M_Show[SEC0_MENU].OptionNow->ControlType;
 464   3              /*显示控制界面*/
 465   3              LcdShow(M_Show[SEC0_MENU].OptionNow->ControlShow);
 466   3              /*无操作返回定时器开启*/
 467   3              // PublicTimer16.MenuDly16.Timer16Count = T_60S;
 468   3          }
 469   2          break;
 470   2          /*本机热点设置*/
 471   2          case CONTROL_HOTSPOT:
 472   2          {   /*检查函数指针非空*/
 473   3              if(Aplist[System_Parameter.Apstate].fun != NULL)
 474   3              {
 475   4                  /*执行对应的功能函数*/
 476   4                  Aplist[System_Parameter.Apstate].fun(); 
 477   4              }
 478   3              ControlSave(); //存盘热点设置
 479   3              clear_screen();
 480   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 481   3              Delay_ms(500);
 482   3              /*返回菜单界面*/
 483   3              Ui_Status.Ui = MENU_STATE;
 484   3              LcdShow(RefreshMenuDisp); //刷新显示
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 9   

 485   3          }break;
 486   2          /*恢复出厂设置*/
 487   2          case CONTROL_RELOAD:
 488   2          {
 489   3              CLOSE_GLOBAL_OUTAGE();
 490   3              IapErase(START_SAVEADDRESS); //擦除密码区
 491   3                                           /*把默认参数拷贝到当前数据结构*/
 492   3              memcpy(&System_Parameter.PSWNext.PassWordbuff[0], DEFAULT_SYSTEM_PARAMETER, (sizeof(System_Paramet
             -er) - 1U));
 493   3              /*把数据进行存储*/
 494   3              IapWrite_Buff(START_SAVEADDRESS, &System_Parameter.PSWNext.PassWordbuff[0], (sizeof(System_Paramet
             -er) - 1U)); //使密码界面失效
 495   3              OPEN_GLOBAL_OUTAGE();
 496   3      
 497   3              BaudInit();
 498   3              PowerInit();
 499   3              CommunicaInit();
 500   3              Wifi_Init();
 501   3      
 502   3              clear_screen();
 503   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 504   3              Delay_ms(500);
 505   3              /*返回菜单界面*/
 506   3              Ui_Status.Ui = MENU_STATE;
 507   3              LcdShow(RefreshMenuDisp); //刷新显示
 508   3              break;
 509   3          }
 510   2      
 511   2          default:
 512   2              break;
 513   2          }
 514   1      
 515   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Enter\r\n");
              #endif
 518   1      }
 519          
 520          void KeyControl_Menu(void) //控件状态--Menu
 521          {
 522   1          switch (Ui_Status.Widget)
 523   1          {
 524   2          case CONTROL_PASSWORD_CHANGE:
 525   2          {
 526   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 527   3              {
 528   4      
 529   4                  InputOffect(&PassWordChange1);
 530   4              }
 531   3              else
 532   3              {
 533   4      
 534   4                  InputOffect(&PassWordChange2);
 535   4              }
 536   3      
 537   3              break;
 538   3          }
 539   2      
 540   2          default:
 541   2              break;
 542   2          }
 543   1      
 544   1      #if USE_PRINTF_DEBUG
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 10  

                  printf("KeyControl_Menu\r\n");
              #endif
 547   1      }
 548          
 549          void KeyControl_Cancel(void) //控件状态--Cancel
 550          {
 551   1          switch (Ui_Status.Widget)
 552   1          {
 553   2          case CONTROL_PASSWORD_CHANGE:
 554   2          {
 555   3              PassWordDelete(&PassWordChange1); //清0数据
 556   3                  PassWordDelete(&PassWordChange2);
 557   3              System_Parameter.PSWNext.First_Input_Flag = false;
 558   3              System_Parameter.PSWNext.Bit_Efficient_Flag = false;
 559   3              break;
 560   3          }
 561   2      
 562   2          case CONTROL_COMMUNICA:
 563   2          {
 564   3              // CommunciaIndex = CommunciaType; //如果没有确定,直接返回，则恢复当前状态索引
 565   3              break;
 566   3          }
 567   2      
 568   2          case CONTROL_BAUDSETTING:
 569   2          {
 570   3              // BaudWillIndex = BaudIndex; //如果没有确定,直接返回，则恢复当前状态索引
 571   3              break;
 572   3          }
 573   2      
 574   2          case CONTROL_RELOAD:
 575   2          {
 576   3              break;
 577   3          }
 578   2      
 579   2          default:
 580   2              break;
 581   2          }
 582   1      
 583   1          /*返回菜单界面*/
 584   1          Ui_Status.Ui = MENU_STATE;
 585   1          LcdShow(RefreshMenuDisp); //显示设置
 586   1      
 587   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Cancel\r\n");
              #endif
 590   1      }
 591          
 592          /*控件状态--Up*/
 593          void KeyControl_Up(void)
 594          {
 595   1          switch (Ui_Status.Widget)
 596   1          {
 597   2          case CONTROL_PASSWORD_CHANGE:
 598   2          {
 599   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 600   3              {
 601   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange1);
 602   4                  uint8_t temp[2] = {0}; //字符
 603   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
 604   4              }
 605   3              else
 606   3              {
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 11  

 607   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange2);
 608   4                  uint8_t temp[2] = {0}; //字符
 609   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 610   4              }
 611   3          }
 612   2          break;
 613   2      
 614   2          case CONTROL_COMMUNICA:
 615   2          {
 616   3              System_Parameter.CommunicationType ^= 1;
 617   3              LcdShow(CommunicaUIshow); //通讯设置界面
 618   3          }
 619   2          break;
 620   2      
 621   2          case CONTROL_BAUDSETTING:
 622   2          {
 623   3              /*箭头索引减小*/
 624   3              if ((M_Show[SEC0_MENU].Finger_Index--) == 0)
 625   3                  M_Show[SEC0_MENU].Finger_Index = 0;
 626   3      
 627   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(UPWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSize1
             -);
 628   3      
 629   3              if (M_Show[SEC0_MENU].Option_Index == (OptionlistSize1 - 1)) //索引逻辑
 630   3              {
 631   4                  M_Show[SEC0_MENU].Finger_Index = 2;
 632   4              }
 633   3              /*菜单滑动逻辑*/
 634   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 635   3              {
 636   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 637   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 638   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 639   4              }
 640   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 641   3              {
 642   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 643   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 644   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
 645   4              }
 646   3              else
 647   3              {
 648   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 649   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
 650   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
 651   4              }
 652   3      
 653   3              LcdShow(RefreshBaudDisp);                                                   //刷新显示
 654   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 655   3          }
 656   2          break;
 657   2          /*本机热点设置*/
 658   2          case CONTROL_HOTSPOT:
 659   2          {
 660   3              System_Parameter.Apstate = LoopIndex(DOWMWORD, System_Parameter.Apstate, G_Aplist_Size);
 661   3              GUI_String(115, 10, Aplist[System_Parameter.Apstate].pstring, CH_12_12);
 662   3          }break;
 663   2          default:
 664   2              break;
 665   2          }
 666   1      
 667   1      #if USE_PRINTF_DEBUG
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 12  

                  printf("KeyControl_Up\r\n");
              #endif
 670   1      }
 671          
 672          void KeyControl_Down(void) //控件状态--Down
 673          {
 674   1          switch (Ui_Status.Widget)
 675   1          {
 676   2          case CONTROL_PASSWORD_CHANGE:
 677   2          {
 678   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 679   3              {
 680   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange1);
 681   4                  uint8_t temp[2] = {0}; //字符
 682   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
 683   4              }
 684   3              else
 685   3              {
 686   4      
 687   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange2);
 688   4                  uint8_t temp[2]= {0}; //字符
 689   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 690   4              }
 691   3          }
 692   2          break;
 693   2      
 694   2          case CONTROL_COMMUNICA:
 695   2          {
 696   3              System_Parameter.CommunicationType ^= 1;
 697   3              LcdShow(CommunicaUIshow); //通讯设置界面
 698   3          }
 699   2          break;
 700   2      
 701   2          case CONTROL_BAUDSETTING:
 702   2          {
 703   3              if ((M_Show[SEC0_MENU].Finger_Index++) >= 2) //箭头索引增加
 704   3                  M_Show[SEC0_MENU].Finger_Index = 2;
 705   3      
 706   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSiz
             -e1); //选项索引
 707   3      
 708   3              if (M_Show[SEC0_MENU].Option_Index == 0) //索引逻辑
 709   3              {
 710   4                  M_Show[SEC0_MENU].Finger_Index = 0;
 711   4              }
 712   3      
 713   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 714   3              {
 715   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 716   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 717   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 718   4              }
 719   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 720   3              {
 721   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 722   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 723   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
 724   4              }
 725   3              else
 726   3              {
 727   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 728   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 13  

 729   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
 730   4              }
 731   3              /*刷新当前选项卡*/
 732   3              LcdShow(RefreshBaudDisp);
 733   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 734   3          }
 735   2          break;
 736   2          /*本机热点设置*/
 737   2          case CONTROL_HOTSPOT:
 738   2          {
 739   3              System_Parameter.Apstate = LoopIndex(UPWORD, System_Parameter.Apstate, G_Aplist_Size);
 740   3              GUI_String(115, 10, Aplist[System_Parameter.Apstate].pstring, CH_12_12);
 741   3          }break;
 742   2          default:
 743   2              break;
 744   2          }
 745   1      
 746   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Down\r\n");
              #endif
 749   1      }
 750          
 751          /*波特率控件状态--up*/
 752          void KeyBaud_Up(void)
 753          {
 754   1          switch (Ui_Status.Widget)
 755   1          {
 756   2          case CONTROL_BAUD1:
 757   2          {
 758   3              System_Parameter.BaudIndex[0] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[0], G_BaudList_Size
             -);
 759   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 760   3          }
 761   2          break;
 762   2          case CONTROL_BAUD2:
 763   2          {
 764   3              System_Parameter.BaudIndex[1] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[1], G_BaudList_Size
             -);
 765   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 766   3          }
 767   2          break;
 768   2          case CONTROL_BAUD3:
 769   2          {
 770   3              System_Parameter.BaudIndex[2] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[2], G_BaudList_Size
             -);
 771   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 772   3          }
 773   2          break;
 774   2          case CONTROL_BAUD4:
 775   2          {
 776   3              System_Parameter.BaudIndex[3] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[3], G_BaudList_Size
             -);
 777   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
 778   3          }
 779   2          break;
 780   2          default:
 781   2              break;
 782   2          }
 783   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Up\r\n");
              #endif
 786   1      }
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 14  

 787          
 788          /*波特率控件状态--Down*/
 789          void KeyBaud_Down(void)
 790          {
 791   1          switch (Ui_Status.Widget)
 792   1          {
 793   2          case CONTROL_BAUD1:
 794   2          {
 795   3              System_Parameter.BaudIndex[0] = LoopIndex(UPWORD, System_Parameter.BaudIndex[0], G_BaudList_Size);
 796   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 797   3          }
 798   2          break;
 799   2          case CONTROL_BAUD2:
 800   2          {
 801   3              System_Parameter.BaudIndex[1] = LoopIndex(UPWORD, System_Parameter.BaudIndex[1], G_BaudList_Size);
 802   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 803   3          }
 804   2          break;
 805   2          case CONTROL_BAUD3:
 806   2          {
 807   3              System_Parameter.BaudIndex[2] = LoopIndex(UPWORD, System_Parameter.BaudIndex[2], G_BaudList_Size);
 808   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 809   3          }
 810   2          break;
 811   2          case CONTROL_BAUD4:
 812   2          {
 813   3              System_Parameter.BaudIndex[3] = LoopIndex(UPWORD, System_Parameter.BaudIndex[3], G_BaudList_Size);
 814   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
 815   3          }
 816   2          break;
 817   2          default:
 818   2              break;
 819   2          }
 820   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Down\r\n");
              #endif
 823   1      }
 824          
 825          /*波特率控件状态--Enter*/
 826          void KeyBaud_Enter(void)
 827          {
 828   1          switch (Ui_Status.Widget)
 829   1          {
 830   2          case CONTROL_BAUD1:
 831   2          {
 832   3              SET_BRT1(1, Baudlist[System_Parameter.BaudIndex[0]].BaudValue);
 833   3              ControlSave();
 834   3      
 835   3              clear_screen();
 836   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 837   3              Delay_ms(500);
 838   3              /*修改成功后返回*/
 839   3              KeyBaud_Cancel();
 840   3          }
 841   2          break;
 842   2          case CONTROL_BAUD2:
 843   2          {
 844   3              SET_BRT1(2, Baudlist[System_Parameter.BaudIndex[1]].BaudValue);
 845   3              ControlSave();
 846   3      
 847   3              clear_screen();
 848   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 15  

 849   3              Delay_ms(500);
 850   3              /*修改成功后返回*/
 851   3              KeyBaud_Cancel();
 852   3          }
 853   2          break;
 854   2          case CONTROL_BAUD3:
 855   2          {
 856   3              SET_BRT1(3, Baudlist[System_Parameter.BaudIndex[2]].BaudValue);
 857   3              ControlSave();
 858   3      
 859   3              clear_screen();
 860   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 861   3              Delay_ms(500);
 862   3              /*修改成功后返回*/
 863   3              KeyBaud_Cancel();
 864   3          }
 865   2          break;
 866   2          case CONTROL_BAUD4:
 867   2          {
 868   3              SET_BRT1(4, Baudlist[System_Parameter.BaudIndex[3]].BaudValue);
 869   3              ControlSave();
 870   3      
 871   3              clear_screen();
 872   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 873   3              Delay_ms(500);
 874   3              // LcdShow(BaudSettingUI4show); //波特率设置界面
 875   3              /*修改成功后返回*/
 876   3              KeyBaud_Cancel();
 877   3          }
 878   2          break;
 879   2          default:
 880   2              break;
 881   2          }
 882   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Enter\r\n");
              #endif
 885   1      }
 886          
 887          /*波特率控件状态--Cancel*/
 888          void KeyBaud_Cancel(void)
 889          { /*返回上级菜单界面*/
 890   1          Ui_Status.Ui = CONTROL_STATE;
 891   1          /*赋值控件*/
 892   1          Ui_Status.Widget = CONTROL_BAUDSETTING;
 893   1          LcdShow(RefreshBaudDisp);
 894   1      
 895   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Cancel\r\n");
              #endif
 898   1      }
 899          
 900          /*波特率控件状态--Menue*/
 901          void KeyBaud_Menu(void)
 902          {
 903   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Menu\r\n");
              #endif
 906   1      }
 907          
 908          /*一级菜单界面刷新显示*/
 909          void RefreshMenuDisp(void)
 910          {
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 16  

 911   1          uint8_t i = 0;
 912   1          clear_screen(); //清屏
 913   1      
 914   1          for (; i < 3; i++)
 915   1          {
 916   2              GUI_String(70, 20 * i + 5, Optionlist[M_Show[MAIN_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 917   2          }
 918   1      
 919   1          GUI_Lattice(50, 6 + M_Show[MAIN_MENU].Finger_Index * 20, 16, 12, finger);
 920   1      }
 921          
 922          /*菜单界面下二级菜单刷新显示*/
 923          void RefreshBaudDisp(void)
 924          {
 925   1          uint8_t i = 0;
 926   1          clear_screen(); //清屏
 927   1      
 928   1          for (; i < 3U; i++)
 929   1          {
 930   2              GUI_String(70, 20 * i + 5, Optionlist1[M_Show[SEC0_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 931   2          }
 932   1      
 933   1          GUI_Lattice(50, 6 + M_Show[SEC0_MENU].Finger_Index * 20, 16, 12, finger);
 934   1      }
 935          
 936          /**
 937           * @brief       波特率设置二级菜单
 938           * @details
 939           * @param       None
 940           * @retval      None
 941           */
 942          void Baud_Setting(void)
 943          {
 944   1          /*刷新界面*/
 945   1          LcdShow(RefreshBaudDisp);
 946   1          // /*切换到波特率设置界面*/
 947   1          // UI_STATE = BAUD_STATE;
 948   1          // /*无操作返回定时器开启*/
 949   1          // PublicTimer16.MenuDly16.Timer16Count = T_60S;
 950   1      }
 951          
 952          void LcdDly(KEY_e key)
 953          { /*如果已经在密码输入界面*/
 954   1          if (Ui_Status.Ui == MAIN_STATE)
 955   1          { /*并且当前控件为屏保，不启用定时器*/
 956   2              if (Ui_Status.Widget == CONTROL_SCREENSAVE)
 957   2                  return;
 958   2          }
 959   1      
 960   1          if (key == NO_KEY)
 961   1          {
 962   2              if (PublicTimer16.MenuDly16.Timer16Flag)
 963   2              {
 964   3                  PublicTimer16.MenuDly16.Timer16Flag = false;
 965   3                  Ui_Status.Ui = MAIN_STATE;
 966   3                  Ui_Status.Widget = CONTROL_SCREENSAVE;
 967   3                  /*屏保界面界面*/
 968   3                  LcdShow(&ScreensaverUiShow);
 969   3                  PassWordDelete(&PassWordI);
 970   3              }
 971   2          }
 972   1          else
C51 COMPILER V9.60.0.0   MENU                                                              12/18/2021 17:07:55 PAGE 17  

 973   1          {
 974   2              PublicTimer16.MenuDly16.Timer16Count = T_60S;
 975   2          }
 976   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2814    ----
   CONSTANT SIZE    =    236    ----
   XDATA SIZE       =    190      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
