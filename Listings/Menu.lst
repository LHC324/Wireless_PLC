C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Objects\Menu.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\Menu.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeModBu
                    -s\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\Menu.lst) OBJECT(.\Objects\Menu.obj)

line level    source

   1          #include "Menu.h"
   2          
   3          /*当前UI界面和显示控件*/
   4          Current_UI Ui_Status = {MAIN_STATE, CONTROL_SCREENSAVE};
   5          
   6          OPTION Optionlist[] =
   7              {
   8                  {"启停开关", CONTROL_PLCPOWER, PlcPowerUIshow},
   9                  {"通信方式", CONTROL_COMMUNICA, CommunicaUIshow},
  10                  {"工作模式",CONTROL_WORKMODE, WorkModeUIshow},
  11                  {"密码修改", CONTROL_PASSWORD_CHANGE, PassWordChangeUIShow},
  12                  {"波特率设置", CONTROL_BAUDSETTING, Baud_Setting},
  13                  {"本机热点", CONTROL_HOTSPOT, HotspotSettingUIshow},
  14                  {"恢复出厂设置", CONTROL_RELOAD, ReloadSettingUIshow},
  15          };
  16          
  17          #define OptionlistSize (sizeof(Optionlist) / sizeof(OPTION))
  18          
  19          /*二级菜单*/
  20          OPTION Optionlist1[] =
  21              {
  22                  {"以太网", CONTROL_BAUD1, BaudSettingUI1show},
  23                  {"无线网", CONTROL_BAUD2, BaudSettingUI2show},
  24                  {"扩展网", CONTROL_BAUD3, BaudSettingUI3show},
  25                  {"内部网", CONTROL_BAUD4, BaudSettingUI4show}};
  26          
  27          #define OptionlistSize1 (sizeof(Optionlist1) / sizeof(OPTION))
  28          
  29          /*当前多级菜单数量*/
  30          Menu_Show M_Show[] =
  31              {
  32                  {0, 0, 0, {0, 1, 2}, Optionlist},
  33                  {0, 0, 0, {0, 1, 2}, Optionlist1}
  34          
  35          };
  36          
  37          #define MENU_NUM (sizeof(M_Show) / sizeof(Menu_Show))
  38          
  39          /*函数映射表*/
  40          const KEY_MAP keyStateEvent[] =
  41              {
  42                  /*Main状态*/
  43                  {KEY_UP, MAIN_STATE, KeyMain_Up},
  44                  {KEY_DOWN, MAIN_STATE, KeyMain_Down},
  45                  {KEY_ENTER, MAIN_STATE, KeyMain_Enter},
  46                  {KEY_CANCEL, MAIN_STATE, KeyMain_Cancel},
  47                  {KEY_MENU, MAIN_STATE, KeyMain_Menu},
  48                  /*Menu状态*/
  49                  {KEY_UP, MENU_STATE, KeyMenu_Up},
  50                  {KEY_DOWN, MENU_STATE, KeyMenu_Down},
  51                  {KEY_ENTER, MENU_STATE, KeyMenu_Enter},
  52                  {KEY_CANCEL, MENU_STATE, KeyMenu_Cancel},
  53                  {KEY_MENU, MENU_STATE, KeyMenu_Menu},
  54                  /*CONTROL状态*/
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 2   

  55                  {KEY_UP, CONTROL_STATE, KeyControl_Up},
  56                  {KEY_DOWN, CONTROL_STATE, KeyControl_Down},
  57                  {KEY_ENTER, CONTROL_STATE, KeyControl_Enter},
  58                  {KEY_CANCEL, CONTROL_STATE, KeyControl_Cancel},
  59                  {KEY_MENU, CONTROL_STATE, KeyControl_Menu},
  60                  /*BAUD状态*/
  61                  {KEY_UP, BAUD_STATE, KeyBaud_Up},
  62                  {KEY_DOWN, BAUD_STATE, KeyBaud_Down},
  63                  {KEY_ENTER, BAUD_STATE, KeyBaud_Enter},
  64                  {KEY_CANCEL, BAUD_STATE, KeyBaud_Cancel},
  65                  {KEY_MENU, BAUD_STATE, KeyBaud_Menu}};
  66          
  67          #define keyStateEventSize (sizeof(keyStateEvent) / sizeof(KEY_MAP))
  68          
  69          void KeyEvent(void) //按键事件
  70          {
  71   1          uint8_t i;
  72   1          KEY_e KeyState = Key_Chick(); //获取按键状态
  73   1      
  74   1          LcdDly(KeyState); // 无按键操作返回函数
  75   1      
  76   1          if (KeyState == NO_KEY) //无按键直接返回
  77   1          {
  78   2              return;
  79   2          }
  80   1      
  81   1          for (i = 0; i < keyStateEventSize; i++)
  82   1          {
  83   2              if (KeyState == keyStateEvent[i].Keycodel) //按键值
  84   2              {   /*按键状态*/
  85   3                  if (Ui_Status.Ui == keyStateEvent[i].Stage)
  86   3                  {
  87   4                      keyStateEvent[i].fun(); //执行按键状态对应函数
  88   4                      break;
  89   4                  }
  90   3              }
  91   2          }
  92   1      }
  93          
  94          void LcdShowInit(void) //界面显示初始化
  95          {
  96   1          LcdShow(&ScreensaverUiShow);
  97   1      }
  98          
  99          /*界面显示接口(回调函数思想)*/
 100          void LcdShow(pshow InterfaceShow) 
 101          {
 102   1          InterfaceShow();
 103   1      }
 104          
 105          /**
 106           * @brief       主界面状态--enter
 107           * @details     在主界面下按下enter按钮
 108           * @param       None
 109           * @retval      None
 110           */
 111          void KeyMain_Enter(void)
 112          {
 113   1      #if USE_PRINTF_DEBUG
                  uint8_t temp = strncmp(System_Parameter.PSWNext.PassWordbuff, "\xFF\xFF\xFF\xFF", PASSWORDBITS);
              #endif
 116   1          if (Ui_Status.Widget == CONTROL_PASSWORD)
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 3   

 117   1          {
 118   2              /*没有设置过密码或者密码正确*/
 119   2              if (PassWordjudge(PassWordI, System_Parameter) || (!strncmp(System_Parameter.PSWNext.PassWordbuff,
             - "\xFF\xFF\xFF\xFF", PASSWORDBITS)))
 120   2              {
 121   3                  LcdShow(RefreshMenuDisp); //刷新界面
 122   3                  Ui_Status.Ui = MENU_STATE;
 123   3                  // PublicTimer16.MenuDly16.Timer16Count = T_60S; //无操作返回定时器开启
 124   3              }
 125   2              else //如果密码错误
 126   2              {
 127   3                  PassWordDelete(&PassWordI);
 128   3                  clear_screen();
 129   3                  GUI_String(49, 31, "wrong password !", EN_5_8);
 130   3                  Delay_ms(1000);
 131   3                  // /*控件选项为屏保*/
 132   3                  // Ui_Status.Widget = CONTROL_SCREENSAVE;
 133   3                  LcdShow(PassWordInputUIShow); //重新输入
 134   3              }
 135   2          }
 136   1      
 137   1      #if USE_PRINTF_DEBUG
                  Uartx_SendStr(&Uart1, System_Parameter.PSWNext.PassWordbuff, 4);
                  Uartx_SendStr(&Uart1, &temp, 1);
                  printf("KeyMain_Enter\r\n");
              #endif
 142   1      }
 143          
 144          void KeyMain_Up(void) //主界面状态--Up
 145          {
 146   1          if (Ui_Status.Widget == CONTROL_PASSWORD) //密码控件
 147   1          {
 148   2              uint8_t Value = PassWordInput(ADD, &PassWordI);
 149   2              uint8_t temp[2] = {0}; //字符
 150   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 151   2          }
 152   1      
 153   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Up\r\n");
              #endif
 156   1      }
 157          /*屏保界面到密码输入界面切换*/
 158          void KeyMain_Menu(void) //主界面状态--Menu
 159          {
 160   1          switch (Ui_Status.Widget)
 161   1          {
 162   2          case CONTROL_SCREENSAVE:
 163   2          {
 164   3              /*切换到密码界面*/
 165   3              Ui_Status.Widget = CONTROL_PASSWORD;
 166   3              LcdShow(&PassWordInputUIShow);
 167   3              /*无操作返回定时器开启*/
 168   3              PublicTimer16.MenuDly16.Timer16Count = T_60S;
 169   3          }
 170   2          break;
 171   2          case CONTROL_PASSWORD:
 172   2          { /*改变当前密码输入位置*/
 173   3              InputOffect(&PassWordI);
 174   3          }
 175   2          break;
 176   2          default:
 177   2              break;
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 4   

 178   2          }
 179   1      
 180   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Menu\r\n");
              #endif
 183   1      }
 184          
 185          void KeyMain_Cancel(void) //主界面状态--Cancel
 186          {
 187   1          /*主界面按下取消键，退到屏保界面*/
 188   1          if (Ui_Status.Widget == CONTROL_PASSWORD)
 189   1          {
 190   2              LcdShow(&ScreensaverUiShow);
 191   2              Ui_Status.Widget = CONTROL_SCREENSAVE;
 192   2              PassWordDelete(&PassWordI);
 193   2          }
 194   1      
 195   1      #if USE_PRINTF_DEBUG
                  printf("%s\r\n", System_Parameter.PSWNext.PassWordbuff); //防止忘记密码之后进不去PLC
              #endif
 198   1      }
 199          
 200          void KeyMain_Down(void) //主界面状态--Down
 201          {
 202   1          if (Ui_Status.Widget == CONTROL_PASSWORD)
 203   1          {
 204   2              uint8_t Value = PassWordInput(SUB, &PassWordI);
 205   2              uint8_t temp[2] = {0}; //字符
 206   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 207   2          }
 208   1      
 209   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Down\r\n");
              #endif
 212   1      }
 213          
 214          void KeyMenu_Enter(void) //菜单状态--Enter
 215          {
 216   1          if (M_Show[MAIN_MENU].OptionNow->ControlShow == NULL)
 217   1          {
 218   2              return;
 219   2          }
 220   1      
 221   1          Ui_Status.Ui = CONTROL_STATE;
 222   1          Ui_Status.Widget = M_Show[MAIN_MENU].OptionNow->ControlType; //赋值控件
 223   1          LcdShow(M_Show[MAIN_MENU].OptionNow->ControlShow);      //显示控制界面
 224   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Enter\r\n");
              #endif
 227   1      }
 228          
 229          /*菜单状态--Up*/
 230          void KeyMenu_Up(void)
 231          {
 232   1          /*箭头索引减小*/
 233   1          if ((M_Show[MAIN_MENU].Finger_Index--) == 0)
 234   1              M_Show[MAIN_MENU].Finger_Index = 0;
 235   1      
 236   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(UPWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize);
 237   1      
 238   1          if (M_Show[MAIN_MENU].Option_Index == (OptionlistSize - 1)) //索引逻辑
 239   1          {
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 5   

 240   2              M_Show[MAIN_MENU].Finger_Index = 2;
 241   2          }
 242   1          /*菜单滑动逻辑*/
 243   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
 244   1          {
 245   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
 246   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 247   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 248   2          }
 249   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 250   1          {
 251   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 252   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 253   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 254   2          }
 255   1          else
 256   1          {
 257   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 258   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 259   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 260   2          }
 261   1      
 262   1          LcdShow(RefreshMenuDisp);                                                  //刷新显示
 263   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 264   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Up\r\n");
              #endif
 267   1      }
 268          
 269          /*菜单状态--Menu*/
 270          void KeyMenu_Menu(void)
 271          {
 272   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Menu\r\n");
              #endif
 275   1      }
 276          
 277          void KeyMenu_Cancel(void) //菜单状态--Cancel
 278          {
 279   1          /*菜单界面按下取消键，直接锁屏*/
 280   1          Ui_Status.Ui = MAIN_STATE;
 281   1          Ui_Status.Widget = CONTROL_SCREENSAVE;
 282   1          LcdShow(&ScreensaverUiShow);
 283   1          PassWordDelete(&PassWordI);
 284   1      
 285   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Cancel\r\n");
              #endif
 288   1      }
 289          
 290          void KeyMenu_Down(void) //菜单状态--Down
 291          {
 292   1          if ((M_Show[MAIN_MENU].Finger_Index++) == 2) //箭头索引增加
 293   1              M_Show[MAIN_MENU].Finger_Index = 2;
 294   1      
 295   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize); 
             -//选项索引
 296   1      
 297   1          if (M_Show[MAIN_MENU].Option_Index == 0) //索引逻辑
 298   1          {
 299   2              M_Show[MAIN_MENU].Finger_Index = 0;
 300   2          }
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 6   

 301   1      
 302   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
 303   1          {
 304   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
 305   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 306   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 307   2          }
 308   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 309   1          {
 310   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 311   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 312   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 313   2          }
 314   1          else
 315   1          {
 316   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 317   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 318   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 319   2          }
 320   1      
 321   1          LcdShow(RefreshMenuDisp);                                                  //刷新显示
 322   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 323   1      
 324   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Down\r\n");
              #endif
 327   1      }
 328          
 329          /**
 330           * @brief       检查密码输入位数是否达标
 331           * @details     
 332           * @param       counts 当前密码输入次数
 333           * @return      true/false
 334           */
 335          uint8_t Check_PasswordBits(void)
 336          {
 337   1          /*密码位数不够，禁止修改*/
 338   1          if (!System_Parameter.PSWNext.Bit_Efficient_Flag)
 339   1          {
 340   2              clear_screen();
 341   2              if(!System_Parameter.PSWNext.First_Input_Flag)
 342   2              {
 343   3                  GUI_String(5, 20, "Invalid password!", EN_5_8);
 344   3                  GUI_String(5, 32, "Current counts is 1.", EN_5_8);
 345   3                  /*修改密码1清空 */
 346   3                  PassWordDelete(&PassWordChange1);
 347   3              }
 348   2              else
 349   2              {
 350   3                  GUI_String(5, 20, "Invalid password!", EN_5_8);
 351   3                  GUI_String(5, 32, "Current counts is 2.", EN_5_8);
 352   3                  /*修改密码2清空 */
 353   3                  PassWordDelete(&PassWordChange2);
 354   3              }
 355   2              Delay_ms(1000);
 356   2              /*显示修改密码界面*/
 357   2              LcdShow(PassWordChangeUIShow);
 358   2         
 359   2              return false;
 360   2          }
 361   1          return true;
 362   1      }
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 7   

 363          
 364          void KeyControl_Enter(void) //控件状态--Enter
 365          {
 366   1          switch (Ui_Status.Widget)
 367   1          {
 368   2          case CONTROL_PASSWORD_CHANGE:
 369   2          {
 370   3              if (!Check_PasswordBits())
 371   3                  return;
 372   3              /*如果是第一次输入修改密码*/
 373   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 374   3              {
 375   4                  uint8_t i;
 376   4                  uint8_t temp[2];
 377   4      
 378   4                  for (i = 0; i < PASSWORDBITS; i++) //显示4位密码
 379   4                  {
 380   5                      GUI_String(i * 20 + 100, 18, myitoa(PassWordChange1.PSWNext.PassWordbuff[i], temp, 10), EN
             -_5_8);
 381   5                  }
 382   4      
 383   4                  GUI_Lattice(175, 16, 16, 12, dot);
 384   4                  /*置标志位*/
 385   4                  System_Parameter.PSWNext.First_Input_Flag = true;
 386   4              }
 387   3              else
 388   3              {
 389   4                  if (PassWordjudge(PassWordChange1, PassWordChange2)) //密码判断两次输入相同密码时修改成功
 390   4                  {
 391   5                      memcpy(&System_Parameter.PSWNext.PassWordbuff, &PassWordChange2.PSWNext.PassWordbuff, size
             -of(PassWordChange2.PSWNext.PassWordbuff));
 392   5                      ControlSave();
 393   5                      PassWordDelete(&PassWordChange1); //修改密码1清0
 394   5                      PassWordDelete(&PassWordChange2); //修改密码2清0
 395   5                      /*返回菜单界面*/
 396   5                      Ui_Status.Ui = MENU_STATE;
 397   5      
 398   5                      clear_screen();
 399   5                      GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 400   5                      Delay_ms(500);
 401   5                      LcdShow(RefreshMenuDisp); //刷新显示
 402   5                  }
 403   4                  else //两次密码输入不一致时
 404   4                  {
 405   5      
 406   5                      clear_screen();
 407   5                      GUI_String(70, 22, "修改失败", CH_12_12); //显示修改结果
 408   5                      Delay_ms(500);
 409   5                      LcdShow(PassWordChangeUIShow); //修改密码
 410   5                  }
 411   4                  /*置标志位*/
 412   4                  System_Parameter.PSWNext.First_Input_Flag = false;
 413   4              }
 414   3              /*清除密码有效标志*/
 415   3              System_Parameter.PSWNext.Bit_Efficient_Flag = false;
 416   3              break;
 417   3          }
 418   2      
 419   2          case CONTROL_PLCPOWER:
 420   2          {
 421   3              System_Parameter.PlcState ^= 1;
 422   3              RUNKEY = System_Parameter.PlcState;
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 8   

 423   3              ControlSave();           //存盘开关量
 424   3              LcdShow(PlcPowerUIshow); // PLC设置界面
 425   3              break;
 426   3          }
 427   2      
 428   2          case CONTROL_COMMUNICA:
 429   2          {
 430   3              if (System_Parameter.CommunicationType == LOCAL)
 431   3              {
 432   4                  Wifi_Enable(false);
 433   4              }
 434   3              else
 435   3              {
 436   4                  Wifi_Enable(true);
 437   4                  clear_screen();
 438   4                  GUI_String(30, 22, "Please wait a moment", EN_5_8);
 439   4                  Delay_ms(500);
 440   4                  // /*初始化WIIF模块*/
 441   4                  // Wifi_Init();
 442   4              }
 443   3              ControlSave(); //存盘通信方式
 444   3      
 445   3              clear_screen();
 446   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 447   3              Delay_ms(500);
 448   3              // LcdShow(CommunicaUIshow); //通讯设置界面
 449   3              /*返回菜单界面*/
 450   3              Ui_Status.Ui = MENU_STATE;
 451   3              LcdShow(RefreshMenuDisp); //刷新显示
 452   3              break;
 453   3          }
 454   2      
 455   2          case CONTROL_BAUDSETTING:
 456   2          {
 457   3              if (M_Show[SEC0_MENU].OptionNow->ControlShow == NULL)
 458   3              {
 459   4                  return;
 460   4              }
 461   3              /*切换到波特率设置界面*/
 462   3              Ui_Status.Ui = BAUD_STATE;
 463   3              /*赋值控件*/
 464   3              Ui_Status.Widget = M_Show[SEC0_MENU].OptionNow->ControlType;
 465   3              /*显示控制界面*/
 466   3              LcdShow(M_Show[SEC0_MENU].OptionNow->ControlShow);
 467   3              /*无操作返回定时器开启*/
 468   3              // PublicTimer16.MenuDly16.Timer16Count = T_60S;
 469   3          }
 470   2          break;
 471   2          /*本机热点设置*/
 472   2          case CONTROL_HOTSPOT:
 473   2          {   /*检查函数指针非空*/
 474   3              if(Aplist[System_Parameter.Apstate].fun != NULL)
 475   3              {
 476   4                  /*执行对应的功能函数*/
 477   4                  Aplist[System_Parameter.Apstate].fun(); 
 478   4              }
 479   3              ControlSave(); //存盘热点设置
 480   3              clear_screen();
 481   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 482   3              Delay_ms(500);
 483   3              /*返回菜单界面*/
 484   3              Ui_Status.Ui = MENU_STATE;
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 9   

 485   3              LcdShow(RefreshMenuDisp); //刷新显示
 486   3          }break;
 487   2          /*工作模式选择*/
 488   2          case CONTROL_WORKMODE:
 489   2          {
 490   3              /*检查函数指针非空*/
 491   3              if(Modelist[SYS_TEMP_PARA.WorkMode].fun != NULL)
 492   3              {
 493   4                  /*执行对应的功能函数*/
 494   4                  Modelist[SYS_TEMP_PARA.WorkMode].fun(); 
 495   4              }
 496   3              ControlSave(); //存盘工作模式设置
 497   3              clear_screen();
 498   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 499   3              Delay_ms(500);
 500   3              /*返回菜单界面*/
 501   3              Ui_Status.Ui = MENU_STATE;
 502   3              LcdShow(RefreshMenuDisp); //刷新显示
 503   3          }break;
 504   2          /*恢复出厂设置*/
 505   2          case CONTROL_RELOAD:
 506   2          {
 507   3              CLOSE_GLOBAL_OUTAGE();
 508   3              IapErase(START_SAVEADDRESS); //擦除密码区
 509   3                                           /*把默认参数拷贝到当前数据结构*/
 510   3              memcpy(&System_Parameter.PSWNext.PassWordbuff[0], DEFAULT_SYSTEM_PARAMETER, (sizeof(System_Paramet
             -er) - 1U));
 511   3              /*把数据进行存储*/
 512   3              IapWrite_Buff(START_SAVEADDRESS, &System_Parameter.PSWNext.PassWordbuff[0], (sizeof(System_Paramet
             -er) - 1U)); //使密码界面失效
 513   3              OPEN_GLOBAL_OUTAGE();
 514   3      
 515   3              BaudInit();
 516   3              PowerInit();
 517   3              CommunicaInit();
 518   3              Wifi_Init();
 519   3      
 520   3              clear_screen();
 521   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 522   3              Delay_ms(500);
 523   3              /*返回菜单界面*/
 524   3              Ui_Status.Ui = MENU_STATE;
 525   3              LcdShow(RefreshMenuDisp); //刷新显示
 526   3              break;
 527   3          }
 528   2      
 529   2          default:
 530   2              break;
 531   2          }
 532   1      
 533   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Enter\r\n");
              #endif
 536   1      }
 537          
 538          void KeyControl_Menu(void) //控件状态--Menu
 539          {
 540   1          switch (Ui_Status.Widget)
 541   1          {
 542   2          case CONTROL_PASSWORD_CHANGE:
 543   2          {
 544   3              if (!System_Parameter.PSWNext.First_Input_Flag)
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 10  

 545   3              {
 546   4      
 547   4                  InputOffect(&PassWordChange1);
 548   4              }
 549   3              else
 550   3              {
 551   4      
 552   4                  InputOffect(&PassWordChange2);
 553   4              }
 554   3      
 555   3              break;
 556   3          }
 557   2      
 558   2          default:
 559   2              break;
 560   2          }
 561   1      
 562   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Menu\r\n");
              #endif
 565   1      }
 566          
 567          void KeyControl_Cancel(void) //控件状态--Cancel
 568          {
 569   1          switch (Ui_Status.Widget)
 570   1          {
 571   2          case CONTROL_PASSWORD_CHANGE:
 572   2          {
 573   3              PassWordDelete(&PassWordChange1); //清0数据
 574   3                  PassWordDelete(&PassWordChange2);
 575   3              System_Parameter.PSWNext.First_Input_Flag = false;
 576   3              System_Parameter.PSWNext.Bit_Efficient_Flag = false;
 577   3              break;
 578   3          }
 579   2      
 580   2          case CONTROL_COMMUNICA:
 581   2          {
 582   3              // CommunciaIndex = CommunciaType; //如果没有确定,直接返回，则恢复当前状态索引
 583   3              break;
 584   3          }
 585   2      
 586   2          case CONTROL_BAUDSETTING:
 587   2          {
 588   3              // BaudWillIndex = BaudIndex; //如果没有确定,直接返回，则恢复当前状态索引
 589   3              break;
 590   3          }
 591   2           /*工作模式选择*/
 592   2          case CONTROL_WORKMODE:
 593   2          {
 594   3              SYS_TEMP_PARA.WorkMode = System_Parameter.WorkMode;
 595   3          }break;
 596   2          
 597   2          case CONTROL_RELOAD:
 598   2          {
 599   3              break;
 600   3          }
 601   2      
 602   2          default:
 603   2              break;
 604   2          }
 605   1      
 606   1          /*返回菜单界面*/
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 11  

 607   1          Ui_Status.Ui = MENU_STATE;
 608   1          LcdShow(RefreshMenuDisp); //显示设置
 609   1      
 610   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Cancel\r\n");
              #endif
 613   1      }
 614          
 615          /*控件状态--Up*/
 616          void KeyControl_Up(void)
 617          {
 618   1          switch (Ui_Status.Widget)
 619   1          {
 620   2          case CONTROL_PASSWORD_CHANGE:
 621   2          {
 622   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 623   3              {
 624   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange1);
 625   4                  uint8_t temp[2] = {0}; //字符
 626   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
 627   4              }
 628   3              else
 629   3              {
 630   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange2);
 631   4                  uint8_t temp[2] = {0}; //字符
 632   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 633   4              }
 634   3          }
 635   2          break;
 636   2      
 637   2          case CONTROL_COMMUNICA:
 638   2          {
 639   3              System_Parameter.CommunicationType ^= 1;
 640   3              LcdShow(CommunicaUIshow); //通讯设置界面
 641   3          }
 642   2          break;
 643   2      
 644   2          case CONTROL_BAUDSETTING:
 645   2          {
 646   3              /*箭头索引减小*/
 647   3              if ((M_Show[SEC0_MENU].Finger_Index--) == 0)
 648   3                  M_Show[SEC0_MENU].Finger_Index = 0;
 649   3      
 650   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(UPWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSize1
             -);
 651   3      
 652   3              if (M_Show[SEC0_MENU].Option_Index == (OptionlistSize1 - 1)) //索引逻辑
 653   3              {
 654   4                  M_Show[SEC0_MENU].Finger_Index = 2;
 655   4              }
 656   3              /*菜单滑动逻辑*/
 657   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 658   3              {
 659   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 660   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 661   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 662   4              }
 663   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 664   3              {
 665   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 666   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 667   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 12  

 668   4              }
 669   3              else
 670   3              {
 671   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 672   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
 673   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
 674   4              }
 675   3      
 676   3              LcdShow(RefreshBaudDisp);                                                   //刷新显示
 677   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 678   3          }
 679   2          break;
 680   2          /*本机热点设置*/
 681   2          case CONTROL_HOTSPOT:
 682   2          {
 683   3              System_Parameter.Apstate = LoopIndex(DOWMWORD, System_Parameter.Apstate, G_Aplist_Size);
 684   3              GUI_String(115, 10, Aplist[System_Parameter.Apstate].pstring, CH_12_12);
 685   3          }break;
 686   2          case CONTROL_WORKMODE:
 687   2          {
 688   3              SYS_TEMP_PARA.WorkMode = LoopIndex(DOWMWORD, SYS_TEMP_PARA.WorkMode, G_Modelist_Size);
 689   3              GUI_String(115, 10, Modelist[SYS_TEMP_PARA.WorkMode].pstring, CH_12_12);
 690   3          }break;
 691   2          default:
 692   2              break;
 693   2          }
 694   1      
 695   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Up\r\n");
              #endif
 698   1      }
 699          
 700          void KeyControl_Down(void) //控件状态--Down
 701          {
 702   1          switch (Ui_Status.Widget)
 703   1          {
 704   2          case CONTROL_PASSWORD_CHANGE:
 705   2          {
 706   3              if (!System_Parameter.PSWNext.First_Input_Flag)
 707   3              {
 708   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange1);
 709   4                  uint8_t temp[2] = {0}; //字符
 710   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
 711   4              }
 712   3              else
 713   3              {
 714   4      
 715   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange2);
 716   4                  uint8_t temp[2]= {0}; //字符
 717   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 718   4              }
 719   3          }
 720   2          break;
 721   2      
 722   2          case CONTROL_COMMUNICA:
 723   2          {
 724   3              System_Parameter.CommunicationType ^= 1;
 725   3              LcdShow(CommunicaUIshow); //通讯设置界面
 726   3          }
 727   2          break;
 728   2      
 729   2          case CONTROL_BAUDSETTING:
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 13  

 730   2          {
 731   3              if ((M_Show[SEC0_MENU].Finger_Index++) >= 2) //箭头索引增加
 732   3                  M_Show[SEC0_MENU].Finger_Index = 2;
 733   3      
 734   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSiz
             -e1); //选项索引
 735   3      
 736   3              if (M_Show[SEC0_MENU].Option_Index == 0) //索引逻辑
 737   3              {
 738   4                  M_Show[SEC0_MENU].Finger_Index = 0;
 739   4              }
 740   3      
 741   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 742   3              {
 743   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 744   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 745   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 746   4              }
 747   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 748   3              {
 749   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 750   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 751   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
 752   4              }
 753   3              else
 754   3              {
 755   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 756   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
 757   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
 758   4              }
 759   3              /*刷新当前选项卡*/
 760   3              LcdShow(RefreshBaudDisp);
 761   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 762   3          }
 763   2          break;
 764   2          /*本机热点设置*/
 765   2          case CONTROL_HOTSPOT:
 766   2          {
 767   3              System_Parameter.Apstate = LoopIndex(UPWORD, System_Parameter.Apstate, G_Aplist_Size);
 768   3              GUI_String(115, 10, Aplist[System_Parameter.Apstate].pstring, CH_12_12);
 769   3          }break;
 770   2          /*工作模式设置*/
 771   2          case CONTROL_WORKMODE:
 772   2          {
 773   3              SYS_TEMP_PARA.WorkMode = LoopIndex(UPWORD, SYS_TEMP_PARA.WorkMode, G_Modelist_Size);
 774   3              GUI_String(115, 10, Modelist[SYS_TEMP_PARA.WorkMode].pstring, CH_12_12);
 775   3          }break;
 776   2          default:
 777   2              break;
 778   2          }
 779   1      
 780   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Down\r\n");
              #endif
 783   1      }
 784          
 785          /*波特率控件状态--up*/
 786          void KeyBaud_Up(void)
 787          {
 788   1          switch (Ui_Status.Widget)
 789   1          {
 790   2          case CONTROL_BAUD1:
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 14  

 791   2          {
 792   3              System_Parameter.BaudIndex[0] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[0], G_BaudList_Size
             -);
 793   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 794   3          }
 795   2          break;
 796   2          case CONTROL_BAUD2:
 797   2          {
 798   3              System_Parameter.BaudIndex[1] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[1], G_BaudList_Size
             -);
 799   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 800   3          }
 801   2          break;
 802   2          case CONTROL_BAUD3:
 803   2          {
 804   3              System_Parameter.BaudIndex[2] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[2], G_BaudList_Size
             -);
 805   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 806   3          }
 807   2          break;
 808   2          case CONTROL_BAUD4:
 809   2          {
 810   3              System_Parameter.BaudIndex[3] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[3], G_BaudList_Size
             -);
 811   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
 812   3          }
 813   2          break;
 814   2          default:
 815   2              break;
 816   2          }
 817   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Up\r\n");
              #endif
 820   1      }
 821          
 822          /*波特率控件状态--Down*/
 823          void KeyBaud_Down(void)
 824          {
 825   1          switch (Ui_Status.Widget)
 826   1          {
 827   2          case CONTROL_BAUD1:
 828   2          {
 829   3              System_Parameter.BaudIndex[0] = LoopIndex(UPWORD, System_Parameter.BaudIndex[0], G_BaudList_Size);
 830   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 831   3          }
 832   2          break;
 833   2          case CONTROL_BAUD2:
 834   2          {
 835   3              System_Parameter.BaudIndex[1] = LoopIndex(UPWORD, System_Parameter.BaudIndex[1], G_BaudList_Size);
 836   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 837   3          }
 838   2          break;
 839   2          case CONTROL_BAUD3:
 840   2          {
 841   3              System_Parameter.BaudIndex[2] = LoopIndex(UPWORD, System_Parameter.BaudIndex[2], G_BaudList_Size);
 842   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 843   3          }
 844   2          break;
 845   2          case CONTROL_BAUD4:
 846   2          {
 847   3              System_Parameter.BaudIndex[3] = LoopIndex(UPWORD, System_Parameter.BaudIndex[3], G_BaudList_Size);
 848   3              GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 15  

 849   3          }
 850   2          break;
 851   2          default:
 852   2              break;
 853   2          }
 854   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Down\r\n");
              #endif
 857   1      }
 858          
 859          /*波特率控件状态--Enter*/
 860          void KeyBaud_Enter(void)
 861          {
 862   1          switch (Ui_Status.Widget)
 863   1          {
 864   2          case CONTROL_BAUD1:
 865   2          {
 866   3              SET_BRT1(1, Baudlist[System_Parameter.BaudIndex[0]].BaudValue);
 867   3              ControlSave();
 868   3      
 869   3              clear_screen();
 870   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 871   3              Delay_ms(500);
 872   3              /*修改成功后返回*/
 873   3              KeyBaud_Cancel();
 874   3          }
 875   2          break;
 876   2          case CONTROL_BAUD2:
 877   2          {
 878   3              SET_BRT1(2, Baudlist[System_Parameter.BaudIndex[1]].BaudValue);
 879   3              ControlSave();
 880   3      
 881   3              clear_screen();
 882   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 883   3              Delay_ms(500);
 884   3              /*修改成功后返回*/
 885   3              KeyBaud_Cancel();
 886   3          }
 887   2          break;
 888   2          case CONTROL_BAUD3:
 889   2          {
 890   3              SET_BRT1(3, Baudlist[System_Parameter.BaudIndex[2]].BaudValue);
 891   3              ControlSave();
 892   3      
 893   3              clear_screen();
 894   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 895   3              Delay_ms(500);
 896   3              /*修改成功后返回*/
 897   3              KeyBaud_Cancel();
 898   3          }
 899   2          break;
 900   2          case CONTROL_BAUD4:
 901   2          {
 902   3              SET_BRT1(4, Baudlist[System_Parameter.BaudIndex[3]].BaudValue);
 903   3              ControlSave();
 904   3      
 905   3              clear_screen();
 906   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 907   3              Delay_ms(500);
 908   3              // LcdShow(BaudSettingUI4show); //波特率设置界面
 909   3              /*修改成功后返回*/
 910   3              KeyBaud_Cancel();
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 16  

 911   3          }
 912   2          break;
 913   2          default:
 914   2              break;
 915   2          }
 916   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Enter\r\n");
              #endif
 919   1      }
 920          
 921          /*波特率控件状态--Cancel*/
 922          void KeyBaud_Cancel(void)
 923          { /*返回上级菜单界面*/
 924   1          Ui_Status.Ui = CONTROL_STATE;
 925   1          /*赋值控件*/
 926   1          Ui_Status.Widget = CONTROL_BAUDSETTING;
 927   1          LcdShow(RefreshBaudDisp);
 928   1      
 929   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Cancel\r\n");
              #endif
 932   1      }
 933          
 934          /*波特率控件状态--Menue*/
 935          void KeyBaud_Menu(void)
 936          {
 937   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Menu\r\n");
              #endif
 940   1      }
 941          
 942          /*一级菜单界面刷新显示*/
 943          void RefreshMenuDisp(void)
 944          {
 945   1          uint8_t i = 0;
 946   1          clear_screen(); //清屏
 947   1      
 948   1          for (; i < 3; i++)
 949   1          {
 950   2              GUI_String(70, 20 * i + 5, Optionlist[M_Show[MAIN_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 951   2          }
 952   1      
 953   1          GUI_Lattice(50, 6 + M_Show[MAIN_MENU].Finger_Index * 20, 16, 12, finger);
 954   1      }
 955          
 956          /*菜单界面下二级菜单刷新显示*/
 957          void RefreshBaudDisp(void)
 958          {
 959   1          uint8_t i = 0;
 960   1          clear_screen(); //清屏
 961   1      
 962   1          for (; i < 3U; i++)
 963   1          {
 964   2              GUI_String(70, 20 * i + 5, Optionlist1[M_Show[SEC0_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 965   2          }
 966   1      
 967   1          GUI_Lattice(50, 6 + M_Show[SEC0_MENU].Finger_Index * 20, 16, 12, finger);
 968   1      }
 969          
 970          /**
 971           * @brief       波特率设置二级菜单
 972           * @details
C51 COMPILER V9.60.0.0   MENU                                                              12/22/2021 16:04:17 PAGE 17  

 973           * @param       None
 974           * @retval      None
 975           */
 976          void Baud_Setting(void)
 977          {
 978   1          /*刷新界面*/
 979   1          LcdShow(RefreshBaudDisp);
 980   1          // /*切换到波特率设置界面*/
 981   1          // UI_STATE = BAUD_STATE;
 982   1          // /*无操作返回定时器开启*/
 983   1          // PublicTimer16.MenuDly16.Timer16Count = T_60S;
 984   1      }
 985          
 986          void LcdDly(KEY_e key)
 987          { /*如果已经在密码输入界面*/
 988   1          if (Ui_Status.Ui == MAIN_STATE)
 989   1          { /*并且当前控件为屏保，不启用定时器*/
 990   2              if (Ui_Status.Widget == CONTROL_SCREENSAVE)
 991   2                  return;
 992   2          }
 993   1      
 994   1          if (key == NO_KEY)
 995   1          {
 996   2              if (PublicTimer16.MenuDly16.Timer16Flag)
 997   2              {
 998   3                  PublicTimer16.MenuDly16.Timer16Flag = false;
 999   3                  Ui_Status.Ui = MAIN_STATE;
1000   3                  Ui_Status.Widget = CONTROL_SCREENSAVE;
1001   3                  /*屏保界面界面*/
1002   3                  LcdShow(&ScreensaverUiShow);
1003   3                  PassWordDelete(&PassWordI);
1004   3              }
1005   2          }
1006   1          else
1007   1          {
1008   2              PublicTimer16.MenuDly16.Timer16Count = T_60S;
1009   2          }
1010   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2948    ----
   CONSTANT SIZE    =    247    ----
   XDATA SIZE       =    197      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
