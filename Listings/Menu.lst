C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Objects\Menu.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\Menu.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Include;.\FreeModB
                    -us\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\Menu.lst) OBJECT(.\Objects\Menu.obj)

line level    source

   1          #include "Menu.h"
   2          
   3          /*当前UI界面状态*/
   4          SHOW_STATE UI_STATE = MAIN_STATE;
   5          
   6          /*菜单选项索引*/
   7          // uint8_t OptionIndex = 0;
   8          // /*菜单箭头索引*/
   9          // uint8_t fingerIndex = 0;
  10          // /*菜单显示索引数组 */
  11          // uint8_t M_Show[MAIN_MENU].OptionIndex_buf[3] = {0, 1, 2};
  12          
  13          // uint8_t M_Show[MAIN_MENU].OptionIndex_buf1[3] = {0, 1, 2};
  14          
  15          OPTION Optionlist[] =
  16          {
  17              {"启停开关", CONTROL_PLCPOWER, PlcPowerUIshow},
  18              {"通信方式", CONTROL_COMMUNICA, CommunicaUIshow},
  19              {"密码修改", CONTROL_PASSWORD_CHANGE, PassWordChangeUIShow},
  20              // {"波特率设置", CONTROL_BAUDSETTING, BaudSettingUIshow},
  21              {"波特率设置", CONTROL_BAUDSETTING, Baud_Setting},
  22              {"恢复出厂设置", CONTROL_RELOAD, ReloadSettingUIshow},
  23          };
  24          
  25          #define OptionlistSize (sizeof(Optionlist) / sizeof(OPTION))
  26          /*当前选项卡*/
  27          // OPTION *OptionNow = Optionlist;
  28          
  29          /*二级菜单*/
  30          OPTION Optionlist1[] =
  31          {
  32              {"以太网", CONTROL_BAUD1, BaudSettingUI1show},
  33              {"无线网", CONTROL_BAUD2, BaudSettingUI2show}, 
  34              {"扩展网", CONTROL_BAUD3, BaudSettingUI3show}, 
  35              {"内部网", CONTROL_BAUD4, BaudSettingUI4show}
  36          };
  37          
  38          #define OptionlistSize1 (sizeof(Optionlist1) / sizeof(OPTION))
  39          /*当前选项卡*/
  40          // OPTION *OptionNow1 = Optionlist1;
  41          
  42          /*当前多级菜单数量*/
  43          Menu_Show M_Show[] = 
  44          {
  45              {0, 0, 0, {1, 2, 3}, Optionlist}, 
  46              {0, 0, 0, {1, 2, 3}, Optionlist1}
  47          
  48          };
  49          
  50          #define MENU_NUM (sizeof(M_Show) / sizeof(Menu_Show))
  51          
  52          /*函数映射表*/
  53          const KEY_MAP keyStateEvent[] =
  54              {
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 2   

  55                  /*Main状态*/
  56                  {KEY_UP, MAIN_STATE, KeyMain_Up},
  57                  {KEY_DOWN, MAIN_STATE, KeyMain_Down},
  58                  {KEY_ENTER, MAIN_STATE, KeyMain_Enter},
  59                  {KEY_CANCEL, MAIN_STATE, KeyMain_Cancel},
  60                  {KEY_MENU, MAIN_STATE, KeyMain_Menu},
  61                  /*Menu状态*/
  62                  {KEY_UP, MENU_STATE, KeyMenu_Up},
  63                  {KEY_DOWN, MENU_STATE, KeyMenu_Down},
  64                  {KEY_ENTER, MENU_STATE, KeyMenu_Enter},
  65                  {KEY_CANCEL, MENU_STATE, KeyMenu_Cancel},
  66                  {KEY_MENU, MENU_STATE, KeyMenu_Menu},
  67                  /*CONTROL状态*/
  68                  {KEY_UP, CONTROL_STATE, KeyControl_Up},
  69                  {KEY_DOWN, CONTROL_STATE, KeyControl_Down},
  70                  {KEY_ENTER, CONTROL_STATE, KeyControl_Enter},
  71                  {KEY_CANCEL, CONTROL_STATE, KeyControl_Cancel},
  72                  {KEY_MENU, CONTROL_STATE, KeyControl_Menu},
  73                  /*BAUD状态*/
  74                  {KEY_UP, BAUD_STATE, KeyBaud_Up},
  75                  {KEY_DOWN, BAUD_STATE, KeyBaud_Down},
  76                  {KEY_ENTER, BAUD_STATE, KeyBaud_Enter},
  77                  {KEY_CANCEL, BAUD_STATE, KeyBaud_Cancel},
  78                  {KEY_MENU, BAUD_STATE, KeyBaud_Menu}
  79          };
  80          
  81          #define keyStateEventSize (sizeof(keyStateEvent) / sizeof(KEY_MAP))
  82          
  83          void KeyEvent(void) //按键事件
  84          {
  85   1          uint8_t i;
  86   1          KEY_e KeyState = Key_Chick(); //获取按键状态
  87   1      
  88   1          LcdDly(KeyState); // 无按键操作返回函数
  89   1      
  90   1          if (KeyState == NO_KEY) //无按键直接返回
  91   1          {
  92   2              return;
  93   2          }
  94   1      
  95   1          for (i = 0; i < keyStateEventSize; i++)
  96   1          {
  97   2              if (KeyState == keyStateEvent[i].Keycodel) //按键值
  98   2              {
  99   3                  if (UI_STATE == keyStateEvent[i].Stage) //按键状态
 100   3                  {
 101   4                      keyStateEvent[i].fun(); //执行按键状态对应函数
 102   4                      break;
 103   4                  }
 104   3              }
 105   2          }
 106   1      }
 107          
 108          void LcdShowInit(void) //界面显示初始化
 109          {
 110   1          LcdShow(&ScreensaverUiShow);
 111   1      }
 112          
 113          void LcdShow(pshow InterfaceShow) //界面显示接口(回调函数思想)
 114          {
 115   1          InterfaceShow();
 116   1      }
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 3   

 117          
 118          /**
 119           * @brief       主界面状态--enter
 120           * @details     在主界面下按下enter按钮
 121           * @param       None
 122           * @retval      None
 123           */
 124          void KeyMain_Enter(void)
 125          {
 126   1      #if USE_PRINTF_DEBUG
                  uint8_t temp = strncmp(System_Parameter.PSWNext.PassWordbuff, "\xFF\xFF\xFF\xFF", PASSWORDBITS);
              #endif
 129   1          if (ControlType == CONTROL_PASSWORD)
 130   1          {
 131   2              /*没有设置过密码或者密码正确*/
 132   2              if (PassWordjudge(PassWordI, System_Parameter) || (!strncmp(System_Parameter.PSWNext.PassWordbuff,
             - "\xFF\xFF\xFF\xFF", PASSWORDBITS)))
 133   2              {
 134   3                  LcdShow(RefreshMenuDisp); //刷新界面
 135   3                  UI_STATE = MENU_STATE;
 136   3                  // PublicTimer16.MenuDly16.Timer16Count = T_60S; //无操作返回定时器开启
 137   3              }
 138   2              else //如果密码错误
 139   2              {
 140   3                  PassWordDelete(&PassWordI);
 141   3                  clear_screen();
 142   3                  GUI_String(49, 31, "wrong password !", EN_5_8);
 143   3                  Delay_ms(1000);
 144   3                  LcdShow(PassWordInputUIShow); //重新输入
 145   3              }
 146   2          }
 147   1      
 148   1      #if USE_PRINTF_DEBUG
                  Uartx_SendStr(&Uart1, System_Parameter.PSWNext.PassWordbuff, 4);
                  Uartx_SendStr(&Uart1, &temp, 1);
                  printf("KeyMain_Enter\r\n");
              #endif
 153   1      }
 154          
 155          void KeyMain_Up(void) //主界面状态--Up
 156          {
 157   1          if (ControlType == CONTROL_PASSWORD) //密码控件
 158   1          {
 159   2              uint8_t Value = PassWordInput(ADD, &PassWordI);
 160   2              uint8_t temp[2]; //字符
 161   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 162   2          }
 163   1      
 164   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Up\r\n");
              #endif
 167   1      }
 168          /*屏保界面到密码输入界面切换*/
 169          void KeyMain_Menu(void) //主界面状态--Menu
 170          {
 171   1          switch (ControlType)
 172   1          {
 173   2          case CONTROL_SCREENSAVE:
 174   2          {
 175   3              /*切换到密码界面*/
 176   3              ControlType = CONTROL_PASSWORD;
 177   3              LcdShow(&PassWordInputUIShow);
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 4   

 178   3              /*无操作返回定时器开启*/
 179   3              PublicTimer16.MenuDly16.Timer16Count = T_60S;
 180   3          }
 181   2          break;
 182   2          case CONTROL_PASSWORD:
 183   2          { /*改变当前密码输入位置*/
 184   3              InputOffect(&PassWordI);
 185   3          }
 186   2          break;
 187   2          default:
 188   2              break;
 189   2          }
 190   1      
 191   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Menu\r\n");
              #endif
 194   1      }
 195          
 196          void KeyMain_Cancel(void) //主界面状态--Cancel
 197          {
 198   1          /*主界面按下取消键，退到屏保界面*/
 199   1          if (ControlType == CONTROL_PASSWORD)
 200   1          {
 201   2              LcdShow(&ScreensaverUiShow);
 202   2              PassWordDelete(&PassWordI);
 203   2          }
 204   1      
 205   1      #if USE_PRINTF_DEBUG
                  printf("%s\r\n", System_Parameter.PSWNext.PassWordbuff); //防止忘记密码之后进不去PLC
              #endif
 208   1      }
 209          
 210          void KeyMain_Down(void) //主界面状态--Down
 211          {
 212   1          if (ControlType == CONTROL_PASSWORD)
 213   1          {
 214   2              uint8_t Value = PassWordInput(SUB, &PassWordI);
 215   2              uint8_t temp[2]; //字符
 216   2              GUI_String(PassWordI.PSWNext.Index * 20 + 97, 38, myitoa(Value, temp, 10), EN_5_8);
 217   2          }
 218   1      
 219   1      #if USE_PRINTF_DEBUG
                  printf("KeyMain_Down\r\n");
              #endif
 222   1      }
 223          
 224          void KeyMenu_Enter(void) //菜单状态--Enter
 225          {
 226   1          if (M_Show[MAIN_MENU].OptionNow->ControlShow == NULL)
 227   1          {
 228   2              return;
 229   2          }
 230   1      
 231   1          UI_STATE = CONTROL_STATE;
 232   1          ControlType = M_Show[MAIN_MENU].OptionNow->ControlType; //赋值控件
 233   1          LcdShow(M_Show[MAIN_MENU].OptionNow->ControlShow);      //显示控制界面
 234   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Enter\r\n");
              #endif
 237   1      }
 238          
 239          /*菜单状态--Up*/
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 5   

 240          void KeyMenu_Up(void) 
 241          {
 242   1          /*箭头索引减小*/
 243   1          if ((M_Show[MAIN_MENU].Finger_Index--) == 0) 
 244   1              M_Show[MAIN_MENU].Finger_Index = 0;
 245   1      
 246   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(UPWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize);
 247   1      
 248   1          if (M_Show[MAIN_MENU].Option_Index == (OptionlistSize - 1)) //索引逻辑
 249   1          {
 250   2              M_Show[MAIN_MENU].Finger_Index = 2;
 251   2          }
 252   1          /*菜单滑动逻辑*/
 253   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
 254   1          {
 255   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
 256   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 257   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 258   2          }
 259   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 260   1          {
 261   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 262   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 263   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 264   2          }
 265   1          else
 266   1          {
 267   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 268   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 269   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 270   2          }
 271   1      
 272   1          LcdShow(RefreshMenuDisp);             //刷新显示
 273   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 274   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Up\r\n");
              #endif
 277   1      }
 278          
 279          /*菜单状态--Menu*/
 280          void KeyMenu_Menu(void) 
 281          {
 282   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Menu\r\n");
              #endif
 285   1      }
 286          
 287          void KeyMenu_Cancel(void) //菜单状态--Cancel
 288          {
 289   1          /*菜单界面按下取消键，直接锁屏*/
 290   1          UI_STATE = MAIN_STATE;
 291   1          ControlType = CONTROL_SCREENSAVE;
 292   1          LcdShow(&ScreensaverUiShow);
 293   1          PassWordDelete(&PassWordI);
 294   1      
 295   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Cancel\r\n");
              #endif
 298   1      }
 299          
 300          void KeyMenu_Down(void) //菜单状态--Down
 301          {
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 6   

 302   1          if ((M_Show[MAIN_MENU].Finger_Index++) == 2) //箭头索引增加
 303   1              M_Show[MAIN_MENU].Finger_Index = 2;
 304   1      
 305   1          M_Show[MAIN_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[MAIN_MENU].Option_Index, OptionlistSize); 
             -//选项索引
 306   1      
 307   1          if (M_Show[MAIN_MENU].Option_Index == 0) //索引逻辑
 308   1          {
 309   2              M_Show[MAIN_MENU].Finger_Index = 0;
 310   2          }
 311   1      
 312   1          if (M_Show[MAIN_MENU].Finger_Index == 0)
 313   1          {
 314   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index;
 315   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index + 1;
 316   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 2;
 317   2          }
 318   1          else if (M_Show[MAIN_MENU].Finger_Index == 1)
 319   1          {
 320   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 1;
 321   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index;
 322   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index + 1;
 323   2          }
 324   1          else
 325   1          {
 326   2              M_Show[MAIN_MENU].OptionIndex_buf[0] = M_Show[MAIN_MENU].Option_Index - 2;
 327   2              M_Show[MAIN_MENU].OptionIndex_buf[1] = M_Show[MAIN_MENU].Option_Index - 1;
 328   2              M_Show[MAIN_MENU].OptionIndex_buf[2] = M_Show[MAIN_MENU].Option_Index;
 329   2          }
 330   1      
 331   1          LcdShow(RefreshMenuDisp);             //刷新显示
 332   1          M_Show[MAIN_MENU].OptionNow = &Optionlist[M_Show[MAIN_MENU].Option_Index]; //赋值当前选项
 333   1      
 334   1      #if USE_PRINTF_DEBUG
                  printf("KeyMenu_Down\r\n");
              #endif
 337   1      }
 338          
 339          void KeyControl_Enter(void) //控件状态--Enter
 340          {
 341   1          switch (ControlType)
 342   1          {
 343   2          case CONTROL_PASSWORD_CHANGE:
 344   2          {
 345   3              if (PassWordFirstChangeFlag == 0) //如果是第一次输入修改密码
 346   3              {
 347   4                  uint8_t i;
 348   4                  uint8_t temp[2];
 349   4      
 350   4                  for (i = 0; i < PASSWORDBITS; i++) //显示4位密码
 351   4                  {
 352   5                      GUI_String(i * 20 + 100, 18, myitoa(PassWordChange1.PSWNext.PassWordbuff[i], temp, 10), EN
             -_5_8);
 353   5                  }
 354   4      
 355   4                  GUI_Lattice(175, 16, 16, 12, dot);
 356   4                  PassWordFirstChangeFlag = 1; //置标志位
 357   4              }
 358   3              else
 359   3              {
 360   4      
 361   4                  if (PassWordjudge(PassWordChange1, PassWordChange2)) //密码判断两次输入相同密码时修改成功
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 7   

 362   4                  {
 363   5                      memcpy(&System_Parameter.PSWNext.PassWordbuff, &PassWordChange2.PSWNext.PassWordbuff, size
             -of(PassWordChange2.PSWNext.PassWordbuff));
 364   5                      ControlSave();
 365   5                      PassWordDelete(&PassWordChange1); //修改密码1清0
 366   5                      PassWordDelete(&PassWordChange2); //修改密码2清0
 367   5                      UI_STATE = MENU_STATE;            //返回菜单界面
 368   5      
 369   5                      clear_screen();
 370   5                      GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 371   5                      Delay_ms(500);
 372   5                      LcdShow(RefreshMenuDisp); //刷新显示
 373   5                  }
 374   4                  else //两次密码输入不一致时
 375   4                  {
 376   5      
 377   5                      clear_screen();
 378   5                      GUI_String(70, 22, "修改失败", CH_12_12); //显示修改结果
 379   5                      Delay_ms(500);
 380   5                      LcdShow(PassWordChangeUIShow); //修改密码
 381   5                  }
 382   4      
 383   4                  PassWordFirstChangeFlag = 0; //置0标志位
 384   4              }
 385   3      
 386   3              break;
 387   3          }
 388   2      
 389   2          case CONTROL_PLCPOWER:
 390   2          {
 391   3              System_Parameter.PlcState ^= 1;
 392   3              RUNKEY = System_Parameter.PlcState;
 393   3              ControlSave();           //存盘开关量
 394   3              LcdShow(PlcPowerUIshow); // PLC设置界面
 395   3              break;
 396   3          }
 397   2      
 398   2          case CONTROL_COMMUNICA:
 399   2          {
 400   3              if (System_Parameter.CommunicationType == LOCAL)
 401   3              {
 402   4                  Wifi_Enable(false);
 403   4              }
 404   3              else
 405   3              {
 406   4                  Wifi_Enable(true);
 407   4                  clear_screen();
 408   4                  GUI_String(30, 22, "Please wait a moment", EN_5_8);
 409   4                  // /*初始化WIIF模块*/
 410   4                  // Wifi_Init();
 411   4              }
 412   3              ControlSave(); //存盘通信方式
 413   3      
 414   3              clear_screen();
 415   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 416   3              Delay_ms(500);
 417   3              LcdShow(CommunicaUIshow); //通讯设置界面
 418   3              break;
 419   3          }
 420   2      
 421   2          case CONTROL_BAUDSETTING:
 422   2          {
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 8   

 423   3              if (M_Show[SEC0_MENU].OptionNow->ControlShow == NULL)
 424   3              {
 425   4                  return;
 426   4              }
 427   3                  /*切换到波特率设置界面*/
 428   3                  UI_STATE = BAUD_STATE;
 429   3              /*赋值控件*/
 430   3              ControlType = M_Show[SEC0_MENU].OptionNow->ControlType; 
 431   3              /*显示控制界面*/
 432   3              LcdShow(M_Show[SEC0_MENU].OptionNow->ControlShow);      
 433   3                  /*无操作返回定时器开启*/
 434   3                  // PublicTimer16.MenuDly16.Timer16Count = T_60S; 
 435   3          } break;
 436   2          /*恢复出厂设置*/
 437   2          case CONTROL_RELOAD:
 438   2          {
 439   3              // novalueflag = true;
 440   3              CLOSE_GLOBAL_OUTAGE();
 441   3              IapErase(START_SAVEADDRESS); //擦除密码区
 442   3                                           /*把默认参数拷贝到当前数据结构*/
 443   3              memcpy(&System_Parameter.PSWNext.PassWordbuff[0], DEFAULT_SYSTEM_PARAMETER, (sizeof(System_Paramet
             -er) - 1U));
 444   3              /*把数据进行存储*/
 445   3              IapWrite_Buff(START_SAVEADDRESS, &System_Parameter.PSWNext.PassWordbuff[0], (sizeof(System_Paramet
             -er) - 1U)); //使密码界面失效
 446   3              OPEN_GLOBAL_OUTAGE();
 447   3      
 448   3              BaudInit();
 449   3              // PassWordinit();
 450   3              PowerInit();
 451   3              CommunicaInit();
 452   3              UI_STATE = MENU_STATE; //返回菜单界面
 453   3      
 454   3              clear_screen();
 455   3              GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 456   3              Delay_ms(500);
 457   3              LcdShow(RefreshMenuDisp); //刷新显示
 458   3              break;
 459   3          }
 460   2      
 461   2          default:
 462   2              break;
 463   2          }
 464   1      
 465   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Enter\r\n");
              #endif
 468   1      }
 469          
 470          void KeyControl_Menu(void) //控件状态--Menu
 471          {
 472   1          switch (ControlType)
 473   1          {
 474   2          case CONTROL_PASSWORD_CHANGE:
 475   2          {
 476   3              if (PassWordFirstChangeFlag == 0)
 477   3              {
 478   4      
 479   4                  InputOffect(&PassWordChange1);
 480   4              }
 481   3              else
 482   3              {
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 9   

 483   4      
 484   4                  InputOffect(&PassWordChange2);
 485   4              }
 486   3      
 487   3              break;
 488   3          }
 489   2      
 490   2          default:
 491   2              break;
 492   2          }
 493   1      
 494   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Menu\r\n");
              #endif
 497   1      }
 498          
 499          void KeyControl_Cancel(void) //控件状态--Cancel
 500          {
 501   1          switch (ControlType)
 502   1          {
 503   2          case CONTROL_PASSWORD_CHANGE:
 504   2          {
 505   3              break;
 506   3          }
 507   2      
 508   2          case CONTROL_COMMUNICA:
 509   2          {
 510   3              // CommunciaIndex = CommunciaType; //如果没有确定,直接返回，则恢复当前状态索引
 511   3              break;
 512   3          }
 513   2      
 514   2          case CONTROL_BAUDSETTING:
 515   2          {
 516   3              // BaudWillIndex = BaudIndex; //如果没有确定,直接返回，则恢复当前状态索引
 517   3              break;
 518   3          }
 519   2      
 520   2          case CONTROL_RELOAD:
 521   2          {
 522   3              break;
 523   3          }
 524   2      
 525   2          default:
 526   2              break;
 527   2          }
 528   1      
 529   1          UI_STATE = MENU_STATE;    //返回菜单界面
 530   1          LcdShow(RefreshMenuDisp); //显示设置
 531   1      
 532   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Cancel\r\n");
              #endif
 535   1      }
 536          
 537          /*控件状态--Up*/
 538          void KeyControl_Up(void) 
 539          {
 540   1          switch (ControlType)
 541   1          {
 542   2          case CONTROL_PASSWORD_CHANGE:
 543   2          {
 544   3              if (PassWordFirstChangeFlag == 0)
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 10  

 545   3              {
 546   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange1);
 547   4                  uint8_t temp[2]; //字符
 548   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
 549   4              }
 550   3              else
 551   3              {
 552   4                  uint8_t Value = PassWordInput(ADD, &PassWordChange2);
 553   4                  uint8_t temp[2]; //字符
 554   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 555   4              }  
 556   3          }break;
 557   2      
 558   2          case CONTROL_COMMUNICA:
 559   2          {
 560   3              System_Parameter.CommunicationType ^= 1;
 561   3              LcdShow(CommunicaUIshow); //通讯设置界面
 562   3          }break;
 563   2      
 564   2          case CONTROL_BAUDSETTING:
 565   2          {
 566   3              /*箭头索引减小*/
 567   3              if ((M_Show[SEC0_MENU].Finger_Index--) == 0) 
 568   3                  M_Show[SEC0_MENU].Finger_Index = 0;
 569   3      
 570   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(UPWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSize1
             -);
 571   3      
 572   3              if (M_Show[SEC0_MENU].Option_Index == (OptionlistSize1 - 1)) //索引逻辑
 573   3              {
 574   4                  M_Show[SEC0_MENU].Finger_Index = 2;
 575   4              }
 576   3              /*菜单滑动逻辑*/
 577   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 578   3              {
 579   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 580   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 581   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 582   4              }
 583   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 584   3              {
 585   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 586   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 587   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
 588   4              }
 589   3              else
 590   3              {
 591   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 592   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
 593   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
 594   4              }
 595   3      
 596   3              LcdShow(RefreshBaudDisp);             //刷新显示
 597   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 598   3          }break;
 599   2      
 600   2          default:
 601   2              break;
 602   2          }
 603   1      
 604   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Up\r\n");
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 11  

              #endif
 607   1      }
 608          
 609          void KeyControl_Down(void) //控件状态--Down
 610          {
 611   1          switch (ControlType)
 612   1          {
 613   2          case CONTROL_PASSWORD_CHANGE:
 614   2          {
 615   3              if (PassWordFirstChangeFlag == 0)
 616   3              {
 617   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange1);
 618   4                  uint8_t temp[2]; //字符
 619   4                  GUI_String(PassWordChange1.PSWNext.Index * 20 + 100, 18, myitoa(Value, temp, 10), EN_5_8);
 620   4              }
 621   3              else
 622   3              {
 623   4      
 624   4                  uint8_t Value = PassWordInput(SUB, &PassWordChange2);
 625   4                  uint8_t temp[2]; //字符
 626   4                  GUI_String(PassWordChange2.PSWNext.Index * 20 + 100, 38, myitoa(Value, temp, 10), EN_5_8);
 627   4              }
 628   3      
 629   3          }break;
 630   2      
 631   2          case CONTROL_COMMUNICA:
 632   2          {
 633   3              System_Parameter.CommunicationType ^= 1;
 634   3              LcdShow(CommunicaUIshow); //通讯设置界面
 635   3              
 636   3          }break;
 637   2      
 638   2          case CONTROL_BAUDSETTING:
 639   2          {   
 640   3              if ((M_Show[SEC0_MENU].Finger_Index++) >= 2) //箭头索引增加
 641   3              M_Show[SEC0_MENU].Finger_Index = 2;
 642   3      
 643   3              M_Show[SEC0_MENU].Option_Index = LoopIndex(DOWMWORD, M_Show[SEC0_MENU].Option_Index, OptionlistSiz
             -e1); //选项索引
 644   3      
 645   3              if (M_Show[SEC0_MENU].Option_Index == 0) //索引逻辑
 646   3              {
 647   4                  M_Show[SEC0_MENU].Finger_Index = 0;
 648   4              }
 649   3      
 650   3              if (M_Show[SEC0_MENU].Finger_Index == 0)
 651   3              {
 652   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index;
 653   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index + 1;
 654   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 2;
 655   4              }
 656   3              else if (M_Show[SEC0_MENU].Finger_Index == 1)
 657   3              {
 658   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 1;
 659   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index;
 660   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index + 1;
 661   4              }
 662   3              else
 663   3              {
 664   4                  M_Show[SEC0_MENU].OptionIndex_buf[0] = M_Show[SEC0_MENU].Option_Index - 2;
 665   4                  M_Show[SEC0_MENU].OptionIndex_buf[1] = M_Show[SEC0_MENU].Option_Index - 1;
 666   4                  M_Show[SEC0_MENU].OptionIndex_buf[2] = M_Show[SEC0_MENU].Option_Index;
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 12  

 667   4              }
 668   3              /*刷新当前选项卡*/
 669   3              LcdShow(RefreshBaudDisp);             
 670   3              M_Show[SEC0_MENU].OptionNow = &Optionlist1[M_Show[SEC0_MENU].Option_Index]; //赋值当前选项
 671   3          }break;
 672   2      
 673   2          default:
 674   2              break;
 675   2          }
 676   1      
 677   1      #if USE_PRINTF_DEBUG
                  printf("KeyControl_Down\r\n");
              #endif
 680   1      }
 681          
 682          /*波特率控件状态--up*/
 683          void KeyBaud_Up(void)
 684          {
 685   1          switch (ControlType)
 686   1          {
 687   2              case CONTROL_BAUD1:
 688   2              {
 689   3                  System_Parameter.BaudIndex[0] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[0], G_BaudList_
             -Size);
 690   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 691   3              }break;
 692   2              case CONTROL_BAUD2:
 693   2              {
 694   3                  System_Parameter.BaudIndex[1] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[1], G_BaudList_
             -Size);
 695   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 696   3              }break;
 697   2              case CONTROL_BAUD3:
 698   2              {
 699   3                  System_Parameter.BaudIndex[2] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[2], G_BaudList_
             -Size);
 700   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 701   3              }break;
 702   2              case CONTROL_BAUD4:
 703   2              {
 704   3                  System_Parameter.BaudIndex[3] = LoopIndex(DOWMWORD, System_Parameter.BaudIndex[3], G_BaudList_
             -Size);
 705   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
 706   3              }break;
 707   2              default : break;
 708   2          }
 709   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Up\r\n");
              #endif
 712   1      }
 713          
 714          /*波特率控件状态--Down*/
 715          void KeyBaud_Down(void)
 716          {
 717   1          switch (ControlType)
 718   1          {
 719   2              case CONTROL_BAUD1:
 720   2              {
 721   3                  System_Parameter.BaudIndex[0] = LoopIndex(UPWORD, System_Parameter.BaudIndex[0], G_BaudList_Si
             -ze);
 722   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[0]].pstring, EN_5_8);
 723   3              }break;
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 13  

 724   2              case CONTROL_BAUD2:
 725   2              {
 726   3                  System_Parameter.BaudIndex[1] = LoopIndex(UPWORD, System_Parameter.BaudIndex[1], G_BaudList_Si
             -ze);
 727   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[1]].pstring, EN_5_8);
 728   3              }break;
 729   2              case CONTROL_BAUD3:
 730   2              {
 731   3                  System_Parameter.BaudIndex[2] = LoopIndex(UPWORD, System_Parameter.BaudIndex[2], G_BaudList_Si
             -ze);
 732   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[2]].pstring, EN_5_8);
 733   3              }break;
 734   2              case CONTROL_BAUD4:
 735   2              {
 736   3                  System_Parameter.BaudIndex[3] = LoopIndex(UPWORD, System_Parameter.BaudIndex[3], G_BaudList_Si
             -ze);
 737   3                  GUI_String(105, 31, Baudlist[System_Parameter.BaudIndex[3]].pstring, EN_5_8);
 738   3              }break;
 739   2              default : break;
 740   2          }
 741   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Down\r\n");
              #endif
 744   1      }
 745          
 746          /*波特率控件状态--Enter*/
 747          void KeyBaud_Enter(void)
 748          {
 749   1          switch (ControlType)
 750   1          {
 751   2              case CONTROL_BAUD1:
 752   2              {
 753   3                  SET_BRT1(1, Baudlist[System_Parameter.BaudIndex[0]].BaudValue);
 754   3                  ControlSave();
 755   3      
 756   3                  clear_screen();
 757   3                  GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 758   3                  Delay_ms(500);
 759   3                  LcdShow(BaudSettingUI1show); //波特率设置界面
 760   3              }break;
 761   2              case CONTROL_BAUD2:
 762   2              {
 763   3                  SET_BRT1(2, Baudlist[System_Parameter.BaudIndex[1]].BaudValue);
 764   3                  ControlSave();
 765   3      
 766   3                  clear_screen();
 767   3                  GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 768   3                  Delay_ms(500);
 769   3                  LcdShow(BaudSettingUI2show); //波特率设置界面
 770   3              }break;
 771   2              case CONTROL_BAUD3:
 772   2              {
 773   3                  SET_BRT1(3, Baudlist[System_Parameter.BaudIndex[2]].BaudValue);
 774   3                  ControlSave();
 775   3      
 776   3                  clear_screen();
 777   3                  GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 778   3                  Delay_ms(500);
 779   3                  LcdShow(BaudSettingUI3show); //波特率设置界面
 780   3              }break;
 781   2              case CONTROL_BAUD4:
 782   2              {
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 14  

 783   3                  SET_BRT1(4, Baudlist[System_Parameter.BaudIndex[3]].BaudValue);
 784   3                  ControlSave();
 785   3      
 786   3                  clear_screen();
 787   3                  GUI_String(70, 22, "修改成功", CH_12_12); //显示修改结果
 788   3                  Delay_ms(500);
 789   3                  LcdShow(BaudSettingUI4show); //波特率设置界面
 790   3              }break;
 791   2              default : break;
 792   2          }
 793   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Enter\r\n");
              #endif
 796   1      }
 797          
 798          /*波特率控件状态--Cancel*/
 799          void KeyBaud_Cancel(void)
 800          {   /*返回上级菜单界面*/
 801   1          UI_STATE = CONTROL_BAUDSETTING;   
 802   1          LcdShow(RefreshBaudDisp);
 803   1      
 804   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Cancel\r\n");
              #endif
 807   1      }
 808          
 809          /*波特率控件状态--Menue*/
 810          void KeyBaud_Menu(void)
 811          {
 812   1      #if USE_PRINTF_DEBUG
                  printf("KeyBaud_Menu\r\n");
              #endif
 815   1      }
 816          
 817          /*一级菜单界面刷新显示*/
 818          void RefreshMenuDisp(void) 
 819          {
 820   1          uint8_t i = 0;
 821   1          clear_screen(); //清屏
 822   1      
 823   1          for (; i < 3; i++)
 824   1          {
 825   2              GUI_String(70, 20 * i + 5, Optionlist[M_Show[MAIN_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 826   2          }
 827   1      
 828   1          GUI_Lattice(50, 6 + M_Show[MAIN_MENU].Finger_Index * 20, 16, 12, finger);
 829   1      }
 830          
 831          /*菜单界面下二级菜单刷新显示*/
 832          void RefreshBaudDisp(void)
 833          {
 834   1          uint8_t i = 0;
 835   1          clear_screen(); //清屏
 836   1      
 837   1          for (; i < 3U; i++)
 838   1          {
 839   2              GUI_String(70, 20 * i + 5, Optionlist1[M_Show[SEC0_MENU].OptionIndex_buf[i]].pString, CH_12_12);
 840   2          }
 841   1      
 842   1          GUI_Lattice(50, 6 + M_Show[SEC0_MENU].Finger_Index * 20, 16, 12, finger);
 843   1      }
 844          
C51 COMPILER V9.60.0.0   MENU                                                              10/27/2021 11:44:19 PAGE 15  

 845          /**
 846           * @brief       波特率设置二级菜单
 847           * @details     
 848           * @param       None
 849           * @retval      None
 850           */
 851          void Baud_Setting(void)
 852          {
 853   1              /*刷新界面*/
 854   1              LcdShow(RefreshBaudDisp); 
 855   1              // /*切换到波特率设置界面*/
 856   1              // UI_STATE = BAUD_STATE;
 857   1              // /*无操作返回定时器开启*/
 858   1              // PublicTimer16.MenuDly16.Timer16Count = T_60S; 
 859   1      }
 860          
 861          
 862          void LcdDly(KEY_e key)
 863          { /*如果已经在密码输入界面*/
 864   1          if (UI_STATE == MAIN_STATE)
 865   1          { /*并且当前控件为屏保，不启用定时器*/
 866   2              if (ControlType == CONTROL_SCREENSAVE)
 867   2                  return;
 868   2          }
 869   1      
 870   1          if (key == NO_KEY)
 871   1          {
 872   2              if (PublicTimer16.MenuDly16.Timer16Flag)
 873   2              {
 874   3                  PublicTimer16.MenuDly16.Timer16Flag = false;
 875   3                  UI_STATE = MAIN_STATE;
 876   3                  ControlType = CONTROL_SCREENSAVE;
 877   3                  /*屏保界面界面*/
 878   3                  LcdShow(&ScreensaverUiShow);
 879   3                  PassWordDelete(&PassWordI);
 880   3              }
 881   2          }
 882   1          else
 883   1          {
 884   2              PublicTimer16.MenuDly16.Timer16Count = T_60S;
 885   2          }
 886   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2465    ----
   CONSTANT SIZE    =    154    ----
   XDATA SIZE       =    182      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
