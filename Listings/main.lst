C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2023 11:28:22 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\main.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeModBu
                    -s\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          //#include "config.h"
   2          #include "Menu.h"
   3          #include "timer.h"
   4          #include "usart.h"
   5          //#include "systemTimer.h"
   6          #include "eeprom.h"
   7          #include "GPIO.h"
   8          #include "LCD.h"
   9          #include "Key.h"
  10          #include "Control.h"
  11          #include "pFunc.h"
  12          #include "report.h"
  13          #include "mdrtuslave.h"
  14          #include "wifi.h"
  15          
  16          /*系统参数*/
  17          SYSTEM_PARAMETER System_Parameter = {0, false, false, "\xFF\xFF\xFF\xFF", "\x08\x08\x02\x08", 0x01, 0x01, 
             -0x00, 0x00, 0x01, 0x02, 0x00, 0xF116};
  18          
  19          static void systemInit(void);
  20          static void UsartHandle(void);
  21          static void Iap_Flash_Iinit(void);
  22          
  23          /*定义一个静态内存池*/
  24          // uint8_t mempool[5U * 1024] = {0};
  25          
  26          void main(void)
  27          {   
  28   1              /*注意传递的是数组名地址*/
  29   1          // init_mempool (mempool, sizeof(mempool)); 
  30   1          systemInit(); //系统初始化
  31   1      #if USING_WDT
  32   1          WDT_CONTR = 0x27; //使能看门狗，复位时间约为4s
  33   1      #endif
  34   1          while(1)
  35   1          {   /*按键*/
  36   2                      KeyEvent(); 
  37   2                      /*多串口数据处理*/
  38   2                      Uart_Handle();
  39   2                      /*ModBus接收数据处理*/
  40   2      //        mdRTU_Handler();
  41   2      #if USING_WDT
  42   2              WDT_CONTR |= 0x10; //喂狗
  43   2      #endif
  44   2          }
  45   1      }
  46          
  47          void systemInit(void)
  48          {
  49   1          Init_All(); //初始化外设
  50   1              /*AUXR初始值为0x01，存在bug导致串口1和串口2共用同一个波特率发生器*/
  51   1              AUXR = 0x00;
  52   1              /***********************************************************************/
  53   1          //以太网串口结构体初始化
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2023 11:28:22 PAGE 2   

  54   1          // Init_ListQueue(&COM_UART1);
  55   1              memset(&COM_UART1,  0, sizeof(COM_UART1));
  56   1              
  57   1              // 4G串口结构体初始化
  58   1          // Init_ListQueue(&COM_UART2);
  59   1              memset(&COM_UART2, 0, sizeof(COM_UART2));
  60   1              
  61   1              // RS485串口结构体初始化
  62   1          // Init_ListQueue(&COM_UART3);
  63   1              memset(&COM_UART3, 0, sizeof(COM_UART3));
  64   1              
  65   1              // PLC串口结构体初始化
  66   1          // Init_ListQueue(&COM_UART4);
  67   1              memset(&COM_UART4, 0, sizeof(COM_UART4));
  68   1      
  69   1              /***********************************************************************/
  70   1              /*液晶屏初始化*/
  71   1          initial_lcd();  
  72   1          /*系统参数存储区初始化*/
  73   1          Iap_Flash_Iinit();
  74   1          /*以下为系统滴答定时器的初始化（10ms （不建议更改））*/      
  75   1          Timer0_Init();
  76   1          PublicTimer16.MenuDly16.Timer16Flag = false;
  77   1          // /*控件变量初始化,放在串口3初始化之前*/
  78   1          // ControlInit();   
  79   1      #if !USING_SIMULATE
  80   1          /*STC程序下载/printf/以太网*/
  81   1          Uart1_Init(); 
  82   1      #endif
  83   1          /*4G模块*/
  84   1          Uart2_Init(); 
  85   1          /*RS485*/
  86   1          Uart3_Init(); 
  87   1          /*PLC*/
  88   1          Uart4_Init(); 
  89   1          /*串口3的485使能引脚，初始化为接收状态*/
  90   1          USART3_EN = 0; 
  91   1          /*控件变量初始化,放在串口3初始化之前*/
  92   1          ControlInit();
  93   1          /*打开全局中断*/
  94   1          OPEN_GLOBAL_OUTAGE(); 
  95   1              /*初始化Modbus协议栈*/
  96   1      //      ModbusInit();
  97   1          /*显示界面初始化*/ 
  98   1          LcdShowInit();
  99   1          if(System_Parameter.WifiInitFlag == false)
 100   1          {
 101   2              /*初始化WIIF模块*/
 102   2              Wifi_Init(); 
 103   2              System_Parameter.WifiInitFlag = true; 
 104   2              /*存储到IAPFLASH*/
 105   2              ControlSave();
 106   2          }
 107   1          else
 108   1          {/*解决WIfi模块平凡掉电后启动不上线*/
 109   2             Wifi_Enable(false);
 110   2             Delay_ms(1000);
 111   2             Wifi_Enable(true);
 112   2          }
 113   1          /*看门狗初始化 */ 
 114   1      //      WDT_init();
 115   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2023 11:28:22 PAGE 3   

 116          
 117          /************************************外设初始化************************************/
 118          void  Init_All(void)
 119          {
 120   1          GPIO_InitTypeDef GPIO_InitStruct;
 121   1      
 122   1      //    #ifdef EXTERNAL_CRYSTAL //只要有宏名，就成立
 123   1              #if EXTERNAL_CRYSTAL
                  P_SW2 = 0x80;
                  XOSCCR = 0xC0;
                  /*启动外部晶振20MHz*/
                  while (!(XOSCCR & 1));             
                  /*时钟不分频*/
                  CLKDIV = 0x01;  
                  /*选择外部晶振 */                    
                  CKSEL = 0x01;                    
                  P_SW2 = 0x00;
                  #endif
 134   1      //  P_SW1 = 0xC0; //串口1切换到P4.3、4.4(P0.2、0.3)
 135   1      //      P_SW2 |= 0x01; //串口2切换到P4.0、4.2(P1.0、1.1)（新板子引脚问题）
 136   1      
 137   1          //手册提示，串口1、2、3、4的发送引脚必须设置为强挽输出
 138   1              /*P0.x引脚输出方式*/
 139   1          /*设置P0.0、P0.2为准双向口*/
 140   1              GPIO_InitStruct.Mode = GPIO_PullUp;
 141   1          GPIO_InitStruct.Pin  = GPIO_Pin_0 | GPIO_Pin_2;
 142   1          GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 143   1          /*设置P0.1为强挽输出 、设置P0.3为强挽输出*/
 144   1              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 145   1          GPIO_InitStruct.Pin  = GPIO_Pin_1 | GPIO_Pin_3;
 146   1          GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 147   1      
 148   1              /*P1.x引脚输出方式*/
 149   1          /*设置P1.0为准双向口*/
 150   1              GPIO_InitStruct.Mode = GPIO_PullUp;
 151   1          GPIO_InitStruct.Pin  = GPIO_Pin_0;
 152   1          GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 153   1          /*设置P1.1、P1.4、 P1.5为强挽输出*/
 154   1              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 155   1          GPIO_InitStruct.Pin  = GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5;
 156   1          GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 157   1      
 158   1          /*P2.x引脚输出方式*/
 159   1          /*按键相关P2.2、P2.3、P2.4、P2.5、P2.6为高阻态*/
 160   1          GPIO_InitStruct.Mode = GPIO_HighZ;
 161   1          GPIO_InitStruct.Pin  = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6;
 162   1          GPIO_Inilize(GPIO_P2, &GPIO_InitStruct);
 163   1      
 164   1              /*P3.x引脚输出方式*/
 165   1          /*设置P3.0为准双向口*/
 166   1              GPIO_InitStruct.Mode = GPIO_PullUp;
 167   1          GPIO_InitStruct.Pin  = GPIO_Pin_0;
 168   1          GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 169   1      
 170   1          /*设置P3.1为强挽输出*/
 171   1              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 172   1          GPIO_InitStruct.Pin  = GPIO_Pin_1;
 173   1          GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 174   1          
 175   1      }
 176          /************************************外设初始化************************************/
 177          
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2023 11:28:22 PAGE 4   

 178          
 179          /************************************检查IAP区FLASH内容************************************/
 180          bit CheckIap_Flash(void)
 181          {
 182   1          uint16_t CRC = 0;
 183   1      
 184   1              /*读取存储区数据*/
 185   1              IapRead_Buff(START_SAVEADDRESS, &System_Parameter.PSWNext.PassWordbuff[0], (sizeof(System_Parameter) - (s
             -izeof(PASSWORDSTRUCT) - 4U))); 
 186   1              /*计算CRC校验码*/
 187   1              CRC = getCrc16(&System_Parameter.PSWNext.PassWordbuff[0], (sizeof(System_Parameter) - (sizeof(PASSWORDSTR
             -UCT) - 4U) - 2U), 0xffff);   
 188   1              /*比较当前校验码和存储区校验码是否匹配*/
 189   1              if(CRC == System_Parameter.CRC16)
 190   1              {
 191   2                      return true;
 192   2              }
 193   1              return false;
 194   1      }
 195          
 196          
 197          void Iap_Flash_Iinit(void)
 198          {   /*检查eeprom参数是否正确*/
 199   1          if(CheckIap_Flash())  
 200   1          {
 201   2              GUI_String(14, 31, "parameters are correct !", EN_5_8);
 202   2              Delay_ms(1000);
 203   2          }
 204   1          else
 205   1          {
 206   2              GUI_String(19, 31, "parameters error !", EN_5_8);
 207   2              Delay_ms(500);
 208   2              GUI_String(19, 31, "restore parameters...", EN_5_8);
 209   2                      
 210   2                      /*每次写之前必须进行擦除操作：擦除每次按照512B进行(0x00-0x0200)*/
 211   2              IapErase(START_SAVEADDRESS); 
 212   2                      /*把默认参数拷贝到当前数据结构*/
 213   2                      memcpy(&System_Parameter.PSWNext.PassWordbuff[0], DEFAULT_SYSTEM_PARAMETER, (sizeof(System_Parameter) - 
             -(sizeof(PASSWORDSTRUCT) - 4U))); 
 214   2                      /*把数据进行存储*/
 215   2              IapWrite_Buff(START_SAVEADDRESS, &System_Parameter.PSWNext.PassWordbuff[0], (sizeof(System_Paramet
             -er) - (sizeof(PASSWORDSTRUCT) - 4U))); //去掉一个字节的index
 216   2      
 217   2              Delay_ms(1000);
 218   2              clear_screen();
 219   2              GUI_String(49, 31, "successfully !", EN_5_8);
 220   2              Delay_ms(500);
 221   2          }
 222   1      }
 223          /************************************检查IAP区FLASH内容************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    457    ----
   CONSTANT SIZE    =     99    ----
   XDATA SIZE       =     20       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
