C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MDREGPOOL
OBJECT MODULE PLACED IN .\Objects\mdregpool.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE FreeModBus\Src\mdregpool.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Inclu
                    -de;.\FreeModBus\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\mdregpool.lst) OBJECT(.\Objects\mdregpool.obj)

line level    source

   1          #include "mdregpool.h"
   2          #include <stdlib.h>
   3          
   4          #if(USER_MODBUS_LIB)
   5          /* ================================================================== */
   6          /*                        åº•å±‚ä»£ç                                      */
   7          /*              ä½œç”¨ï¼šå®ç°åŠ¨æ€å¢åˆ ä»»æ„åœ°å€å¯„å­˜å™¨ï¼ŒåŠ é€Ÿå¯„å­˜å™¨è®¿é—®               */
   8          /* ================================================================== */
   9          
  10          static mdU32 start_addr[] = {   COIL_OFFSET,
  11                                          INPUT_COIL_OFFSET,
  12                                          INPUT_REGISTER_OFFSET,
  13                                          HOLD_REGISTER_OFFSET  };
  14          
  15          /*
  16              mdCreateRegister
  17                  @handler å¥æŸ„
  18                  @reg    åˆ›å»ºçš„å¯„å­˜å™¨
  19                  @return æˆåŠŸè¿”å› mdTRUEï¼Œå¤±è´¥è¿”å› mdFALSE
  20              åˆ†é…ä¸€ä¸ªå¯„å­˜å™¨ï¼Œåˆå§‹åŒ–å®ƒï¼Œå¥æŸ„çš„å¯„å­˜å™¨æ•°é‡åŠ ä¸€ã€‚å¦‚æœå½“å‰å¯„å­˜å™¨æ•°é‡è¶…
             -è¿‡è®¾å®šçš„æœ€å¤§å¯„å­˜å™¨æ•°é‡ï¼Œåˆ™åˆ†é…å¤±è´¥
  21          */
  22          static mdSTATUS mdCreateRegister(RegisterPoolHandle handler,RegisterHandle* reg){
  23   1          mdSTATUS ret = mdFALSE;
  24   1          (*reg) = NULL;
  25   1          if (handler->curRegisterNumber < handler->maxRegisterNumber)
  26   1          {
  27   2              RegisterHandle reghandle = (RegisterHandle)malloc(sizeof(struct Register));
  28   2              if (reghandle != NULL)
  29   2              {
  30   3                  reghandle->addr = 0;
  31   3                  reghandle->dat = 0;
  32   3                  reghandle->next = NULL;
  33   3                  (*reg) = reghandle;
  34   3                  handler->curRegisterNumber++;
  35   3                  ret = mdTRUE;
  36   3              }
  37   2          }
  38   1          return ret;
  39   1      }
  40          
  41          /*
  42              mdDestoryRegister
  43                  @handler å¥æŸ„
  44                  @reg    éœ€è¦åˆ é™¤çš„å¯„å­˜å™¨
  45                  @return
  46              é‡Šæ”¾å¯„å­˜å™¨å ç”¨çš„ç©ºé—´ï¼Œå¹¶ä¸”å°†å¥æŸ„ä¸­çš„ curRegisterNumber å‡ä¸€
  47          */
  48          static mdVOID mdDestoryRegister(RegisterPoolHandle handler,RegisterHandle* reg){
  49   1          free(*reg);
  50   1          handler->curRegisterNumber--;
  51   1          (*reg) = NULL;
  52   1      }
  53          
C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 2   

  54          /*
  55              mdFindRegisterByAddress
  56                  @handler å¥æŸ„
  57                  @addr   å¯„å­˜å™¨åœ°å€
  58                  @reg    è¿”å›æ‰¾åˆ°çš„å¯„å­˜å™¨
  59                  @return æ‰¾åˆ°åˆ™è¿”å› mdTRUEï¼Œä¸”å¡«å…… regï¼Œå¦åˆ™è¿”å› mdFALSEï¼Œregç½®ä¸º NULL
  60              æ ¹æ®å¯„å­˜å™¨åœ°å€å¯»æ‰¾å¯„å­˜å™¨ï¼Œè‹¥æ‰¾åˆ°åˆ™è¿”å› mdTRUEï¼Œä¸”å¡«å…… regï¼Œå¦åˆ™è¿”å› mdFALS
             -Eï¼Œregç½®ä¸º NULL
  61          */
  62          static mdSTATUS mdFindRegisterByAddress(RegisterPoolHandle handler, mdU32 addr, RegisterHandle *reg){
  63   1          mdSTATUS ret = mdFALSE;
  64   1              mdU32 i = 0;
  65   1              
  66   1          for (i = 0; i < 4; i++)
  67   1          {
  68   2              if((addr >= start_addr[i]) && (addr < start_addr[i] + REGISTER_POOL_MAX_BUFFER)){
  69   3                  (*reg) = handler->quickMap[i][addr-start_addr[i]];
  70   3                  ret = mdTRUE;
  71   3              }
  72   2          }
  73   1          if (ret == mdFALSE)
  74   1          {
  75   2              RegisterHandle p = handler->pool->next;
  76   2              while (p != NULL)
  77   2              {
  78   3                  if (addr == p->addr)
  79   3                  {
  80   4                      (*reg) = p;
  81   4                      ret = mdTRUE;
  82   4                      break;
  83   4                  }
  84   3                  else if (addr < p->addr)
  85   3                  {
  86   4                      (*reg) = NULL;
  87   4                      break;
  88   4                  }
  89   3                  else p=p->next;
  90   3              }
  91   2          }
  92   1          return ret;
  93   1      }
  94          
  95          
  96          /*
  97              mdInsertRegister
  98                  @handler å¥æŸ„
  99                  @reg    æ’å…¥çš„å¯„å­˜å™¨
 100                  @return æ’å…¥æˆåŠŸè¿”å› mdTRUEï¼Œ å¦åˆ™è¿”å› mdFALSE
 101              éå†å¯„å­˜å™¨æ± ï¼ŒæŒ‰ç…§å¯„å­˜å™¨åœ°å€å¤§å°é¡ºåºæ’å…¥é€‚å½“çš„ä½ç½®ï¼Œå¦‚æœå·²å­˜åœ¨åˆ™è¿”å›
             - mdFALSE
 102          */
 103          static mdSTATUS mdInsertRegister(RegisterPoolHandle handler,RegisterHandle* reg){
 104   1          mdSTATUS ret = mdFALSE;
 105   1          RegisterHandle p=handler->pool,q=p->next;
 106   1          while (q!=NULL && q->addr < (*reg)->addr){
 107   2              p = q;
 108   2              q = p->next;
 109   2          }
 110   1          if (q == NULL)
 111   1          {
 112   2              p->next = *reg;
 113   2              (*reg)->next = NULL;
C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 3   

 114   2              ret = mdTRUE;
 115   2          }
 116   1          else if(q->addr == (*reg)->addr){
 117   2              ret = mdFALSE;
 118   2          }
 119   1          else{
 120   2              (*reg)->next = q;
 121   2              p->next = *reg;
 122   2              ret = mdTRUE;
 123   2          }
 124   1          return ret;
 125   1      }
 126          
 127          
 128          /* ================================================================== */
 129          /*                        ç¬¬äºŒå±‚å°è£…                                    */
 130          /*     ä½œç”¨ï¼šå®ç°ç†è®ºä¸Š(å…¶å®é™åˆ¶å¯„å­˜å™¨æœ€å¤§æ•°é‡)å¯„å­˜å™¨æ•°é‡æ— é™å¤šï¼Œ             
             -  */
 131          /*            å¿½ç•¥ä¸ç”¨å¯„å­˜å™¨åœ°å€å­˜å‚¨çš„å›°æ‰°                                 */
 132          /* ================================================================== */
 133          
 134          #define mdToDouble(n) ((double)n)
 135          #define mdREG_ADDR(n) ((mdU32)(mdToDouble(n)/REGISTER_WIDTH))
 136          #define mdREG_OFFSET(n) (n%REGISTER_WIDTH)
 137          #define mdGetBit(reg,offset) ((reg>>offset)&1)
 138          #define ToBit(n) ((mdU32)n>0?mdHigh:mdLow)
 139          
 140          /*
 141              mdReadBit
 142                  @handler å¥æŸ„
 143                  @addr    ä½åœ°å€ï¼Œå¦‚æœå¯„å­˜å™¨ä½å®½ä¸º16ï¼Œåˆ™0~15éƒ½åœ¨ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸­ï¼Œä»¥æ­¤ç±»æ
             -¨
 144                  @bit    ä½ç»“æœ
 145                  @return mdTRUE
 146              æ ¹æ®åœ°å€åœ¨å½“å‰å¥æŸ„ä¸­è¯»å–ä½å¤§å°
 147          */
 148          static mdSTATUS mdReadBit(RegisterPoolHandle handler, mdU32 addr,mdBit *abit) reentrant {
 149   1          mdSTATUS ret = mdFALSE;
 150   1          mdU32 reg_addr = mdREG_ADDR(addr);
 151   1          mdU32 reg_off = mdREG_OFFSET(addr);
 152   1          RegisterHandle reg;
 153   1          ret = mdFindRegisterByAddress(handler,reg_addr,&reg);
 154   1          if (ret == mdTRUE)
 155   1          {
 156   2              (*abit) = ToBit( mdGetBit(reg->dat,reg_off));
 157   2          }
 158   1          else{
 159   2              (*abit) = mdLow;
 160   2          }
 161   1      
 162   1          return mdTRUE;
 163   1      }
 164          
 165          /*
 166              mdWriteBit
 167                  @handler å¥æŸ„
 168                  @addr    ä½åœ°å€ï¼Œå¦‚æœå¯„å­˜å™¨ä½å®½ä¸º16ï¼Œåˆ™0~15éƒ½åœ¨ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸­ï¼Œä»¥æ­¤ç±»æ
             -¨
 169                  @abit    ä½å¤§å°
 170                  @return ç©ºé—´ä¸è¶³æ—¶è¿”å› mdFalseï¼Œå¦åˆ™ mdTRUE
 171              æ ¹æ®åœ°å€ä¿®æ”¹å½“å‰å¥æŸ„ä¸­çš„ä½å¤§å°
 172          */
C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 4   

 173          static mdSTATUS mdWriteBit(RegisterPoolHandle handler,mdU32 addr,mdBit abit) reentrant{
 174   1          mdSTATUS ret = mdFALSE;
 175   1          mdU32 reg_addr = mdREG_ADDR(addr);
 176   1          mdU32 reg_off = mdREG_OFFSET(addr);
 177   1          RegisterHandle reg;
 178   1          ret = mdFindRegisterByAddress(handler,reg_addr,&reg);
 179   1          abit = ToBit(abit);
 180   1          if (ret == mdTRUE)    {
 181   2              reg->dat |= (abit << reg_off);
 182   2          }
 183   1          else{
 184   2              ret = mdCreateRegister(handler,&reg);
 185   2              if (ret == mdTRUE)
 186   2              {
 187   3                  reg->addr = reg_addr;
 188   3                  reg->dat |= (abit << reg_off);
 189   3                  ret = mdInsertRegister(handler,&reg);
 190   3              }
 191   2          }
 192   1          return ret;
 193   1      }
 194          
 195          /*
 196              mdReadBits
 197                  @handler å¥æŸ„
 198                  @addr    ä½åœ°å€ï¼Œå¦‚æœå¯„å­˜å™¨ä½å®½ä¸º16ï¼Œåˆ™0~15éƒ½åœ¨ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸­ï¼Œä»¥æ­¤ç±»æ
             -¨
 199                  @len    é•¿åº¦
 200                  @bits    ä½æ•°ç»„
 201                  @return mdTRUE
 202              æ ¹æ®åœ°å€åœ¨å½“å‰å¥æŸ„ä¸­è¯»å– len ä¸ªä½å¤§å°ï¼Œç»“æœä¿å­˜åœ¨ bitsä¸­
 203          */
 204          static mdSTATUS mdReadBits(RegisterPoolHandle handler,mdU32 addr,mdU32 len,mdBit *bits) reentrant{
 205   1          mdSTATUS ret = mdFALSE;
 206   1              mdU32 i = 0;
 207   1              
 208   1          for (i = 0; i < len; i++)
 209   1          {
 210   2              ret = handler->mdReadBit(handler,addr+i, bits++);
 211   2          }
 212   1          return ret;
 213   1      
 214   1      }
 215          
 216          /*
 217              mdReadBits
 218                  @handler å¥æŸ„
 219                  @addr    ä½åœ°å€ï¼Œå¦‚æœå¯„å­˜å™¨ä½å®½ä¸º16ï¼Œåˆ™0~15éƒ½åœ¨ç¬¬ä¸€ä¸ªå¯„å­˜å™¨ä¸­ï¼Œä»¥æ­¤ç±»æ
             -¨
 220                  @len    é•¿åº¦
 221                  @bits    ä½æ•°ç»„
 222                  @return ç©ºé—´ä¸è¶³æ—¶è¿”å› mdFalseï¼Œå¦åˆ™ mdTRUE
 223              æ ¹æ®åœ°å€ä¿®æ”¹å½“å‰å¥æŸ„ä¸­çš„ len ä¸ªä½å¤§å°
 224          */
 225          static mdSTATUS mdWriteBits(RegisterPoolHandle handler,mdU32 addr,mdU32 len,mdBit* bits) reentrant{
 226   1          mdSTATUS ret = mdFALSE;
 227   1              mdU32 i = 0;
 228   1              
 229   1          for (i = 0; i < len; i++)
 230   1          {
 231   2              ret = handler->mdWriteBit(handler,addr+i,bits[i]);
 232   2          }
C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 5   

 233   1          return ret;
 234   1      }
 235          
 236          /*
 237              mdReadU16
 238                  @handler å¥æŸ„
 239                  @addr    å¯„å­˜å™¨åœ°å€
 240                  @data    å¯„å­˜å™¨æ•°æ®
 241                  @return  mdTRUE
 242              æ ¹æ®åœ°å€è¯»å–ä¸€ä¸ªå¯„å­˜å™¨å€¼
 243          */
 244          static mdSTATUS mdReadU16(RegisterPoolHandle handler,mdU32 addr,mdU16 *dat) reentrant{
 245   1          mdSTATUS ret = mdFALSE;
 246   1          RegisterHandle reg;
 247   1          ret = mdFindRegisterByAddress(handler,addr,&reg);
 248   1          if (ret == mdTRUE)
 249   1          {
 250   2              (*dat) = reg->dat;
 251   2          }
 252   1          else{
 253   2              (*dat) = 0;
 254   2          }
 255   1          return mdTRUE;
 256   1      }
 257          
 258          
 259          /*
 260              mdReadU16
 261                  @handler å¥æŸ„
 262                  @addr    å¯„å­˜å™¨åœ°å€
 263                  @dat    å¯„å­˜å™¨æ•°æ®
 264                  @return  ç©ºé—´ä¸è¶³æ—¶è¿”å› mdFALSE ,å¦åˆ™è¿”å› mdTRUE
 265              æ ¹æ®åœ°å€å†™å…¥ä¸€ä¸ªå¯„å­˜å™¨
 266          */
 267          static mdSTATUS mdWriteU16(RegisterPoolHandle handler,mdU32 addr,mdU16 dat) reentrant{
 268   1          mdSTATUS ret = mdFALSE;
 269   1          RegisterHandle reg;
 270   1          ret = mdFindRegisterByAddress(handler,addr,&reg);
 271   1          if (ret == mdTRUE)
 272   1          {
 273   2              reg->dat = dat;
 274   2          }
 275   1          else{
 276   2              ret = mdCreateRegister(handler,&reg);
 277   2              if (ret == mdTRUE)
 278   2              {
 279   3                  reg->addr = addr;
 280   3                  reg->dat = dat;
 281   3                  ret = mdInsertRegister(handler,&reg);
 282   3              }
 283   2          }
 284   1          return ret;
 285   1      }
 286          
 287          /*
 288              mdReadU16
 289                  @handler å¥æŸ„
 290                  @addr    å¯„å­˜å™¨åœ°å€
 291                  @len    è¯»å–é•¿åº¦
 292                  @dat    å€¼æ•°ç»„
 293                  @return  mdTRUE
 294              æ ¹æ®åœ°å€è¯»å–ä¸€ç»„å¯„å­˜å™¨å€¼
C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 6   

 295          */
 296          static mdSTATUS mdReadU16s(RegisterPoolHandle handler,mdU32 addr,mdU32 len,mdU16 *dat) reentrant{
 297   1          mdSTATUS ret = mdFALSE;
 298   1              mdU32 i = 0;
 299   1              
 300   1          for (i = 0; i < len; i++)
 301   1          {
 302   2              ret = handler->mdReadU16(handler,addr+i, dat++);
 303   2          }
 304   1          return ret;
 305   1      }
 306          
 307          
 308          /*
 309              mdWriteU16s
 310                  @handler å¥æŸ„
 311                  @addr    å¯„å­˜å™¨åœ°å€
 312                  @len    å†™å…¥é•¿åº¦
 313                  @dat    å€¼æ•°ç»„
 314                  @return  ç©ºé—´ä¸è¶³æ—¶è¿”å› mdFALSE ,å¦åˆ™è¿”å› mdTRUE
 315              æ ¹æ®åœ°å€å†™å…¥ä¸€ç»„å¯„å­˜å™¨å€¼
 316          */
 317          static mdSTATUS mdWriteU16s(RegisterPoolHandle handler,mdU32 addr,mdU32 len,mdU16 *dat) reentrant{
 318   1          mdSTATUS ret = mdFALSE;
 319   1              mdU32 i = 0;
 320   1              
 321   1          for (i = 0; i < len; i++)
 322   1          {
 323   2              ret = handler->mdWriteU16(handler,addr+i,*(dat++));
 324   2          }
 325   1          return ret;
 326   1      }
 327          
 328          
 329          
 330          static mdSTATUS mdReadCoil(RegisterPoolHandle handler, mdU32 addr, mdBit* abit) reentrant
 331          {
 332   1          mdU16 buf;
 333   1          mdSTATUS ret = handler->mdReadU16(handler, addr + COIL_OFFSET, &buf);
 334   1          (*abit) = buf & 0x01;
 335   1          return ret;
 336   1      }
 337          
 338          static mdSTATUS mdReadCoils(RegisterPoolHandle handler, mdU32 addr, mdU32 len, mdBit* bits) reentrant
 339          {
 340   1          mdU16 buf;
 341   1          mdSTATUS ret = mdFALSE;
 342   1              mdU32 i = 0;
 343   1              
 344   1          for (i = 0; i < len; i++)
 345   1          {
 346   2              ret |= handler->mdReadU16(handler, addr + i + COIL_OFFSET, &buf);
 347   2              *(bits++) = buf & 0x01;
 348   2          }
 349   1          return ret;
 350   1      }
 351          
 352          static mdSTATUS mdWriteCoil(RegisterPoolHandle handler, mdU32 addr, mdBit abit) reentrant
 353          {
 354   1          return handler->mdWriteU16(handler, addr + COIL_OFFSET, (mdU16)abit);
 355   1      }
 356          
C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 7   

 357          static mdSTATUS mdWriteCoils(RegisterPoolHandle handler, mdU32 addr, mdU32 len, mdBit* bits) reentrant
 358          {
 359   1          mdSTATUS ret = mdFALSE;
 360   1              mdU32 i = 0;
 361   1              
 362   1          for (i = 0; i < len; i++)
 363   1          {
 364   2              ret |= handler->mdWriteU16(handler, addr + i + COIL_OFFSET, (mdU16)(*(bits++)));
 365   2          }
 366   1          return ret;
 367   1      }
 368          
 369          static mdSTATUS mdReadInputCoil(RegisterPoolHandle handler, mdU32 addr, mdBit* abit) reentrant
 370          {
 371   1          mdU16 buf;
 372   1          mdSTATUS ret = handler->mdReadU16(handler, addr + INPUT_COIL_OFFSET, &buf);
 373   1          (*abit) = buf & 0x01;
 374   1          return ret;
 375   1      }
 376          
 377          static mdSTATUS mdReadInputCoils(RegisterPoolHandle handler, mdU32 addr, mdU32 len, mdBit* bits) reentrant
 378          {
 379   1          mdU16 buf;
 380   1          mdSTATUS ret = mdFALSE;
 381   1              mdU32 i = 0;
 382   1              
 383   1          for (i = 0; i < len; i++)
 384   1          {
 385   2              ret |= handler->mdReadU16(handler, addr + i + INPUT_COIL_OFFSET, &buf);
 386   2              *(bits++) = buf & 0x01;
 387   2          }
 388   1          return ret;
 389   1      }
 390          
 391          static mdSTATUS mdWriteInputCoil(RegisterPoolHandle handler, mdU32 addr, mdBit abit) reentrant
 392          {
 393   1          return handler->mdWriteU16(handler, addr + INPUT_COIL_OFFSET, (mdU16)abit);
 394   1      }
 395          
 396          static mdSTATUS mdWriteInputCoils(RegisterPoolHandle handler, mdU32 addr, mdU32 len, mdBit* bits) reentran
             -t
 397          {
 398   1          mdSTATUS ret = mdFALSE;
 399   1              mdU32 i = 0;
 400   1              
 401   1          for (i = 0; i < len; i++)
 402   1          {
 403   2              ret |= handler->mdWriteU16(handler, addr + i + INPUT_COIL_OFFSET, (mdU16)(*(bits++)));
 404   2          }
 405   1          return ret;
 406   1      }
 407          
 408          static mdSTATUS mdReadInputRegister(RegisterPoolHandle handler, mdU32 addr, mdU16* dat) reentrant
 409          {
 410   1          return handler->mdReadU16(handler, addr + INPUT_REGISTER_OFFSET, dat);
 411   1      }
 412          
 413          static mdSTATUS mdReadInputRegisters(RegisterPoolHandle handler, mdU32 addr, mdU32 len, mdU16* dat) reentr
             -ant
 414          {
 415   1          return handler->mdReadU16s(handler, addr + INPUT_REGISTER_OFFSET, len, dat);
 416   1      }
C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 8   

 417          
 418          static mdSTATUS mdWriteInputRegister(RegisterPoolHandle handler, mdU32 addr, mdU16 dat) reentrant
 419          {
 420   1          return handler->mdWriteU16(handler, addr + INPUT_REGISTER_OFFSET, dat);
 421   1      }
 422          
 423          static mdSTATUS mdWriteInputRegisters(RegisterPoolHandle handler, mdU32 addr, mdU32 len, mdU16* dat) reent
             -rant
 424          {
 425   1          return handler->mdWriteU16s(handler, addr + INPUT_REGISTER_OFFSET, len, dat);
 426   1      }
 427          
 428          
 429          static mdSTATUS mdReadHoldRegister(RegisterPoolHandle handler, mdU32 addr, mdU16* dat) reentrant
 430          {
 431   1          return handler->mdReadU16(handler, addr + HOLD_REGISTER_OFFSET, dat);
 432   1      }
 433          
 434          static mdSTATUS mdReadHoldRegisters(RegisterPoolHandle handler, mdU32 addr, mdU32 len, mdU16* dat) reentra
             -nt
 435          {
 436   1          return handler->mdReadU16s(handler, addr + HOLD_REGISTER_OFFSET, len, dat);
 437   1      }
 438          
 439          static mdSTATUS mdWriteHoldRegister(RegisterPoolHandle handler, mdU32 addr, mdU16 dat) reentrant
 440          {
 441   1          return handler->mdWriteU16(handler, addr + HOLD_REGISTER_OFFSET, dat);
 442   1      }
 443          
 444          static mdSTATUS mdWriteHoldRegisters(RegisterPoolHandle handler, mdU32 addr, mdU32 len, mdU16* dat) reentr
             -ant
 445          {
 446   1          return handler->mdWriteU16s(handler, addr + HOLD_REGISTER_OFFSET, len, dat);
 447   1      }
 448          
 449          /*
 450              mdCreateRegisterPool
 451                  @regpoolhandle  å¥æŸ„
 452                  @return ç©ºé—´ä¸è¶³æ—¶è¿”å› mdFALSEï¼Œå¦åˆ™è¿”å› mdTRUE
 453              åˆ›å»ºå¹¶åˆå§‹åŒ–å¯„å­˜å™¨æ± 
 454          */
 455          mdSTATUS mdCreateRegisterPool(RegisterPoolHandle* regpoolhandle){
 456   1          mdSTATUS ret = mdFALSE;
 457   1          RegisterPoolHandle handler;
 458   1              mdU32 i = 0;
 459   1              mdU32 j = 0;
 460   1          handler= (RegisterPoolHandle)malloc(sizeof(struct RegisterPool));
 461   1          if (handler != NULL)
 462   1          {
 463   2              //æ³¨å†Œæ–¹æ³•
 464   2              handler->mdReadBit              = mdReadBit;
 465   2              handler->mdReadBits             = mdReadBits;
 466   2              handler->mdReadU16              = mdReadU16;
 467   2              handler->mdReadU16s             = mdReadU16s;
 468   2              handler->mdWriteBit             = mdWriteBit;
 469   2              handler->mdWriteBits            = mdWriteBits;
 470   2              handler->mdWriteU16             = mdWriteU16;
 471   2              handler->mdWriteU16s            = mdWriteU16s;
 472   2      
 473   2              handler->mdReadCoil             = mdReadCoil;
 474   2              handler->mdReadCoils            = mdReadCoils;
 475   2              handler->mdWriteCoil            = mdWriteCoil;
C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 9   

 476   2              handler->mdWriteCoils           = mdWriteCoils;
 477   2              handler->mdReadInputCoil        = mdReadInputCoil;
 478   2              handler->mdReadInputCoils       = mdReadInputCoils;
 479   2              handler->mdWriteInputCoil       = mdWriteInputCoil;
 480   2              handler->mdWriteInputCoils      = mdWriteInputCoils;
 481   2              handler->mdReadInputRegister    = mdReadInputRegister;
 482   2              handler->mdReadInputRegisters   = mdReadInputRegisters;
 483   2              handler->mdWriteInputRegister   = mdWriteInputRegister;
 484   2              handler->mdWriteInputRegisters  = mdWriteInputRegisters;
 485   2              handler->mdReadHoldRegister     = mdReadHoldRegister;
 486   2              handler->mdReadHoldRegisters    = mdReadHoldRegisters;
 487   2              handler->mdWriteHoldRegister    = mdWriteHoldRegister;
 488   2              handler->mdWriteHoldRegisters   = mdWriteHoldRegisters;
 489   2      
 490   2              //è®¾å®šå½“å‰å¯„å­˜å™¨æ•°é‡(æ­¤å¤„ä¸è®¾ç½®ï¼Œå¯èƒ½ä¼šå‡ºé”™ï¼Œç¼–è¯‘å™¨ä¸ä¼šåˆå§‹åŒ–ç»“æ„ä½
             -“å˜é‡ä¸º0)
 491   2                      handler->curRegisterNumber = 0;
 492   2              //è®¾å®šæœ€å¤§å¯„å­˜å™¨æ•°é‡
 493   2              handler->maxRegisterNumber = REGISTER_POOL_MAX_REGISTER_NUMBER;
 494   2      
 495   2              //é‡‡ç”¨å¤´èŠ‚ç‚¹æ¨¡å¼
 496   2              ret = mdCreateRegister(handler,&(handler->pool));
 497   2              if (ret == mdFALSE) goto exit;
 498   2      
 499   2              //æ„å»ºå¯„å­˜å™¨æ± å’Œå¿«è¡¨
 500   2              RegisterHandle p = handler->pool;
*** ERROR C141 IN LINE 500 OF FreeModBus\Src\mdregpool.c: syntax error near 'RegisterHandle', expected '__asm'
*** ERROR C202 IN LINE 500 OF FreeModBus\Src\mdregpool.c: 'p': undefined identifier
 501   2              for (i = 0; i < 4; i++)
 502   2              {
 503   3                  for (j = 0; j < REGISTER_POOL_MAX_BUFFER; j++)
 504   3                  {
 505   4                      RegisterHandle reg;
 506   4                      ret = mdCreateRegister(handler,&reg);
 507   4                      if (ret == mdFALSE) goto exit;
 508   4                      reg->addr = start_addr[i] + j;
 509   4                      handler->quickMap[i][j] = reg;
 510   4                      p->next = reg;
*** ERROR C202 IN LINE 510 OF FreeModBus\Src\mdregpool.c: 'p': undefined identifier
 511   4                      p = reg;
*** ERROR C202 IN LINE 511 OF FreeModBus\Src\mdregpool.c: 'p': undefined identifier
 512   4                  }
 513   3              }
 514   2              ret = mdTRUE;
 515   2          }
 516   1      exit:    (*regpoolhandle) = handler;
 517   1          return ret;
 518   1      }
*** ERROR C233 IN LINE 518 OF FreeModBus\Src\mdregpool.c: 'exit': undefined label
 519          
 520          /*
 521              mdDestoryRegisterPool
 522                  @regpoolhandle  å¥æŸ„
 523                  @return
 524              é‡Šæ”¾å¯„å­˜å™¨æ± ç©ºé—´ï¼Œå¥æŸ„ç½® NULL
 525          */
 526          mdVOID mdDestoryRegisterPool(RegisterPoolHandle* regpoolhandle){
 527   1      
 528   1          //é‡Šæ”¾æ‰€æœ‰å¯„å­˜å™¨
 529   1          RegisterHandle p = (*regpoolhandle)->pool;
 530   1          while (p->next != NULL)
 531   1          {
C51 COMPILER V9.60.0.0   MDREGPOOL                                                         09/18/2021 18:02:50 PAGE 10  

 532   2              RegisterHandle q = p->next;
 533   2              mdDestoryRegister(*regpoolhandle,&p);
 534   2              p = q;
 535   2          }
 536   1          //é‡Šæ”¾å¯„å­˜å™¨æ± 
 537   1          free(*regpoolhandle);
 538   1          (*regpoolhandle) = NULL;
 539   1      }
 540          
 541          #endif

C51 COMPILATION COMPLETE.  0 WARNING(S),  5 ERROR(S)
