C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 17:07:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE REPORT
OBJECT MODULE PLACED IN .\Objects\report.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\report.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeMod
                    -Bus\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\report.lst) OBJECT(.\Objects\report.obj)

line level    source

   1          #include "report.h"
   2          #include "usart.h"
   3          
   4          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest);
   5          void Uart_DataForward(SEL_CHANNEL Src, SEL_CHANNEL Dest);
   6          void Plc_To_Rs485(void);
   7          void Wifi_To_Plc(void);
   8          void Rs485_to_Plc(void);
   9          
  10          /*å®šä¹‰å½“å‰ä¸²å£äº¤æ¢åºåˆ—*/
  11          // const ComData_Handle ComData_Array[] =
  12          //      {
  13          //              {CHANNEL_PLC, CHANNEL_RS485, Plc_To_Rs485},
  14          //              {CHANNEL_WIFI, CHANNEL_PLC, Wifi_To_Plc},
  15          //              //      {CHANNEL_LAN,  CHANNEL_PLC,   Lan_To_Plc}
  16          // };
  17          
  18          const ComData_Handle ComData_Array[] =
  19                  {
  20                          // {CHANNEL_PLC, CHANNEL_RS485, Public_DataHandle},
  21                          {CHANNEL_WIFI, CHANNEL_PLC, Public_DataHandle},
  22                          {CHANNEL_LAN, CHANNEL_PLC, Public_DataHandle},
  23                          {CHANNEL_RS485, CHANNEL_PLC, Public_DataHandle}};
  24          
  25          #define COMDATA_SIZE (sizeof(ComData_Array) / sizeof(ComData_Handle))
  26          
  27          /*åˆ›å»º4æ¡é“¾é˜Ÿ*/
  28          Uart_List xdata Uart_LinkList[MAX_LQUEUE];
  29          
  30          /**
  31           * @brief       åˆå§‹åŒ–é™æ€é“¾é˜Ÿ
  32           * @details
  33           * @param       *List:å½“å‰é“¾é˜ŸæŒ‡é’ˆ
  34           * @retval      None
  35           */
  36          void Init_ListQueue(Uart_List *List)
  37          {
  38   1              uint8_t i = 0;
  39   1      
  40   1              for (i = 0; i < MAX_NODE; i++)
  41   1              {
  42   2                      /*åˆå§‹åŒ–é˜Ÿåˆ—æ•°æ®åŸŸ*/
  43   2                      List->LNode[i].Source_Channel = CHANNEL_IDLE;
  44   2                      List->LNode[i].Target_Channel = CHANNEL_IDLE;
  45   2                      List->LNode[i].Frame_Flag = false;
  46   2                      List->LNode[i].Timer_Flag = false;
  47   2                      List->LNode[i].Rx_Length = 0;
  48   2                      List->LNode[i].OverTime = MAX_SILENCE;
  49   2                      memset(&List->LNode[i].Rx_Buffer[0], 0, MAX_SIZE);
  50   2              }
  51   1              // List->Buffer_Size = buf_size;
  52   1              /*åˆå§‹åŒ–é“¾è¡¨èŠ‚ç‚¹è¯»å†™æŒ‡é’ˆ*/
  53   1              List->Wptr = List->Rptr = 0;
  54   1      }
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 17:07:55 PAGE 2   

  55          
  56          /**
  57           * @brief       ä¸²å£1å¯¹1æ•°æ®è½¬å‘
  58           * @details
  59           * @param       None
  60           * @retval      None
  61           */
  62          // void Uart_DataForward(SEL_CHANNEL Src, SEL_CHANNEL Dest)
  63          // {
  64          //      uint8_t i = 0;
  65          
  66          //      for (i = 0; i < COMDATA_SIZE; i++)
  67          //      {
  68          //              if ((Src == ComData_Array[i].Source_Channel) && (Dest == ComData_Array[i].Target_Channel))
  69          //              {
  70          //                      ComData_Array[i].pHandle();
  71          //              }
  72          //      }
  73          // }
  74          
  75          /**
  76           * @brief       ä¸²å£äº‹ä»¶å¤„ç†
  77           * @details
  78           * @param       None
  79           * @retval      None
  80           */
  81          void Uart_Handle(void)
  82          {
  83   1              static uint8_t i = 0;
  84   1      
  85   1              // /*å…³é—­ä¸²å£4æ¥æ”¶ä¸­æ–­*/
  86   1              // // S4CON &= ~S4REN;
  87   1      
  88   1              for (i = 0; i < COMDATA_SIZE; i++)
  89   1              {
  90   2                      ComData_Array[i].pHandle(ComData_Array[i].Source_Channel, ComData_Array[i].Target_Channel);
  91   2              }
  92   1              // ComData_Array[0].pHandle(ComData_Array[0].Source_Channel, ComData_Array[0].Target_Channel);
  93   1              // ComData_Array[1].pHandle(ComData_Array[1].Source_Channel, ComData_Array[1].Target_Channel);
  94   1              // ComData_Array[2].pHandle(ComData_Array[2].Source_Channel, ComData_Array[2].Target_Channel);
  95   1              // USART3_EN = 1;
  96   1              // Uartx_SendStr(&Uart3, "\x01\x02\x03", 3);
  97   1              // USART3_EN = 0;
  98   1              /*å½“å‰æ— è¯·æ±‚é€šé“*/
  99   1              // current_request_channel = CHANNEL_IDLE;
 100   1              // Rs485_to_Plc();
 101   1      
 102   1              // Public_DataHandle(CHANNEL_RS485, CHANNEL_PLC);
 103   1      
 104   1              // Public_DataHandle(CHANNEL_WIFI, CHANNEL_PLC);
 105   1              // Public_DataHandle(CHANNEL_LAN, CHANNEL_PLC);
 106   1      }
 107          
 108          /*ç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–è¯¥æ¨¡å—*/
 109          // #pragma OPTIMIZE(2)
 110          /**
 111           * @brief       è·å¾—ç›®æ ‡é€šé“é“¾è¡¨åœ°å€
 112           * @details
 113           * @param       channel é€šé“å·
 114           * @retval      p æŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆ
 115           */
 116          static Uart_List *Get_Target_Channel(channel)
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 17:07:55 PAGE 3   

 117          {
 118   1              Uart_List *p = NULL;
 119   1              switch (channel)
 120   1              {
 121   2              case CHANNEL_LAN:
 122   2                      p = &COM_UART1;
 123   2                      break;
 124   2              case CHANNEL_WIFI:
 125   2                      p = &COM_UART2;
 126   2                      break;
 127   2              case CHANNEL_RS485:
 128   2                      p = &COM_UART3;
 129   2                      break;
 130   2              case CHANNEL_PLC:
 131   2                      p = &COM_UART4;
 132   2                      break;
 133   2              default:
 134   2                      break;
 135   2              }
 136   1              return p;
 137   1      }
 138          
 139          /**
 140           * @brief       è·å¾—ç›®æ ‡é€šé“å¯¹åº”ä¸²å£
 141           * @details
 142           * @param       channel é€šé“å·
 143           * @retval      p æŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆ
 144           */
 145          static Uart_HandleTypeDef *Get_Target_Uart(channel)
 146          {
 147   1              Uart_HandleTypeDef *p = NULL;
 148   1              switch (channel)
 149   1              {
 150   2              case CHANNEL_LAN:
 151   2                      p = &Uart1;
 152   2                      break;
 153   2              case CHANNEL_WIFI:
 154   2                      p = &Uart2;
 155   2                      break;
 156   2              case CHANNEL_RS485:
 157   2                      p = &Uart3;
 158   2                      break;
 159   2              case CHANNEL_PLC:
 160   2                      p = &Uart4;
 161   2                      break;
 162   2              default:
 163   2                      break;
 164   2              }
 165   1              return p;
 166   1      }
 167          
 168          /**
 169           * @brief       æ•°æ®å¸§å…¬å…±è½¬å‘
 170           * @details
 171           * @param       src æ•°æ®æºè¯·æ±‚é€šé“
 172           * @param   dest æ•°æ®äº¤ä»˜é€šé“
 173           * @retval      None
 174           */
 175          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest)
 176          {
 177   1              Uart_List *psrc = Get_Target_Channel(src);
 178   1              Uart_List *pdest = Get_Target_Channel(dest);
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 17:07:55 PAGE 4   

 179   1              Uart_HandleTypeDef *psuart = Get_Target_Uart(src);
 180   1              Uart_HandleTypeDef *peuart = Get_Target_Uart(dest);
 181   1              uint8_t i = 0;
 182   1      
 183   1              if ((psrc == NULL) || (pdest == NULL) || (psuart == NULL) || (peuart == NULL))
 184   1              {
 185   2                      return;
 186   2              }
 187   1              // printf ("psrc %d, pdest %d, %d, %d, %d, %d\r\n",
 188   1              // (uint16_t)psrc, (uint16_t)pdest, (uint16_t)&COM_UART1, (uint16_t)&COM_UART2,
 189   1              // (uint16_t)&COM_UART3, (uint16_t)&COM_UART4);
 190   1      
 191   1              /*æ£€æµ‹å‘èµ·è¯·æ±‚æ¥æ”¶ç¼“å†²åŒº*/
 192   1              if ((psrc->LNode[psrc->Rptr].Frame_Flag))
 193   1              {
 194   2                      // printf("1->>source %bd, target %bd, pdest %d, ptr 0x%X\r\n",
 195   2                              //    psrc->LNode[psrc->Rptr].Source_Channel, psrc->LNode[psrc->Rptr].Target_Channel, psrc, psrc->Rptr)
             -;
 196   2      
 197   2                      /*æ£€æŸ¥å½“å‰èŠ‚ç‚¹æºåœ°å€å’Œç›®æ ‡åœ°å€æ˜¯å¦ä¸æ­£åœ¨æ‰§è¡Œä¸Šç›®æ ‡ç›¸åŒ*/
 198   2                      if ((psrc->LNode[psrc->Rptr].Source_Channel != src) || (psrc->LNode[psrc->Rptr].Target_Channel != dest))
 199   2                      {
 200   3                              // return;
 201   3                              goto BANK2;
 202   3                      }
 203   2                      /*æ ‡è®°è¯¥æ¥æ”¶å¸§ä»¥è¿›è¡Œå¤„ç†*/
 204   2                      psrc->LNode[psrc->Rptr].Frame_Flag = false;
 205   2                      if (dest == CHANNEL_RS485)
 206   2                      {
 207   3                              /*å…è®¸485å‘é€*/
 208   3                              USART3_EN = 1;
 209   3                              /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½ä¸
             -åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 210   3                              psrc->LNode[psrc->Rptr].Rx_Length += 1U;
 211   3                      }
 212   2                      /*å¯åŠ¨å¯¹åº”ç«¯ç¡¬ä»¶æ•°æ®è½¬å‘*/
 213   2                      Uartx_SendStr(peuart, psrc->LNode[psrc->Rptr].Rx_Buffer, psrc->LNode[psrc->Rptr].Rx_Length);
 214   2                      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 215   2                      psrc->LNode[psrc->Rptr].Rx_Length = 0;
 216   2                      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 217   2                      memset(&psrc->LNode[psrc->Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 218   2                      if (dest == CHANNEL_RS485)
 219   2                      {
 220   3                              /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 221   3                              USART3_EN = 0;
 222   3                      }
 223   2                      /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 224   2                      psrc->Rptr = ((psrc->Rptr + 1U) % MAX_NODE);
 225   2              }
 226   1      
 227   1      BANK2:
 228   1              // pdest = Get_Target_Channel(pdest->LNode[pdest->Rptr].Source_Channel);
 229   1              // psuart = Get_Target_Uart(pdest->LNode[pdest->Rptr].Target_Channel);
 230   1      
 231   1              // /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
 232   1              // if ((pdest->LNode[pdest->Rptr].Frame_Flag))
 233   1              // {
 234   1              //      printf("2->>source %bd, target %bd, pdest %d, ptr 0x%X\r\n\r\n",
 235   1              //                 pdest->LNode[pdest->Rptr].Source_Channel, pdest->LNode[pdest->Rptr].Target_Channel, pdest, pdest-
             ->Rptr);
 236   1      
 237   1              //      /*æ£€æŸ¥ç›®æ ‡ç«¯æ˜¯å¦ä¸å½“å‰èŠ‚ç‚¹æ•°æ®ç›®æ ‡ç›¸åŒ*/
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 17:07:55 PAGE 5   

 238   1              //      // if ((pdest->LNode[pdest->Rptr].Source_Channel != dest) || (pdest->LNode[pdest->Rptr].Target_Channe
             -l != src))
 239   1              //      // {
 240   1              //      //      return;
 241   1              //      //      // goto BANK1;
 242   1              //      // }
 243   1              //      /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
 244   1              //      pdest->LNode[pdest->Rptr].Frame_Flag = false;
 245   1              //      if (src == CHANNEL_RS485)
 246   1              //      {
 247   1              //              /*å…è®¸485å‘é€*/
 248   1              //              USART3_EN = 1;
 249   1              //              /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½
             -ä¸åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 250   1              //              pdest->LNode[pdest->Rptr].Rx_Length += 1U;
 251   1              //      }
 252   1              //      /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
 253   1              //      Uartx_SendStr(psuart, pdest->LNode[pdest->Rptr].Rx_Buffer, pdest->LNode[pdest->Rptr].Rx_Length);
 254   1              //      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 255   1              //      pdest->LNode[pdest->Rptr].Rx_Length = 0;
 256   1              //      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 257   1              //      memset(&pdest->LNode[pdest->Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 258   1              //      if (src == CHANNEL_RS485)
 259   1              //      {
 260   1              //              /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 261   1              //              USART3_EN = 0;
 262   1              //      }
 263   1              //      /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 264   1              //      pdest->Rptr = ((pdest->Rptr + 1U) % MAX_NODE);
 265   1              // }
 266   1      
 267   1              for (i = 0; i < MAX_NODE; i++)
 268   1              {
 269   2                      /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
 270   2                      if ((pdest->LNode[i].Frame_Flag))
 271   2                      {
 272   3                              if ((pdest->LNode[i].Source_Channel != dest) || (pdest->LNode[i].Target_Channel != src))
 273   3                              {
 274   4                                      break;
 275   4                                      // goto BANK1;
 276   4                              }
 277   3                              /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
 278   3                              pdest->LNode[i].Frame_Flag = false;
 279   3                              if (src == CHANNEL_RS485)
 280   3                              {
 281   4                                      /*å…è®¸485å‘é€*/
 282   4                                      USART3_EN = 1;
 283   4                                      /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½ä¸
             -åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 284   4                                      pdest->LNode[i].Rx_Length += 1U;
 285   4                              }
 286   3                              /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
 287   3                              Uartx_SendStr(psuart, pdest->LNode[i].Rx_Buffer, pdest->LNode[i].Rx_Length);
 288   3                              /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 289   3                              pdest->LNode[i].Rx_Length = 0;
 290   3                              /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 291   3                              memset(&pdest->LNode[i].Rx_Buffer[0], 0, MAX_SIZE);
 292   3                              if (src == CHANNEL_RS485)
 293   3                              {
 294   4                                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 295   4                                      USART3_EN = 0;
 296   4                              }
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 17:07:55 PAGE 6   

 297   3                              /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 298   3                              // i = ((i + 1U) % MAX_NODE);
 299   3                      }
 300   2              }
 301   1      }
 302          
 303          // void Rs485_to_Plc(void)
 304          // {
 305          //      /*STCä¸²å£4æ”¶åˆ°PLCå‘å‡ºçš„æ•°æ®*/
 306          //      if ((COM_UART3.LNode[COM_UART3.Rptr].Frame_Flag)) //&& (COM_UART4.LNode[COM_UART4.Rptr].Rx_Length)
 307          //      {
 308          //              /*å¦‚æœä¸²å£4æ¥æ”¶åˆ°çš„æ•°æ®å¸§ä¸æ˜¯EBMæ‰€éœ€çš„ï¼Œè¿‡æ»¤æ‰*/
 309          //              // if (COM_UART3.LNode[COM_UART3.Rptr].Rx_Buffer[0] != MODBUS_SLAVEADDR)
 310          //              { /*æ ‡è®°è¯¥æ¥æ”¶å¸§ä»¥è¿›è¡Œå¤„ç†*/
 311          //                      COM_UART3.LNode[COM_UART3.Rptr].Frame_Flag = false;
 312          //                      /*å…è®¸485å‘é€*/
 313          //                      // USART3_EN = 1;
 314          //                      /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½
             -ä¸åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 315          //                      Uartx_SendStr(&Uart4, COM_UART3.LNode[COM_UART3.Rptr].Rx_Buffer, COM_UART3.LNode[COM_UART3.Rptr].Rx_
             -Length + 1U);
 316          //                      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 317          //                      COM_UART3.LNode[COM_UART3.Rptr].Rx_Length = 0;
 318          //                      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 319          //                      memset(&COM_UART3.LNode[COM_UART3.Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 320          //                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 321          //                      // USART3_EN = 0;
 322          //                      /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 323          //                      SET_RPTR(3);
 324          //              }
 325          
 326          //              /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
 327          //              if ((COM_UART4.LNode[COM_UART4.Rptr].Frame_Flag)) //&& (COM_UART3.LNode[COM_UART3.Rptr].Rx_Length)
 328          //              {
 329          //                      /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
 330          //                      COM_UART4.LNode[COM_UART4.Rptr].Frame_Flag = false;
 331          //                      /*å…è®¸485å‘é€*/
 332          //                      USART3_EN = 1;
 333          //                      /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
 334          //                      Uartx_SendStr(&Uart3, COM_UART4.LNode[COM_UART4.Rptr].Rx_Buffer, COM_UART4.LNode[COM_UART4.Rptr].Rx_
             -Length + 1U);
 335          //                      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 336          //                      COM_UART4.LNode[COM_UART4.Rptr].Rx_Length = 0;
 337          //                      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 338          //                      memset(&COM_UART4.LNode[COM_UART4.Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 339          //                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 340          //                      USART3_EN = 0;
 341          //                      /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 342          //                      SET_RPTR(4);
 343          //              }
 344          //      }
 345          // }
 346          
 347          /*ç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–è¯¥æ¨¡å—*/
 348          #pragma OPTIMIZE(9)
 349          
 350          /**
 351           * @brief       è·å–16bitCRCç 
 352           * @details
 353           * @param       *ptr:å‚ä¸æ ¡éªŒæ•°æ®æŒ‡é’ˆ,length:æ•°æ®é•¿åº¦,init_dat:å‚ä¸è¿ç®—ç›®æ ‡æ•°æ®
 354           * @retval      None
 355           */
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 17:07:55 PAGE 7   

 356          uint16_t getCrc16(uint8_t *ptr, uint8_t length, uint16_t init_dat)
 357          {
 358   1              uint8_t i = 0;
 359   1              uint16_t j = 0;
 360   1              uint16_t crc16 = init_dat;
 361   1      
 362   1              for (i = 0; i < length; i++)
 363   1              {
 364   2                      crc16 ^= *ptr++;
 365   2      
 366   2                      for (j = 0; j < 8; j++)
 367   2                      {
 368   3                              if (crc16 & 0x0001)
 369   3                              {
 370   4                                      crc16 = (crc16 >> 1) ^ 0xa001;
 371   4                              }
 372   3                              else
 373   3                              {
 374   4                                      crc16 = crc16 >> 1;
 375   4                              }
 376   3                      }
 377   2              }
 378   1              return (crc16);
 379   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1081    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   4632      28
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
