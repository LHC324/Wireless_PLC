C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 14:13:58 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE REPORT
OBJECT MODULE PLACED IN .\Objects\report.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\report.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeMod
                    -Bus\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\report.lst) OBJECT(.\Objects\report.obj)

line level    source

   1          #include "report.h"
   2          #include "usart.h"
   3          
   4          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest);
   5          void Uart_DataForward(SEL_CHANNEL Src, SEL_CHANNEL Dest);
   6          void Plc_To_Rs485(void);
   7          void Wifi_To_Plc(void);
   8          void Rs485_to_Plc(void);
   9          
  10          /*å®šä¹‰å½“å‰ä¸²å£äº¤æ¢åºåˆ—*/
  11          // const ComData_Handle ComData_Array[] =
  12          //      {
  13          //              {CHANNEL_PLC, CHANNEL_RS485, Plc_To_Rs485},
  14          //              {CHANNEL_WIFI, CHANNEL_PLC, Wifi_To_Plc},
  15          //              //      {CHANNEL_LAN,  CHANNEL_PLC,   Lan_To_Plc}
  16          // };
  17          
  18          const ComData_Handle code ComData_Array[] =
  19                  {
  20                          // {CHANNEL_PLC, CHANNEL_RS485, Public_DataHandle},
  21                          {CHANNEL_WIFI, CHANNEL_PLC, Public_DataHandle},
  22                          {CHANNEL_LAN, CHANNEL_PLC, Public_DataHandle},
  23                          {CHANNEL_RS485, CHANNEL_PLC, Public_DataHandle}
  24                  };
  25          
  26          #define COMDATA_SIZE (sizeof(ComData_Array) / sizeof(ComData_Handle))
  27          
  28          /*åˆ›å»º4æ¡é“¾é˜Ÿ*/
  29          Uart_List xdata Uart_LinkList[MAX_LQUEUE] = {0};
  30          
  31          /**
  32           * @brief       åˆå§‹åŒ–é™æ€é“¾é˜Ÿ
  33           * @details
  34           * @param       *List:å½“å‰é“¾é˜ŸæŒ‡é’ˆ
  35           * @retval      None
  36           */
  37          void Init_ListQueue(Uart_List *List)
  38          {
  39   1              uint8_t j = 0;
  40   1      
  41   1              for (j = 0; j < MAX_NODE; j++)
  42   1              {
  43   2                      /*åˆå§‹åŒ–é˜Ÿåˆ—æ•°æ®åŸŸ*/
  44   2                      List->LNode[j].Source_Channel = CHANNEL_IDLE;
  45   2                      List->LNode[j].Target_Channel = CHANNEL_IDLE;
  46   2                      List->LNode[j].Frame_Flag = false;
  47   2                      List->LNode[j].Timer_Flag = false;
  48   2                      List->LNode[j].Rx_Length = 0;
  49   2                      List->LNode[j].OverTime = MAX_SILENCE;
  50   2                      memset(&List->LNode[j].Rx_Buffer[0], 0, MAX_SIZE);
  51   2              }
  52   1              // List->Buffer_Size = buf_size;
  53   1              /*åˆå§‹åŒ–é“¾è¡¨èŠ‚ç‚¹è¯»å†™æŒ‡é’ˆ*/
  54   1              List->Wptr = List->Rptr = 0;
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 14:13:58 PAGE 2   

  55   1      }
  56          
  57          /**
  58           * @brief       ä¸²å£1å¯¹1æ•°æ®è½¬å‘
  59           * @details
  60           * @param       None
  61           * @retval      None
  62           */
  63          // void Uart_DataForward(SEL_CHANNEL Src, SEL_CHANNEL Dest)
  64          // {
  65          //      uint8_t i = 0;
  66          
  67          //      for (i = 0; i < COMDATA_SIZE; i++)
  68          //      {
  69          //              if ((Src == ComData_Array[i].Source_Channel) && (Dest == ComData_Array[i].Target_Channel))
  70          //              {
  71          //                      ComData_Array[i].pHandle();
  72          //              }
  73          //      }
  74          // }
  75          
  76          /**
  77           * @brief       ä¸²å£äº‹ä»¶å¤„ç†
  78           * @details
  79           * @param       None
  80           * @retval      None
  81           */
  82          void Uart_Handle(void)
  83          {
  84   1              static uint8_t i = 0;
  85   1      
  86   1              // /*å…³é—­ä¸²å£4æ¥æ”¶ä¸­æ–­*/
  87   1              // // S4CON &= ~S4REN;
  88   1      
  89   1              for (i = 0; i < COMDATA_SIZE; i++)
  90   1              {       
  91   2                      ComData_Array[i].pHandle(ComData_Array[i].Source_Channel, ComData_Array[i].Target_Channel);
  92   2              }
  93   1              // ComData_Array[0].pHandle(ComData_Array[0].Source_Channel, ComData_Array[0].Target_Channel);
  94   1              // ComData_Array[1].pHandle(ComData_Array[1].Source_Channel, ComData_Array[1].Target_Channel);
  95   1              // ComData_Array[2].pHandle(ComData_Array[2].Source_Channel, ComData_Array[2].Target_Channel);
  96   1              // USART3_EN = 1;
  97   1              // Uartx_SendStr(&Uart3, "\x01\x02\x03", 3);
  98   1              // USART3_EN = 0;
  99   1              /*å½“å‰æ— è¯·æ±‚é€šé“*/
 100   1              // current_request_channel = CHANNEL_IDLE;
 101   1              // Rs485_to_Plc();
 102   1      
 103   1              // Public_DataHandle(CHANNEL_RS485, CHANNEL_PLC);
 104   1      
 105   1              // Public_DataHandle(CHANNEL_WIFI, CHANNEL_PLC);
 106   1              // Public_DataHandle(CHANNEL_LAN, CHANNEL_PLC);
 107   1      }
 108          
 109          /*ç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–è¯¥æ¨¡å—*/
 110          // #pragma OPTIMIZE(2)
 111          /**
 112           * @brief       è·å¾—ç›®æ ‡é€šé“é“¾è¡¨åœ°å€
 113           * @details
 114           * @param       channel é€šé“å·
 115           * @retval      p æŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆ
 116           */
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 14:13:58 PAGE 3   

 117          static Uart_List *Get_Target_Channel(channel)
 118          {
 119   1              Uart_List *p = NULL;
 120   1              switch (channel)
 121   1              {
 122   2              case CHANNEL_LAN:
 123   2                      p = &COM_UART1;
 124   2                      break;
 125   2              case CHANNEL_WIFI:
 126   2                      p = &COM_UART2;
 127   2                      break;
 128   2              case CHANNEL_RS485:
 129   2                      p = &COM_UART3;
 130   2                      break;
 131   2              case CHANNEL_PLC:
 132   2                      p = &COM_UART4;
 133   2                      break;
 134   2              default:
 135   2                      break;
 136   2              }
 137   1              return p;
 138   1      }
 139          
 140          /**
 141           * @brief       è·å¾—ç›®æ ‡é€šé“å¯¹åº”ä¸²å£
 142           * @details
 143           * @param       channel é€šé“å·
 144           * @retval      p æŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆ
 145           */
 146          static Uart_HandleTypeDef *Get_Target_Uart(channel)
 147          {
 148   1              Uart_HandleTypeDef *p = NULL;
 149   1              switch (channel)
 150   1              {
 151   2              case CHANNEL_LAN:
 152   2                      p = &Uart1;
 153   2                      break;
 154   2              case CHANNEL_WIFI:
 155   2                      p = &Uart2;
 156   2                      break;
 157   2              case CHANNEL_RS485:
 158   2                      p = &Uart3;
 159   2                      break;
 160   2              case CHANNEL_PLC:
 161   2                      p = &Uart4;
 162   2                      break;
 163   2              default:
 164   2                      break;
 165   2              }
 166   1              return p;
 167   1      }
 168          
 169          /**
 170           * @brief       æ•°æ®å¸§å…¬å…±è½¬å‘
 171           * @details
 172           * @param       src æ•°æ®æºè¯·æ±‚é€šé“
 173           * @param   dest æ•°æ®äº¤ä»˜é€šé“
 174           * @retval      None
 175           */
 176          // void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest)
 177          // {
 178          //      Uart_List *psrc = Get_Target_Channel(src);
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 14:13:58 PAGE 4   

 179          //      Uart_List *pdest = Get_Target_Channel(dest);
 180          //      Uart_HandleTypeDef *psuart = Get_Target_Uart(src);
 181          //      Uart_HandleTypeDef *peuart = Get_Target_Uart(dest);
 182          //      uint8_t i = 0;
 183          
 184          //      if ((psrc == NULL) || (pdest == NULL) || (psuart == NULL) || (peuart == NULL))
 185          //      {
 186          //              return;
 187          //      }
 188          //      // printf ("psrc %d, pdest %d, %d, %d, %d, %d\r\n",
 189          //      // (uint16_t)psrc, (uint16_t)pdest, (uint16_t)&COM_UART1, (uint16_t)&COM_UART2,
 190          //      // (uint16_t)&COM_UART3, (uint16_t)&COM_UART4);
 191          
 192          //      /*æ£€æµ‹å‘èµ·è¯·æ±‚æ¥æ”¶ç¼“å†²åŒº*/
 193          //      if (psrc->LNode[psrc->Rptr].Frame_Flag)
 194          //      {
 195          //              printf("1->>source %bd, target %bd, pdest %d, ptr 0x%X\r\n",
 196          //                         psrc->LNode[psrc->Rptr].Source_Channel, psrc->LNode[psrc->Rptr].Target_Channel, psrc, psrc->Rptr)
             -;
 197          
 198          //              /*æ£€æŸ¥å½“å‰èŠ‚ç‚¹æºåœ°å€å’Œç›®æ ‡åœ°å€æ˜¯å¦ä¸æ­£åœ¨æ‰§è¡Œä¸Šç›®æ ‡ç›¸åŒ*/
 199          //              if ((psrc->LNode[psrc->Rptr].Source_Channel != src) || (psrc->LNode[psrc->Rptr].Target_Channel != des
             -t))
 200          //              {
 201          //                      // return;
 202          //                      goto BANK2;
 203          //              }
 204          //              /*æ ‡è®°è¯¥æ¥æ”¶å¸§ä»¥è¿›è¡Œå¤„ç†*/
 205          //              psrc->LNode[psrc->Rptr].Frame_Flag = false;
 206          //              if (dest == CHANNEL_RS485)
 207          //              {
 208          //                      /*å…è®¸485å‘é€*/
 209          //                      USART3_EN = 1;
 210          //                      /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½
             -ä¸åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 211          //                      psrc->LNode[psrc->Rptr].Rx_Length += 1U;
 212          //              }
 213          //              /*å¯åŠ¨å¯¹åº”ç«¯ç¡¬ä»¶æ•°æ®è½¬å‘*/
 214          //              Uartx_SendStr(peuart, psrc->LNode[psrc->Rptr].Rx_Buffer, psrc->LNode[psrc->Rptr].Rx_Length);
 215          //              /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 216          //              psrc->LNode[psrc->Rptr].Rx_Length = 0;
 217          //              /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 218          //              memset(&psrc->LNode[psrc->Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 219          //              if (dest == CHANNEL_RS485)
 220          //              {
 221          //                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 222          //                      USART3_EN = 0;
 223          //              }
 224          //              /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 225          //              psrc->Rptr = ((psrc->Rptr + 1U) % MAX_NODE);
 226          //      }
 227          
 228          // BANK2:
 229          //      // pdest = Get_Target_Channel(pdest->LNode[pdest->Rptr].Source_Channel);
 230          //      // psuart = Get_Target_Uart(pdest->LNode[pdest->Rptr].Target_Channel);
 231          
 232          //      // /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
 233          //      // if ((pdest->LNode[pdest->Rptr].Frame_Flag))
 234          //      // {
 235          //      //      printf("2->>source %bd, target %bd, pdest %d, ptr 0x%X\r\n\r\n",
 236          //      //                 pdest->LNode[pdest->Rptr].Source_Channel, pdest->LNode[pdest->Rptr].Target_Channel, pdest, pde
             -st->Rptr);
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 14:13:58 PAGE 5   

 237          
 238          //      //      /*æ£€æŸ¥ç›®æ ‡ç«¯æ˜¯å¦ä¸å½“å‰èŠ‚ç‚¹æ•°æ®ç›®æ ‡ç›¸åŒ*/
 239          //      //      // if ((pdest->LNode[pdest->Rptr].Source_Channel != dest) || (pdest->LNode[pdest->Rptr].Target_Cha
             -nnel != src))
 240          //      //      // {
 241          //      //      //      return;
 242          //      //      //      // goto BANK1;
 243          //      //      // }
 244          //      //      /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
 245          //      //      pdest->LNode[pdest->Rptr].Frame_Flag = false;
 246          //      //      if (src == CHANNEL_RS485)
 247          //      //      {
 248          //      //              /*å…è®¸485å‘é€*/
 249          //      //              USART3_EN = 1;
 250          //      //              /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆš
             -å¥½ä¸åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 251          //      //              pdest->LNode[pdest->Rptr].Rx_Length += 1U;
 252          //      //      }
 253          //      //      /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
 254          //      //      Uartx_SendStr(psuart, pdest->LNode[pdest->Rptr].Rx_Buffer, pdest->LNode[pdest->Rptr].Rx_Length);
 255          //      //      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 256          //      //      pdest->LNode[pdest->Rptr].Rx_Length = 0;
 257          //      //      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 258          //      //      memset(&pdest->LNode[pdest->Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 259          //      //      if (src == CHANNEL_RS485)
 260          //      //      {
 261          //      //              /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 262          //      //              USART3_EN = 0;
 263          //      //      }
 264          //      //      /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 265          //      //      pdest->Rptr = ((pdest->Rptr + 1U) % MAX_NODE);
 266          //      // }
 267          
 268          //      for (i = 0; i < MAX_NODE; i++)
 269          //      {
 270          //              /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
 271          //              if (pdest->LNode[i].Frame_Flag)
 272          //              {
 273          //                      printf("2->>source %bd, target %bd, pdest %d, ptr 0x%X\r\n\r\n",
 274          //                      pdest->LNode[i].Source_Channel, pdest->LNode[i].Target_Channel, pdest, i);
 275          //                      if ((pdest->LNode[i].Source_Channel != dest) || (pdest->LNode[i].Target_Channel != src))
 276          //                      {
 277          //                              // break;
 278          //                              continue;
 279          //                              // goto BANK1;
 280          //                      }
 281          //                      /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
 282          //                      pdest->LNode[i].Frame_Flag = false;
 283          //                      if (src == CHANNEL_RS485)
 284          //                      {
 285          //                              /*å…è®¸485å‘é€*/
 286          //                              USART3_EN = 1;
 287          //                              /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥
             -½ä¸åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 288          //                              pdest->LNode[i].Rx_Length += 1U;
 289          //                      }
 290          //                      /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
 291          //                      Uartx_SendStr(psuart, pdest->LNode[i].Rx_Buffer, pdest->LNode[i].Rx_Length);
 292          //                      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 293          //                      pdest->LNode[i].Rx_Length = 0;
 294          //                      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 295          //                      memset(&pdest->LNode[i].Rx_Buffer[0], 0, MAX_SIZE);
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 14:13:58 PAGE 6   

 296          //                      if (src == CHANNEL_RS485)
 297          //                      {
 298          //                              /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 299          //                              USART3_EN = 0;
 300          //                      }
 301          //                      /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 302          //                      // i = ((i + 1U) % MAX_NODE);
 303          //              }
 304          //      }
 305          // }
 306          
 307          /**
 308           * @brief       æ•°æ®å¸§å…¬å…±è½¬å‘
 309           * @details
 310           * @param       src æ•°æ®æºè¯·æ±‚é€šé“
 311           * @param   dest æ•°æ®äº¤ä»˜é€šé“
 312           * @retval      None
 313           */
 314          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest) 
 315          {
 316   1              Uart_List * const psrc = Get_Target_Channel(src);
 317   1              Uart_List * const pdest = Get_Target_Channel(dest);
 318   1              Uart_HandleTypeDef * const psuart = Get_Target_Uart(src);
 319   1              Uart_HandleTypeDef * const peuart = Get_Target_Uart(dest);
 320   1              static uint8_t i = 0;
 321   1      
 322   1              if ((psrc == NULL) || (pdest == NULL) || (psuart == NULL) || (peuart == NULL))
 323   1              {
 324   2                      return;
 325   2              }
 326   1      #if (USE_PRINTF_DEBUG)
                      // printf ("psrc %d, pdest %d, %d, %d, %d, %d\r\n",
                      // (uint16_t)psrc, (uint16_t)pdest, (uint16_t)&COM_UART1, (uint16_t)&COM_UART2,
                      // (uint16_t)&COM_UART3, (uint16_t)&COM_UART4);
              #endif
 331   1              /*æ£€æŸ¥å½“å‰èŠ‚ç‚¹æºåœ°å€å’Œç›®æ ‡åœ°å€æ˜¯å¦ä¸æ­£åœ¨æ‰§è¡Œä¸Šç›®æ ‡ç›¸åŒ*/
 332   1              if ((psrc->LNode[psrc->Rptr].Source_Channel == src) && (psrc->LNode[psrc->Rptr].Target_Channel == dest))
 333   1              {
 334   2                      /*æ£€æµ‹å‘èµ·è¯·æ±‚æ¥æ”¶ç¼“å†²åŒº*/
 335   2                      if (psrc->LNode[psrc->Rptr].Frame_Flag)
 336   2                      {
 337   3      #if (USE_PRINTF_DEBUG)
                                      printf("1->>source %bd, target %bd, pdest %d, ptr 0x%X\r\n",
                                      psrc->LNode[psrc->Rptr].Source_Channel, psrc->LNode[psrc->Rptr].Target_Channel, psrc, psrc->Rptr);
              #endif
 341   3                              /*æ ‡è®°è¯¥æ¥æ”¶å¸§ä»¥è¿›è¡Œå¤„ç†*/
 342   3                              psrc->LNode[psrc->Rptr].Frame_Flag = false;
 343   3                              if (dest == CHANNEL_RS485)
 344   3                              {
 345   4                                      /*å…è®¸485å‘é€*/
 346   4                                      USART3_EN = 1;
 347   4                                      /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½ä¸
             -åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 348   4                                      psrc->LNode[psrc->Rptr].Rx_Length += 1U;
 349   4                              }
 350   3                              /*å¯åŠ¨å¯¹åº”ç«¯ç¡¬ä»¶æ•°æ®è½¬å‘*/
 351   3                              Uartx_SendStr(peuart, psrc->LNode[psrc->Rptr].Rx_Buffer, psrc->LNode[psrc->Rptr].Rx_Length);
 352   3                              /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 353   3                              psrc->LNode[psrc->Rptr].Rx_Length = 0;
 354   3                              /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 355   3                              memset(&psrc->LNode[psrc->Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 356   3                              if (dest == CHANNEL_RS485)
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 14:13:58 PAGE 7   

 357   3                              {
 358   4                                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 359   4                                      USART3_EN = 0;
 360   4                              }
 361   3                              /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 362   3                              psrc->Rptr = ((psrc->Rptr + 1U) % MAX_NODE);
 363   3                      }
 364   2              }
 365   1      
 366   1              for (i = 0; i < MAX_NODE; i++)
 367   1              {
 368   2                      if ((pdest->LNode[i].Source_Channel != dest) || (pdest->LNode[i].Target_Channel != src))
 369   2                      {
 370   3                              continue;
 371   3                      }
 372   2                      /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
 373   2                      if (pdest->LNode[i].Frame_Flag)
 374   2                      {
 375   3      #if (USE_PRINTF_DEBUG)
                                      printf("2->>source %bd, target %bd, pdest %d, ptr 0x%X\r\n\r\n",
                                      pdest->LNode[i].Source_Channel, pdest->LNode[i].Target_Channel, pdest, i);
              #endif          
 379   3                              /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
 380   3                              pdest->LNode[i].Frame_Flag = false;
 381   3                              if (src == CHANNEL_RS485)
 382   3                              {
 383   4                                      /*å…è®¸485å‘é€*/
 384   4                                      USART3_EN = 1;
 385   4                                      /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½ä¸
             -åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 386   4                                      pdest->LNode[i].Rx_Length += 1U;
 387   4                              }
 388   3                              /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
 389   3                              Uartx_SendStr(psuart, pdest->LNode[i].Rx_Buffer, pdest->LNode[i].Rx_Length);
 390   3                              /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 391   3                              pdest->LNode[i].Rx_Length = 0;
 392   3                              /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 393   3                              memset(&pdest->LNode[i].Rx_Buffer[0], 0, MAX_SIZE);
 394   3                              if (src == CHANNEL_RS485)
 395   3                              {
 396   4                                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 397   4                                      USART3_EN = 0;
 398   4                              }
 399   3                      }
 400   2              }
 401   1      }
 402          
 403          // void Rs485_to_Plc(void)
 404          // {
 405          //      /*STCä¸²å£4æ”¶åˆ°PLCå‘å‡ºçš„æ•°æ®*/
 406          //      if ((COM_UART3.LNode[COM_UART3.Rptr].Frame_Flag)) //&& (COM_UART4.LNode[COM_UART4.Rptr].Rx_Length)
 407          //      {
 408          //              /*å¦‚æœä¸²å£4æ¥æ”¶åˆ°çš„æ•°æ®å¸§ä¸æ˜¯EBMæ‰€éœ€çš„ï¼Œè¿‡æ»¤æ‰*/
 409          //              // if (COM_UART3.LNode[COM_UART3.Rptr].Rx_Buffer[0] != MODBUS_SLAVEADDR)
 410          //              { /*æ ‡è®°è¯¥æ¥æ”¶å¸§ä»¥è¿›è¡Œå¤„ç†*/
 411          //                      COM_UART3.LNode[COM_UART3.Rptr].Frame_Flag = false;
 412          //                      /*å…è®¸485å‘é€*/
 413          //                      // USART3_EN = 1;
 414          //                      /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½
             -ä¸åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 415          //                      Uartx_SendStr(&Uart4, COM_UART3.LNode[COM_UART3.Rptr].Rx_Buffer, COM_UART3.LNode[COM_UART3.Rptr].Rx_
             -Length + 1U);
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 14:13:58 PAGE 8   

 416          //                      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 417          //                      COM_UART3.LNode[COM_UART3.Rptr].Rx_Length = 0;
 418          //                      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 419          //                      memset(&COM_UART3.LNode[COM_UART3.Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 420          //                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 421          //                      // USART3_EN = 0;
 422          //                      /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 423          //                      SET_RPTR(3);
 424          //              }
 425          
 426          //              /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
 427          //              if ((COM_UART4.LNode[COM_UART4.Rptr].Frame_Flag)) //&& (COM_UART3.LNode[COM_UART3.Rptr].Rx_Length)
 428          //              {
 429          //                      /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
 430          //                      COM_UART4.LNode[COM_UART4.Rptr].Frame_Flag = false;
 431          //                      /*å…è®¸485å‘é€*/
 432          //                      USART3_EN = 1;
 433          //                      /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
 434          //                      Uartx_SendStr(&Uart3, COM_UART4.LNode[COM_UART4.Rptr].Rx_Buffer, COM_UART4.LNode[COM_UART4.Rptr].Rx_
             -Length + 1U);
 435          //                      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 436          //                      COM_UART4.LNode[COM_UART4.Rptr].Rx_Length = 0;
 437          //                      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 438          //                      memset(&COM_UART4.LNode[COM_UART4.Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 439          //                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 440          //                      USART3_EN = 0;
 441          //                      /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 442          //                      SET_RPTR(4);
 443          //              }
 444          //      }
 445          // }
 446          
 447          /*ç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–è¯¥æ¨¡å—*/
 448          #pragma OPTIMIZE(9)
 449          
 450          /**
 451           * @brief       è·å–16bitCRCç 
 452           * @details
 453           * @param       *ptr:å‚ä¸æ ¡éªŒæ•°æ®æŒ‡é’ˆ,length:æ•°æ®é•¿åº¦,init_dat:å‚ä¸è¿ç®—ç›®æ ‡æ•°æ®
 454           * @retval      None
 455           */
 456          uint16_t getCrc16(uint8_t *ptr, uint8_t length, uint16_t init_dat)
 457          {
 458   1              uint8_t i = 0;
 459   1              uint16_t j = 0;
 460   1              uint16_t crc16 = init_dat;
 461   1      
 462   1              for (i = 0; i < length; i++)
 463   1              {
 464   2                      crc16 ^= *ptr++;
 465   2      
 466   2                      for (j = 0; j < 8; j++)
 467   2                      {
 468   3                              if (crc16 & 0x0001)
 469   3                              {
 470   4                                      crc16 = (crc16 >> 1) ^ 0xa001;
 471   4                              }
 472   3                              else
 473   3                              {
 474   4                                      crc16 = crc16 >> 1;
 475   4                              }
 476   3                      }
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 14:13:58 PAGE 9   

 477   2              }
 478   1              return (crc16);
 479   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1066    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =   4618      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
