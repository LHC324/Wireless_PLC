C51 COMPILER V9.60.0.0   REPORT                                                            03/03/2023 11:28:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE REPORT
OBJECT MODULE PLACED IN .\Objects\report.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\report.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeMod
                    -Bus\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\report.lst) OBJECT(.\Objects\report.obj)

line level    source

   1          #include "report.h"
   2          #include "usart.h"
   3          
   4          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest);
   5          void Uart_DataForward(SEL_CHANNEL Src, SEL_CHANNEL Dest);
   6          
   7          /*å®šä¹‰å½“å‰ä¸²å£äº¤æ¢åºåˆ—*/
   8          const ComData_Handle code ComData_Array[] =
   9                  {
  10                          // {CHANNEL_PLC, CHANNEL_RS485, Public_DataHandle},
  11                          {CHANNEL_WIFI, CHANNEL_PLC, Public_DataHandle},
  12                          {CHANNEL_LAN, CHANNEL_PLC, Public_DataHandle},
  13                          {CHANNEL_RS485, CHANNEL_PLC, Public_DataHandle},
  14                          /*ä½œä¸ºä¸»æœºæ—¶æƒ…å†µ*/
  15                          {CHANNEL_PLC, CHANNEL_WIFI, Public_DataHandle},
  16                          {CHANNEL_PLC, CHANNEL_LAN, Public_DataHandle},
  17                          {CHANNEL_PLC, CHANNEL_RS485, Public_DataHandle}
  18                  };
  19          
  20          #define COMDATA_SIZE (sizeof(ComData_Array) / sizeof(ComData_Handle))
  21          
  22          /*åˆ›å»º4æ¡é“¾é˜Ÿ*/
  23          Uart_List xdata Uart_LinkList[MAX_LQUEUE] = {0};
  24          #if USING_PORT0_SINGLE
  25          Uart_List_X xdata Uart_Port0 = {0};
  26          #endif
  27          
  28          #if 0
              /**
               * @brief       åˆå§‹åŒ–é™æ€é“¾é˜Ÿ
               * @details
               * @param       *List:å½“å‰é“¾é˜ŸæŒ‡é’ˆ
               * @retval      None
               */
              void Init_ListQueue(Uart_List *List)
              {
                      uint8_t j = 0;
              
                      for (j = 0; j < MAX_NODE; j++)
                      {
                              /*åˆå§‹åŒ–é˜Ÿåˆ—æ•°æ®åŸŸ*/
                              List->LNode[j].Source_Channel = CHANNEL_IDLE;
                              List->LNode[j].Target_Channel = CHANNEL_IDLE;
                              List->LNode[j].Frame_Flag = false;
                              List->LNode[j].Timer_Flag = false;
                              List->LNode[j].Rx_Length = 0;
                              List->LNode[j].OverTime = MAX_SILENCE;
                              memset(&List->LNode[j].Rx_Buffer[0], 0, MAX_SIZE);
                      }
                      // List->Buffer_Size = buf_size;
                      /*åˆå§‹åŒ–é“¾è¡¨èŠ‚ç‚¹è¯»å†™æŒ‡é’ˆ*/
                      List->Wptr = List->Rptr = 0;
              }
              #endif
C51 COMPILER V9.60.0.0   REPORT                                                            03/03/2023 11:28:23 PAGE 2   

  55          
  56          /**
  57           * @brief       ä¸²å£äº‹ä»¶å¤„ç†
  58           * @details
  59           * @param       None
  60           * @retval      None
  61           */
  62          void Uart_Handle(void)
  63          {
  64   1              uint8_t i = 0;
  65   1              
  66   1              if (System_Parameter.WorkMode == SLAVE)
  67   1              {
  68   2                      if (System_Parameter.Ppistate) //ppiæ¨¡å¼ï¼šæ¡æ‰‹é€Ÿåº¦å¿…é¡»è¦å¿«
  69   2                      {
  70   3                              Public_DataHandle(CHANNEL_RS485, CHANNEL_PLC);
  71   3                              return;
  72   3                      }
  73   2                      else
  74   2                              for (i = 0; i < COMDATA_SIZE - 3U; i++)
  75   2                              {       
  76   3                                      ComData_Array[i].pHandle(ComData_Array[i].Source_Channel,                       
  77   3                                      ComData_Array[i].Target_Channel);
  78   3                              }
  79   2              }
  80   1              else
  81   1              {
  82   2                      switch (System_Parameter.CurrentSlave)
  83   2                      {
  84   3                              case ETHERNET_ID: 
  85   3                              {
  86   4                                      ComData_Array[3].pHandle(ComData_Array[3].Source_Channel, ComData_Array[3].Target_Channel);
  87   4                              }break;
  88   3                              case WIFI_ID:
  89   3                              {
  90   4                                      ComData_Array[4].pHandle(ComData_Array[4].Source_Channel, ComData_Array[4].Target_Channel);
  91   4                              }break;
  92   3                              case RS485_ID:
  93   3                              {
  94   4                                      ComData_Array[5].pHandle(ComData_Array[5].Source_Channel, ComData_Array[5].Target_Channel);
  95   4                              }break;
  96   3                              default : break;
  97   3                      }
  98   2              }
  99   1      }
 100          
 101          /*ç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–è¯¥æ¨¡å—*/
 102          // #pragma OPTIMIZE(2)
 103          /**
 104           * @brief       è·å¾—ç›®æ ‡é€šé“é“¾è¡¨åœ°å€
 105           * @details
 106           * @param       channel é€šé“å·
 107           * @retval      p æŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆ
 108           */
 109          static Uart_List *Get_Target_Channel(channel)
 110          {
 111   1              Uart_List *p = NULL;
 112   1              switch (channel)
 113   1              {
 114   2              case CHANNEL_LAN:
 115   2                      p = &COM_UART1;
 116   2                      break;
C51 COMPILER V9.60.0.0   REPORT                                                            03/03/2023 11:28:23 PAGE 3   

 117   2              case CHANNEL_WIFI:
 118   2                      p = &COM_UART2;
 119   2                      break;
 120   2              case CHANNEL_RS485:
 121   2                      p = &COM_UART3;
 122   2                      break;
 123   2              case CHANNEL_PLC:
 124   2      #if !USING_PORT0_SINGLE
                              p = &COM_UART4;
              #endif
 127   2                      break;
 128   2              default:
 129   2                      break;
 130   2              }
 131   1              return p;
 132   1      }
 133          
 134          /**
 135           * @brief       è·å¾—ç›®æ ‡é€šé“å¯¹åº”ä¸²å£
 136           * @details
 137           * @param       channel é€šé“å·
 138           * @retval      p æŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆ
 139           */
 140          static Uart_HandleTypeDef *Get_Target_Uart(channel)
 141          {
 142   1              Uart_HandleTypeDef *p = NULL;
 143   1              switch (channel)
 144   1              {
 145   2              case CHANNEL_LAN:
 146   2                      p = &Uart1;
 147   2                      break;
 148   2              case CHANNEL_WIFI:
 149   2                      p = &Uart2;
 150   2                      break;
 151   2              case CHANNEL_RS485:
 152   2                      p = &Uart3;
 153   2                      break;
 154   2              case CHANNEL_PLC:
 155   2                      p = &Uart4;
 156   2                      break;
 157   2              default:
 158   2                      break;
 159   2              }
 160   1              return p;
 161   1      }
 162          
 163          #if USING_PORT0_SINGLE
 164          /**
 165           * @brief       æ•°æ®å¸§å…¬å…±è½¬å‘
 166           * @details
 167           * @param       src æ•°æ®æºè¯·æ±‚é€šé“
 168           * @param   puart ç›®æ ‡ä¸²å£å¥æŸ„
 169           * @retval      None
 170           */
 171          static void Port0_Send(SEL_CHANNEL src, 
 172                                                     Uart_HandleTypeDef * const puart) 
 173          {
 174   1              if (COM_UART4.Target_Channel != src)
 175   1              {
 176   2                      return;
 177   2              }
 178   1      
C51 COMPILER V9.60.0.0   REPORT                                                            03/03/2023 11:28:23 PAGE 4   

 179   1              /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
 180   1              if (COM_UART4.Frame_Flag)
 181   1              {
 182   2                      /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
 183   2                      COM_UART4.Frame_Flag = false;
 184   2      #if (USE_PRINTF_DEBUG)
                              printf("2->>source %bd, target %bd, src %bd, len %d.\r\n",
                              COM_UART4.Source_Channel, COM_UART4.Target_Channel, src, COM_UART4.Rx_Length);
              #endif          
 188   2                      if (src == CHANNEL_RS485)
 189   2                      {
 190   3                              /*å…è®¸485å‘é€*/
 191   3                              USART3_EN = 1;
 192   3                              /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½ä¸
             -åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 193   3                              COM_UART4.Rx_Length++;
 194   3                      }
 195   2                      /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
 196   2                      Uartx_SendStr(puart, (uint8_t *)&COM_UART4.Rx_Buffer[0], COM_UART4.Rx_Length);
 197   2                      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 198   2                      COM_UART4.Rx_Length = 0;
 199   2                      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 200   2                      // memset(&COM_UART4.Rx_Buffer[0], 0, MAX_SIZE);
 201   2                      if (src == CHANNEL_RS485)
 202   2                      {
 203   3                              /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 204   3                              USART3_EN = 0;
 205   3                      }
 206   2              }
 207   1      }
 208          #endif
 209          
 210          
 211          /**
 212           * @brief       æ•°æ®å¸§å…¬å…±è½¬å‘
 213           * @details
 214           * @param       src æ•°æ®æºè¯·æ±‚é€šé“
 215           * @param   dest æ•°æ®äº¤ä»˜é€šé“
 216           * @retval      None
 217           */
 218          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest) 
 219          {
 220   1              Uart_List * const psrc = Get_Target_Channel(src);
 221   1              Uart_List * const pdest = Get_Target_Channel(dest);
 222   1              Uart_HandleTypeDef * const psuart = Get_Target_Uart(src);
 223   1              Uart_HandleTypeDef * const peuart = Get_Target_Uart(dest);
 224   1      #if !USING_PORT0_SINGLE
                      uint8_t i = 0;
                      if ((psrc == NULL) || (pdest == NULL) || (psuart == NULL) || (peuart == NULL))
                      {
                              return;
                      }
              #else
 231   1      if ((psrc == NULL) || (psuart == NULL) || (peuart == NULL))
 232   1              {
 233   2                      return;
 234   2              }
 235   1      #endif
 236   1      
 237   1      #if (USE_PRINTF_DEBUG)
                      // printf ("psrc %d, pdest %d, %d, %d, %d, %d\r\n",
                      // (uint16_t)psrc, (uint16_t)pdest, (uint16_t)&COM_UART1, (uint16_t)&COM_UART2,
C51 COMPILER V9.60.0.0   REPORT                                                            03/03/2023 11:28:23 PAGE 5   

                      // (uint16_t)&COM_UART3, (uint16_t)&COM_UART4);
              #endif
 242   1              /*ä¸»æœºæ—¶plcç›®æ ‡é€šé“æ— æ³•ç¡®å®š*/
 243   1              if (System_Parameter.WorkMode == MASTER)
 244   1              {
 245   2                      psrc->LNode[psrc->Rptr].Target_Channel = dest;
 246   2              }
 247   1              /*æ£€æŸ¥å½“å‰èŠ‚ç‚¹æºåœ°å€å’Œç›®æ ‡åœ°å€æ˜¯å¦ä¸æ­£åœ¨æ‰§è¡Œä¸Šç›®æ ‡ç›¸åŒ*/
 248   1              if ((psrc->LNode[psrc->Rptr].Source_Channel == src) && 
 249   1                      (psrc->LNode[psrc->Rptr].Target_Channel == dest))
 250   1              {
 251   2                      /*æ£€æµ‹å‘èµ·è¯·æ±‚æ¥æ”¶ç¼“å†²åŒº*/
 252   2                      if (psrc->LNode[psrc->Rptr].Frame_Flag)
 253   2                      {
 254   3      #if (USE_PRINTF_DEBUG)
                                      printf("1->>source %bd, target %bd, ptr %bd, len %d\r\n",
                                      psrc->LNode[psrc->Rptr].Source_Channel, psrc->LNode[psrc->Rptr].Target_Channel, 
                                      psrc->Rptr, psrc->LNode[psrc->Rptr].Rx_Length);
              #endif
 259   3                              /*æ ‡è®°è¯¥æ¥æ”¶å¸§ä»¥è¿›è¡Œå¤„ç†*/
 260   3                              psrc->LNode[psrc->Rptr].Frame_Flag = false;
 261   3                              if (dest == CHANNEL_RS485)
 262   3                              {
 263   4                                      /*å…è®¸485å‘é€*/
 264   4                                      USART3_EN = 1;
 265   4                                      /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½ä¸
             -åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 266   4                                      psrc->LNode[psrc->Rptr].Rx_Length++;
 267   4                              }
 268   3                              /*å¯åŠ¨å¯¹åº”ç«¯ç¡¬ä»¶æ•°æ®è½¬å‘*/
 269   3                              Uartx_SendStr(peuart, psrc->LNode[psrc->Rptr].Rx_Buffer, psrc->LNode[psrc->Rptr].Rx_Length);
 270   3                              /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 271   3                              psrc->LNode[psrc->Rptr].Rx_Length = 0;
 272   3                              /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 273   3                              // memset(&psrc->LNode[psrc->Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 274   3                              if (dest == CHANNEL_RS485)
 275   3                              {
 276   4                                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 277   4                                      USART3_EN = 0;
 278   4                              }
 279   3                              /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 280   3                              psrc->Rptr = ((++psrc->Rptr) & (MAX_NODE - 1));
 281   3                      }
 282   2              }
 283   1      #if USING_PORT0_SINGLE
 284   1              Port0_Send(src, psuart);
 285   1      #else
                      for (i = 0; i < MAX_NODE; i++)
                      {
                              if ((pdest->LNode[i].Source_Channel != dest) || (pdest->LNode[i].Target_Channel != src))
                              {
                                      continue;
                              }
                              /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
                              if (pdest->LNode[i].Frame_Flag)
                              {
              #if (USE_PRINTF_DEBUG)
                                      printf("2->>source %bd, target %bd, ptr %bd, len %d\r\n\r\n",
                                      pdest->LNode[i].Source_Channel, pdest->LNode[i].Target_Channel, 
                                      pdest->Rptr, pdest->LNode[pdest->Rptr].Rx_Length);
              #endif          
                                      /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
C51 COMPILER V9.60.0.0   REPORT                                                            03/03/2023 11:28:23 PAGE 6   

                                      pdest->LNode[i].Frame_Flag = false;
                                      if (src == CHANNEL_RS485)
                                      {
                                              /*å…è®¸485å‘é€*/
                                              USART3_EN = 1;
                                              /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½ä¸
             -åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
                                              pdest->LNode[i].Rx_Length += 1U;
                                      }
                                      /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
                                      Uartx_SendStr(psuart, pdest->LNode[i].Rx_Buffer, pdest->LNode[i].Rx_Length);
                                      /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
                                      pdest->LNode[i].Rx_Length = 0;
                                      /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
                                      // memset(&pdest->LNode[i].Rx_Buffer[0], 0, MAX_SIZE);
                                      if (src == CHANNEL_RS485)
                                      {
                                              /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
                                              USART3_EN = 0;
                                      }
                              }
                      }
              #endif
 323   1      }
 324          
 325          
 326          /*ç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–è¯¥æ¨¡å—*/
 327          #pragma OPTIMIZE(9)
 328          
 329          /**
 330           * @brief       è·å–16bitCRCç 
 331           * @details
 332           * @param       *ptr:å‚ä¸æ ¡éªŒæ•°æ®æŒ‡é’ˆ,length:æ•°æ®é•¿åº¦,init_dat:å‚ä¸è¿ç®—ç›®æ ‡æ•°æ®
 333           * @retval      None
 334           */
 335          uint16_t getCrc16(uint8_t *ptr, uint8_t length, uint16_t init_dat)
 336          {
 337   1              uint8_t i = 0;
 338   1              uint16_t j = 0;
 339   1              uint16_t crc16 = init_dat;
 340   1      
 341   1              for (i = 0; i < length; i++)
 342   1              {
 343   2                      crc16 ^= *ptr++;
 344   2      
 345   2                      for (j = 0; j < 8; j++)
 346   2                      {
 347   3                              if (crc16 & 0x0001)
 348   3                              {
 349   4                                      crc16 = (crc16 >> 1) ^ 0xa001;
 350   4                              }
 351   3                              else
 352   3                              {
 353   4                                      crc16 = crc16 >> 1;
 354   4                              }
 355   3                      }
 356   2              }
 357   1              return (crc16);
 358   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.60.0.0   REPORT                                                            03/03/2023 11:28:23 PAGE 7   

   CODE SIZE        =    895    ----
   CONSTANT SIZE    =     30    ----
   XDATA SIZE       =   6653      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
