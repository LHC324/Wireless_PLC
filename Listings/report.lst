C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 17:57:20 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE REPORT
OBJECT MODULE PLACED IN .\Objects\report.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\report.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeMod
                    -Bus\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\report.lst) OBJECT(.\Objects\report.obj)

line level    source

   1          #include "report.h"
   2          #include "usart.h"
   3          
   4          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest);
   5          void Uart_DataForward(SEL_CHANNEL Src, SEL_CHANNEL Dest);
   6          
   7          /*å®šä¹‰å½“å‰ä¸²å£äº¤æ¢åºåˆ—*/
   8          const ComData_Handle code ComData_Array[] =
   9                  {
  10                          // {CHANNEL_PLC, CHANNEL_RS485, Public_DataHandle},
  11                          {CHANNEL_WIFI, CHANNEL_PLC, Public_DataHandle},
  12                          {CHANNEL_LAN, CHANNEL_PLC, Public_DataHandle},
  13                          {CHANNEL_RS485, CHANNEL_PLC, Public_DataHandle},
  14                          /*ä½œä¸ºä¸»æœºæ—¶æƒ…å†µ*/
  15                          {CHANNEL_PLC, CHANNEL_WIFI, Public_DataHandle},
  16                          {CHANNEL_PLC, CHANNEL_LAN, Public_DataHandle},
  17                          {CHANNEL_PLC, CHANNEL_RS485, Public_DataHandle}
  18                  };
  19          
  20          #define COMDATA_SIZE (sizeof(ComData_Array) / sizeof(ComData_Handle))
  21          
  22          /*åˆ›å»º4æ¡é“¾é˜Ÿ*/
  23          Uart_List xdata Uart_LinkList[MAX_LQUEUE] = {0};
  24          
  25          /**
  26           * @brief       åˆå§‹åŒ–é™æ€é“¾é˜Ÿ
  27           * @details
  28           * @param       *List:å½“å‰é“¾é˜ŸæŒ‡é’ˆ
  29           * @retval      None
  30           */
  31          void Init_ListQueue(Uart_List *List)
  32          {
  33   1              uint8_t j = 0;
  34   1      
  35   1              for (j = 0; j < MAX_NODE; j++)
  36   1              {
  37   2                      /*åˆå§‹åŒ–é˜Ÿåˆ—æ•°æ®åŸŸ*/
  38   2                      List->LNode[j].Source_Channel = CHANNEL_IDLE;
  39   2                      List->LNode[j].Target_Channel = CHANNEL_IDLE;
  40   2                      List->LNode[j].Frame_Flag = false;
  41   2                      List->LNode[j].Timer_Flag = false;
  42   2                      List->LNode[j].Rx_Length = 0;
  43   2                      List->LNode[j].OverTime = MAX_SILENCE;
  44   2                      memset(&List->LNode[j].Rx_Buffer[0], 0, MAX_SIZE);
  45   2              }
  46   1              // List->Buffer_Size = buf_size;
  47   1              /*åˆå§‹åŒ–é“¾è¡¨èŠ‚ç‚¹è¯»å†™æŒ‡é’ˆ*/
  48   1              List->Wptr = List->Rptr = 0;
  49   1      }
  50          
  51          /**
  52           * @brief       ä¸²å£äº‹ä»¶å¤„ç†
  53           * @details
  54           * @param       None
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 17:57:20 PAGE 2   

  55           * @retval      None
  56           */
  57          void Uart_Handle(void)
  58          {
  59   1              static uint8_t i = 0;
  60   1      
  61   1              // /*å…³é—­ä¸²å£4æ¥æ”¶ä¸­æ–­*/
  62   1              // // S4CON &= ~S4REN;
  63   1              
  64   1              if (System_Parameter.WorkMode == SLAVE)
  65   1              {
  66   2                      for (i = 0; i < COMDATA_SIZE - 3U; i++)
  67   2                      {       
  68   3                              ComData_Array[i].pHandle(ComData_Array[i].Source_Channel, ComData_Array[i].Target_Channel);
  69   3                      }
  70   2              }
  71   1              else
  72   1              {
  73   2                      switch (System_Parameter.CurrentSlave)
  74   2                      {
  75   3                              case ETHERNET_ID: 
  76   3                              {
  77   4                                      ComData_Array[3].pHandle(ComData_Array[3].Source_Channel, ComData_Array[3].Target_Channel);
  78   4                              }break;
  79   3                              case WIFI_ID:
  80   3                              {
  81   4                                      ComData_Array[4].pHandle(ComData_Array[4].Source_Channel, ComData_Array[4].Target_Channel);
  82   4                              }break;
  83   3                              case RS485_ID:
  84   3                              {
  85   4                                      ComData_Array[5].pHandle(ComData_Array[5].Source_Channel, ComData_Array[5].Target_Channel);
  86   4                              }break;
  87   3                              default : break;
  88   3                      }
  89   2              }
  90   1              // ComData_Array[0].pHandle(ComData_Array[0].Source_Channel, ComData_Array[0].Target_Channel);
  91   1              // ComData_Array[1].pHandle(ComData_Array[1].Source_Channel, ComData_Array[1].Target_Channel);
  92   1              // ComData_Array[2].pHandle(ComData_Array[2].Source_Channel, ComData_Array[2].Target_Channel);
  93   1              // USART3_EN = 1;
  94   1              // Uartx_SendStr(&Uart3, "\x01\x02\x03", 3);
  95   1              // USART3_EN = 0;
  96   1              /*å½“å‰æ— è¯·æ±‚é€šé“*/
  97   1              // current_request_channel = CHANNEL_IDLE;
  98   1              // Rs485_to_Plc();
  99   1      
 100   1              // Public_DataHandle(CHANNEL_RS485, CHANNEL_PLC);
 101   1      
 102   1              // Public_DataHandle(CHANNEL_WIFI, CHANNEL_PLC);
 103   1              // Public_DataHandle(CHANNEL_LAN, CHANNEL_PLC);
 104   1      }
 105          
 106          /*ç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–è¯¥æ¨¡å—*/
 107          // #pragma OPTIMIZE(2)
 108          /**
 109           * @brief       è·å¾—ç›®æ ‡é€šé“é“¾è¡¨åœ°å€
 110           * @details
 111           * @param       channel é€šé“å·
 112           * @retval      p æŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆ
 113           */
 114          static Uart_List *Get_Target_Channel(channel)
 115          {
 116   1              Uart_List *p = NULL;
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 17:57:20 PAGE 3   

 117   1              switch (channel)
 118   1              {
 119   2              case CHANNEL_LAN:
 120   2                      p = &COM_UART1;
 121   2                      break;
 122   2              case CHANNEL_WIFI:
 123   2                      p = &COM_UART2;
 124   2                      break;
 125   2              case CHANNEL_RS485:
 126   2                      p = &COM_UART3;
 127   2                      break;
 128   2              case CHANNEL_PLC:
 129   2                      p = &COM_UART4;
 130   2                      break;
 131   2              default:
 132   2                      break;
 133   2              }
 134   1              return p;
 135   1      }
 136          
 137          /**
 138           * @brief       è·å¾—ç›®æ ‡é€šé“å¯¹åº”ä¸²å£
 139           * @details
 140           * @param       channel é€šé“å·
 141           * @retval      p æŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆ
 142           */
 143          static Uart_HandleTypeDef *Get_Target_Uart(channel)
 144          {
 145   1              Uart_HandleTypeDef *p = NULL;
 146   1              switch (channel)
 147   1              {
 148   2              case CHANNEL_LAN:
 149   2                      p = &Uart1;
 150   2                      break;
 151   2              case CHANNEL_WIFI:
 152   2                      p = &Uart2;
 153   2                      break;
 154   2              case CHANNEL_RS485:
 155   2                      p = &Uart3;
 156   2                      break;
 157   2              case CHANNEL_PLC:
 158   2                      p = &Uart4;
 159   2                      break;
 160   2              default:
 161   2                      break;
 162   2              }
 163   1              return p;
 164   1      }
 165          
 166          
 167          /**
 168           * @brief       æ•°æ®å¸§å…¬å…±è½¬å‘
 169           * @details
 170           * @param       src æ•°æ®æºè¯·æ±‚é€šé“
 171           * @param   dest æ•°æ®äº¤ä»˜é€šé“
 172           * @retval      None
 173           */
 174          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest) 
 175          {
 176   1              Uart_List * const psrc = Get_Target_Channel(src);
 177   1              Uart_List * const pdest = Get_Target_Channel(dest);
 178   1              Uart_HandleTypeDef * const psuart = Get_Target_Uart(src);
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 17:57:20 PAGE 4   

 179   1              Uart_HandleTypeDef * const peuart = Get_Target_Uart(dest);
 180   1              static uint8_t i = 0;
 181   1      
 182   1              if ((psrc == NULL) || (pdest == NULL) || (psuart == NULL) || (peuart == NULL))
 183   1              {
 184   2                      return;
 185   2              }
 186   1      #if (USE_PRINTF_DEBUG)
                      // printf ("psrc %d, pdest %d, %d, %d, %d, %d\r\n",
                      // (uint16_t)psrc, (uint16_t)pdest, (uint16_t)&COM_UART1, (uint16_t)&COM_UART2,
                      // (uint16_t)&COM_UART3, (uint16_t)&COM_UART4);
              #endif
 191   1              /*ä¸»æœºæ—¶plcç›®æ ‡é€šé“æ— æ³•ç¡®å®š*/
 192   1              if (System_Parameter.WorkMode == MASTER)
 193   1              {
 194   2                      psrc->LNode[psrc->Rptr].Target_Channel = dest;
 195   2              }
 196   1              /*æ£€æŸ¥å½“å‰èŠ‚ç‚¹æºåœ°å€å’Œç›®æ ‡åœ°å€æ˜¯å¦ä¸æ­£åœ¨æ‰§è¡Œä¸Šç›®æ ‡ç›¸åŒ*/
 197   1              if ((psrc->LNode[psrc->Rptr].Source_Channel == src) && (psrc->LNode[psrc->Rptr].Target_Channel == dest))
 198   1              {
 199   2                      /*æ£€æµ‹å‘èµ·è¯·æ±‚æ¥æ”¶ç¼“å†²åŒº*/
 200   2                      if (psrc->LNode[psrc->Rptr].Frame_Flag)
 201   2                      {
 202   3      #if (USE_PRINTF_DEBUG)
                                      printf("1->>source %bd, target %bd, pdest %d, ptr 0x%X\r\n",
                                      psrc->LNode[psrc->Rptr].Source_Channel, psrc->LNode[psrc->Rptr].Target_Channel, psrc, psrc->Rptr);
              #endif
 206   3                              /*æ ‡è®°è¯¥æ¥æ”¶å¸§ä»¥è¿›è¡Œå¤„ç†*/
 207   3                              psrc->LNode[psrc->Rptr].Frame_Flag = false;
 208   3                              if (dest == CHANNEL_RS485)
 209   3                              {
 210   4                                      /*å…è®¸485å‘é€*/
 211   4                                      USART3_EN = 1;
 212   4                                      /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½ä¸
             -åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 213   4                                      psrc->LNode[psrc->Rptr].Rx_Length += 1U;
 214   4                              }
 215   3                              /*å¯åŠ¨å¯¹åº”ç«¯ç¡¬ä»¶æ•°æ®è½¬å‘*/
 216   3                              Uartx_SendStr(peuart, psrc->LNode[psrc->Rptr].Rx_Buffer, psrc->LNode[psrc->Rptr].Rx_Length);
 217   3                              /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 218   3                              psrc->LNode[psrc->Rptr].Rx_Length = 0;
 219   3                              /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 220   3                              memset(&psrc->LNode[psrc->Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 221   3                              if (dest == CHANNEL_RS485)
 222   3                              {
 223   4                                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 224   4                                      USART3_EN = 0;
 225   4                              }
 226   3                              /*è¯»æŒ‡é’ˆæŒ‡åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹*/
 227   3                              psrc->Rptr = ((psrc->Rptr + 1U) % MAX_NODE);
 228   3                      }
 229   2              }
 230   1      
 231   1              for (i = 0; i < MAX_NODE; i++)
 232   1              {
 233   2                      if ((pdest->LNode[i].Source_Channel != dest) || (pdest->LNode[i].Target_Channel != src))
 234   2                      {
 235   3                              continue;
 236   3                      }
 237   2                      /*ç›®æ ‡è®¾å¤‡å‘å‡ºåº”ç­”*/
 238   2                      if (pdest->LNode[i].Frame_Flag)
 239   2                      {
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 17:57:20 PAGE 5   

 240   3      #if (USE_PRINTF_DEBUG)
                                      printf("2->>source %bd, target %bd, pdest %d, ptr 0x%X\r\n\r\n",
                                      pdest->LNode[i].Source_Channel, pdest->LNode[i].Target_Channel, pdest, i);
              #endif          
 244   3                              /*æ ‡è®°è¯¥æ¥æ”¶å¸§å·²ç»è¿›è¡Œå¤„ç†*/
 245   3                              pdest->LNode[i].Frame_Flag = false;
 246   3                              if (src == CHANNEL_RS485)
 247   3                              {
 248   4                                      /*å…è®¸485å‘é€*/
 249   4                                      USART3_EN = 1;
 250   4                                      /*æ•°æ®è½¬å‘ç»™RS485æ—¶ï¼Œæ•°æ®é•¿åº¦+1ï¼Œå¯ä»¥ä¿è¯MAX3485èŠ¯ç‰‡èƒ½å¤Ÿæœ€åä¸€ä½æ•°æ®åˆšå¥½ä¸
             -åœæ­¢åœ¨ä¸²å£çš„åœæ­¢ä½ä¸Š*/
 251   4                                      pdest->LNode[i].Rx_Length += 1U;
 252   4                              }
 253   3                              /*æ•°æ®è¿”å›ç»™è¯·æ±‚å¯¹è±¡*/
 254   3                              Uartx_SendStr(psuart, pdest->LNode[i].Rx_Buffer, pdest->LNode[i].Rx_Length);
 255   3                              /*æ¥æ”¶åˆ°æ•°æ®é•¿åº¦ç½®ä¸º0*/
 256   3                              pdest->LNode[i].Rx_Length = 0;
 257   3                              /*å‘é€ä¸­æ–­ç»“æŸåï¼Œæ¸…ç©ºå¯¹åº”æ¥æ”¶ç¼“å†²åŒº*/
 258   3                              memset(&pdest->LNode[i].Rx_Buffer[0], 0, MAX_SIZE);
 259   3                              if (src == CHANNEL_RS485)
 260   3                              {
 261   4                                      /*å‘é€å®Œä¸€å¸§æ•°æ®åæ‹‰ä½*/
 262   4                                      USART3_EN = 0;
 263   4                              }
 264   3                      }
 265   2              }
 266   1      }
 267          
 268          
 269          /*ç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–è¯¥æ¨¡å—*/
 270          #pragma OPTIMIZE(9)
 271          
 272          /**
 273           * @brief       è·å–16bitCRCç 
 274           * @details
 275           * @param       *ptr:å‚ä¸æ ¡éªŒæ•°æ®æŒ‡é’ˆ,length:æ•°æ®é•¿åº¦,init_dat:å‚ä¸è¿ç®—ç›®æ ‡æ•°æ®
 276           * @retval      None
 277           */
 278          uint16_t getCrc16(uint8_t *ptr, uint8_t length, uint16_t init_dat)
 279          {
 280   1              uint8_t i = 0;
 281   1              uint16_t j = 0;
 282   1              uint16_t crc16 = init_dat;
 283   1      
 284   1              for (i = 0; i < length; i++)
 285   1              {
 286   2                      crc16 ^= *ptr++;
 287   2      
 288   2                      for (j = 0; j < 8; j++)
 289   2                      {
 290   3                              if (crc16 & 0x0001)
 291   3                              {
 292   4                                      crc16 = (crc16 >> 1) ^ 0xa001;
 293   4                              }
 294   3                              else
 295   3                              {
 296   4                                      crc16 = crc16 >> 1;
 297   4                              }
 298   3                      }
 299   2              }
 300   1              return (crc16);
C51 COMPILER V9.60.0.0   REPORT                                                            12/21/2021 17:57:20 PAGE 6   

 301   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1150    ----
   CONSTANT SIZE    =     30    ----
   XDATA SIZE       =   6922      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
