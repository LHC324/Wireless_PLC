C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 09:21:04 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE REPORT
OBJECT MODULE PLACED IN .\Objects\report.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\report.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include;.\FreeMod
                    -Bus\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\report.lst) OBJECT(.\Objects\report.obj)

line level    source

   1          #include "report.h"
   2          #include "usart.h"
   3          
   4          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest);
   5          void Uart_DataForward(SEL_CHANNEL Src, SEL_CHANNEL Dest);
   6          void Plc_To_Rs485(void);
   7          void Wifi_To_Plc(void);
   8          void Rs485_to_Plc(void);
   9          
  10          /*定义当前串口交换序列*/
  11          // const ComData_Handle ComData_Array[] =
  12          //      {
  13          //              {CHANNEL_PLC, CHANNEL_RS485, Plc_To_Rs485},
  14          //              {CHANNEL_WIFI, CHANNEL_PLC, Wifi_To_Plc},
  15          //              //      {CHANNEL_LAN,  CHANNEL_PLC,   Lan_To_Plc}
  16          // };
  17          
  18          const ComData_Handle ComData_Array[] =
  19                  {
  20                          // {CHANNEL_PLC, CHANNEL_RS485, Public_DataHandle},
  21                          {CHANNEL_WIFI, CHANNEL_PLC, Public_DataHandle},
  22                          {CHANNEL_LAN, CHANNEL_PLC, Public_DataHandle},
  23                          {CHANNEL_RS485, CHANNEL_PLC, Public_DataHandle}};
  24          
  25          #define COMDATA_SIZE (sizeof(ComData_Array) / sizeof(ComData_Handle))
  26          
  27          /*创建4条链队*/
  28          Uart_List Uart_LinkList[MAX_LQUEUE];
  29          
  30          /**
  31           * @brief       初始化静态链队
  32           * @details
  33           * @param       *List:当前链队指针
  34           * @retval      None
  35           */
  36          void Init_ListQueue(Uart_List *List)
  37          {
  38   1              uint8_t i = 0;
  39   1      
  40   1              for (i = 0; i < MAX_NODE; i++)
  41   1              {
  42   2                      /*初始化队列数据域*/
  43   2                      List->LNode[i].Source_Channel = CHANNEL_IDLE;
  44   2                      List->LNode[i].Target_Channel = CHANNEL_IDLE;
  45   2                      List->LNode[i].Frame_Flag = false;
  46   2                      List->LNode[i].Timer_Flag = false;
  47   2                      List->LNode[i].Rx_Length = 0;
  48   2                      List->LNode[i].OverTime = MAX_SILENCE;
  49   2                      /*清空对应数据缓冲区*/
  50   2                      memset(&List->LNode[i].Rx_Buffer[0], 0, MAX_SIZE);
  51   2              }
  52   1              /*初始化链表节点读写指针*/
  53   1              List->Wptr = List->Rptr = 0;
  54   1      }
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 09:21:04 PAGE 2   

  55          
  56          /**
  57           * @brief       串口1对1数据转发
  58           * @details
  59           * @param       None
  60           * @retval      None
  61           */
  62          // void Uart_DataForward(SEL_CHANNEL Src, SEL_CHANNEL Dest)
  63          // {
  64          //      uint8_t i = 0;
  65          
  66          //      for (i = 0; i < COMDATA_SIZE; i++)
  67          //      {
  68          //              if ((Src == ComData_Array[i].Source_Channel) && (Dest == ComData_Array[i].Target_Channel))
  69          //              {
  70          //                      ComData_Array[i].pHandle();
  71          //              }
  72          //      }
  73          // }
  74          
  75          /**
  76           * @brief       串口事件处理
  77           * @details
  78           * @param       None
  79           * @retval      None
  80           */
  81          void Uart_Handle(void)
  82          {
  83   1              static uint8_t i = 0;
  84   1      
  85   1              // /*关闭串口4接收中断*/
  86   1              // // S4CON &= ~S4REN;
  87   1      
  88   1              // for (i = 0; i < COMDATA_SIZE; i++)
  89   1              // {
  90   1              //      ComData_Array[i].pHandle(ComData_Array[i].Source_Channel, ComData_Array[i].Target_Channel);
  91   1              // }
  92   1              // ComData_Array[0].pHandle(ComData_Array[0].Source_Channel, ComData_Array[0].Target_Channel);
  93   1              // ComData_Array[1].pHandle(ComData_Array[1].Source_Channel, ComData_Array[1].Target_Channel);
  94   1              // ComData_Array[2].pHandle(ComData_Array[2].Source_Channel, ComData_Array[2].Target_Channel);
  95   1              // USART3_EN = 1;
  96   1              // Uartx_SendStr(&Uart3, "\x01\x02\x03", 3);
  97   1              // USART3_EN = 0;
  98   1              /*当前无请求通道*/
  99   1              current_request_channel = CHANNEL_IDLE;
 100   1              // Rs485_to_Plc();
 101   1              Public_DataHandle(CHANNEL_RS485, CHANNEL_PLC);
 102   1              // Public_DataHandle(CHANNEL_WIFI, CHANNEL_PLC);
 103   1              // Public_DataHandle(CHANNEL_LAN, CHANNEL_PLC);
 104   1      }
*** WARNING C280 IN LINE 83 OF Source\report.c: 'i': unreferenced local variable
 105          
 106          /*禁止编译器优化该模块*/
 107          // #pragma OPTIMIZE(0)
 108          /**
 109           * @brief       获得目标通道链表地址
 110           * @details
 111           * @param       channel 通道号
 112           * @retval      p 指向链表的指针
 113           */
 114          static Uart_List *Get_Target_Channel(channel)
 115          {
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 09:21:04 PAGE 3   

 116   1              Uart_List *p = NULL;
 117   1              switch (channel)
 118   1              {
 119   2              case CHANNEL_LAN:
 120   2                      p = &COM_UART1;
 121   2                      break;
 122   2              case CHANNEL_WIFI:
 123   2                      p = &COM_UART2;
 124   2                      break;
 125   2              case CHANNEL_RS485:
 126   2                      p = &COM_UART3;
 127   2                      break;
 128   2              case CHANNEL_PLC:
 129   2                      p = &COM_UART4;
 130   2                      break;
 131   2              default:
 132   2                      break;
 133   2              }
 134   1              return p;
 135   1      }
 136          
 137          /**
 138           * @brief       获得目标通道对应串口
 139           * @details
 140           * @param       channel 通道号
 141           * @retval      p 指向链表的指针
 142           */
 143          static Uart_HandleTypeDef *Get_Target_Uart(channel)
 144          {
 145   1              Uart_HandleTypeDef *p = NULL;
 146   1              switch (channel)
 147   1              {
 148   2              case CHANNEL_LAN:
 149   2                      p = &Uart1;
 150   2                      break;
 151   2              case CHANNEL_WIFI:
 152   2                      p = &Uart2;
 153   2                      break;
 154   2              case CHANNEL_RS485:
 155   2                      p = &Uart3;
 156   2                      break;
 157   2              case CHANNEL_PLC:
 158   2                      p = &Uart4;
 159   2                      break;
 160   2              default:
 161   2                      break;
 162   2              }
 163   1              return p;
 164   1      }
 165          
 166          /**
 167           * @brief       请求发送方源数据处理
 168           * @details
 169           * @param       psrc 数据源请求通道
 170           * @param   peuart 目标串口
 171           * @retval      None
 172           */
 173          static void Source_DataHandle(Uart_List *psrc, Uart_HandleTypeDef *peuart)
 174          {
 175   1              if ((psrc == NULL) || (peuart == NULL))
 176   1              {
 177   2                      return;
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 09:21:04 PAGE 4   

 178   2              }
 179   1              /*检测发起请求接收缓冲区*/
 180   1              if ((psrc->LNode[psrc->Rptr].Frame_Flag))
 181   1              {
 182   2                      /*检查当前节点源地址和目标地址是否与正在执行上目标相同*/
 183   2                      // if ((psrc->LNode[psrc->Rptr].Source_Channel != src) || (psrc->LNode[psrc->Rptr].Target_Channel != des
             -t))
 184   2                      // {
 185   2                      //      return;
 186   2                      // }
 187   2                      /*标记该接收帧以进行处理*/
 188   2                      psrc->LNode[psrc->Rptr].Frame_Flag = false;
 189   2                      if (psrc->LNode[psrc->Rptr].Target_Channel == CHANNEL_RS485)
 190   2                      {
 191   3                              /*允许485发送*/
 192   3                              USART3_EN = 1;
 193   3                              /*数据转发给RS485时，数据长度+1，可以保证MAX3485芯片能够最后一位数据刚好不
             -停止在串口的停止位上*/
 194   3                              psrc->LNode[psrc->Rptr].Rx_Length += 1U;
 195   3                      }
 196   2                      /*启动对应端硬件数据转发*/
 197   2                      Uartx_SendStr(peuart, psrc->LNode[psrc->Rptr].Rx_Buffer, psrc->LNode[psrc->Rptr].Rx_Length);
 198   2                      /*接收到数据长度置为0*/
 199   2                      psrc->LNode[psrc->Rptr].Rx_Length = 0;
 200   2                      /*发送中断结束后，清空对应接收缓冲区*/
 201   2                      memset(&psrc->LNode[psrc->Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 202   2                      if (psrc->LNode[psrc->Rptr].Target_Channel == CHANNEL_RS485)
 203   2                      {
 204   3                              /*发送完一帧数据后拉低*/
 205   3                              USART3_EN = 0;
 206   3                      }
 207   2                      /*读指针指到下一个节点*/
 208   2                      psrc->Rptr = ((psrc->Rptr + 1U) % MAX_NODE);
 209   2              }
 210   1      }
 211          
 212          /**
 213           * @brief       目标响应方数据处理
 214           * @details
 215           * @param       pdest 数据源请求通道
 216           * @param   psuart 目标串口
 217           * @retval      None
 218           */
 219          static void Target_DataHandle(Uart_List *pdest, Uart_HandleTypeDef *psuart)
 220          {
 221   1              if ((pdest == NULL) || (psuart == NULL))
 222   1              {
 223   2                      return;
 224   2              }
 225   1              /*目标设备发出应答*/
 226   1              if ((pdest->LNode[pdest->Rptr].Frame_Flag))
 227   1              {
 228   2                      /*检查目标端是否与当前节点数据目标相同*/
 229   2                      // if ((pdest->LNode[pdest->Rptr].Source_Channel != dest) || (pdest->LNode[pdest->Rptr].Target_Channel !
             -= src))
 230   2                      // {
 231   2                      //      return;
 232   2                      // }
 233   2                      /*标记该接收帧已经进行处理*/
 234   2                      pdest->LNode[pdest->Rptr].Frame_Flag = false;
 235   2                      if (pdest->LNode[pdest->Rptr].Target_Channel == CHANNEL_RS485)
 236   2                      {
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 09:21:04 PAGE 5   

 237   3                              /*允许485发送*/
 238   3                              USART3_EN = 1;
 239   3                              /*数据转发给RS485时，数据长度+1，可以保证MAX3485芯片能够最后一位数据刚好不
             -停止在串口的停止位上*/
 240   3                              pdest->LNode[pdest->Rptr].Rx_Length += 1U;
 241   3                      }
 242   2                      /*数据返回给请求对象*/
 243   2                      Uartx_SendStr(psuart, pdest->LNode[pdest->Rptr].Rx_Buffer, pdest->LNode[pdest->Rptr].Rx_Length);
 244   2                      /*接收到数据长度置为0*/
 245   2                      pdest->LNode[pdest->Rptr].Rx_Length = 0;
 246   2                      /*发送中断结束后，清空对应接收缓冲区*/
 247   2                      memset(&pdest->LNode[pdest->Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 248   2                      if (pdest->LNode[pdest->Rptr].Target_Channel == CHANNEL_RS485)
 249   2                      {
 250   3                              /*发送完一帧数据后拉低*/
 251   3                              USART3_EN = 0;
 252   3                      }
 253   2                      /*读指针指到下一个节点*/
 254   2                      pdest->Rptr = ((pdest->Rptr + 1U) % MAX_NODE);
 255   2              }
 256   1      }
 257          
 258          /**
 259           * @brief       数据帧公共转发
 260           * @details
 261           * @param       src 数据源请求通道
 262           * @param   dest 数据交付通道
 263           * @retval      None
 264           */
 265          void Public_DataHandle(SEL_CHANNEL src, SEL_CHANNEL dest)
 266          {
 267   1              Source_DataHandle(Get_Target_Channel(src), Get_Target_Uart(dest));
 268   1              Target_DataHandle(Get_Target_Channel(dest), Get_Target_Uart(src));
 269   1      }
 270          
 271          void Rs485_to_Plc(void)
 272          {
 273   1              /*STC串口4收到PLC发出的数据*/
 274   1              if ((COM_UART3.LNode[COM_UART3.Rptr].Frame_Flag)) //&& (COM_UART4.LNode[COM_UART4.Rptr].Rx_Length)
 275   1              {
 276   2                      /*如果串口4接收到的数据帧不是EBM所需的，过滤掉*/
 277   2                      // if (COM_UART3.LNode[COM_UART3.Rptr].Rx_Buffer[0] != MODBUS_SLAVEADDR)
 278   2                      { /*标记该接收帧以进行处理*/
 279   3                              COM_UART3.LNode[COM_UART3.Rptr].Frame_Flag = false;
 280   3                              /*允许485发送*/
 281   3                              // USART3_EN = 1;
 282   3                              /*数据转发给RS485时，数据长度+1，可以保证MAX3485芯片能够最后一位数据刚好不
             -停止在串口的停止位上*/
 283   3                              Uartx_SendStr(&Uart4, COM_UART3.LNode[COM_UART3.Rptr].Rx_Buffer, COM_UART3.LNode[COM_UART3.Rptr].Rx_Len
             -gth + 1U);
 284   3                              /*接收到数据长度置为0*/
 285   3                              COM_UART3.LNode[COM_UART3.Rptr].Rx_Length = 0;
 286   3                              /*发送中断结束后，清空对应接收缓冲区*/
 287   3                              memset(&COM_UART3.LNode[COM_UART3.Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 288   3                              /*发送完一帧数据后拉低*/
 289   3                              // USART3_EN = 0;
 290   3                              /*读指针指到下一个节点*/
 291   3                              SET_RPTR(3);
 292   3                      }
 293   2      
 294   2                      /*目标设备发出应答*/
 295   2                      if ((COM_UART4.LNode[COM_UART4.Rptr].Frame_Flag)) //&& (COM_UART3.LNode[COM_UART3.Rptr].Rx_Length)
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 09:21:04 PAGE 6   

 296   2                      {
 297   3                              /*标记该接收帧已经进行处理*/
 298   3                              COM_UART4.LNode[COM_UART4.Rptr].Frame_Flag = false;
 299   3                              /*允许485发送*/
 300   3                              USART3_EN = 1;
 301   3                              /*数据返回给请求对象*/
 302   3                              Uartx_SendStr(&Uart3, COM_UART4.LNode[COM_UART4.Rptr].Rx_Buffer, COM_UART4.LNode[COM_UART4.Rptr].Rx_Len
             -gth + 1U);
 303   3                              /*接收到数据长度置为0*/
 304   3                              COM_UART4.LNode[COM_UART4.Rptr].Rx_Length = 0;
 305   3                              /*发送中断结束后，清空对应接收缓冲区*/
 306   3                              memset(&COM_UART4.LNode[COM_UART4.Rptr].Rx_Buffer[0], 0, MAX_SIZE);
 307   3                              /*发送完一帧数据后拉低*/
 308   3                              USART3_EN = 0;
 309   3                              /*读指针指到下一个节点*/
 310   3                              SET_RPTR(4);
 311   3                      }
 312   2              }
 313   1      }
 314          
 315          /*禁止编译器优化该模块*/
 316          // #pragma OPTIMIZE(0)
 317          
 318          /**
 319           * @brief       获取16bitCRC码
 320           * @details
 321           * @param       *ptr:参与校验数据指针,length:数据长度,init_dat:参与运算目标数据
 322           * @retval      None
 323           */
 324          uint16_t getCrc16(uint8_t *ptr, uint8_t length, uint16_t init_dat)
 325          {
 326   1              uint8_t i = 0;
 327   1              uint16_t j = 0;
 328   1              uint16_t crc16 = init_dat;
 329   1      
 330   1              for (i = 0; i < length; i++)
 331   1              {
 332   2                      crc16 ^= *ptr++;
 333   2      
 334   2                      for (j = 0; j < 8; j++)
 335   2                      {
 336   3                              if (crc16 & 0x0001)
 337   3                              {
 338   4                                      crc16 = (crc16 >> 1) ^ 0xa001;
 339   4                              }
 340   3                              else
 341   3                              {
 342   4                                      crc16 = crc16 >> 1;
 343   4                              }
 344   3                      }
 345   2              }
 346   1              return (crc16);
 347   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1212    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   2744      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   REPORT                                                            12/18/2021 09:21:04 PAGE 7   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
